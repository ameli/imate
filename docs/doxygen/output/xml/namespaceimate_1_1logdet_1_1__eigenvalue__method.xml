<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespaceimate_1_1logdet_1_1__eigenvalue__method" kind="namespace" language="Python">
    <compoundname>imate::logdet::_eigenvalue_method</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceimate_1_1logdet_1_1__eigenvalue__method_1a9514f0de2c73a9922234ff43d1546c66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.logdet._eigenvalue_method.eigenvalue_method</definition>
        <argsstring>(A, gram=False, p=1.0, return_info=False, eigenvalues=None, assume_matrix=&apos;gen&apos;, non_zero_eig_fraction=0.9)</argsstring>
        <name>eigenvalue_method</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
          <defval>1.0</defval>
        </param>
        <param>
          <type>return_info</type>
          <defname>return_info</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>eigenvalues</type>
          <defname>eigenvalues</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>assume_matrix</type>
          <defname>assume_matrix</defname>
          <defval>&apos;gen&apos;</defval>
        </param>
        <param>
          <type>non_zero_eig_fraction</type>
          <defname>non_zero_eig_fraction</defname>
          <defval>0.9</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Log-determinant of non-singular matrix using eigenvalue method.

Given the matrix :math:`\\mathbf{A}` and the real exponent :math:`p`, the
following is computed:

.. math::

    \\mathrm{logdet} \\left(\\mathbf{A}^p \\right) = p \\log_e \\vert
    \\det (\\mathbf{A}) \\vert.

If ``gram`` is `True`, then :math:`\\mathbf{A}` in the above is replaced by
the Gramian matrix :math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`, and the
following is instead computed:

.. math::

    \\mathrm{logdet} \\left((\\mathbf{A}^{\\intercal}\\mathbf{A})^p
    \\right) = 2p \\log_e \\vert \\det (\\mathbf{A}) \\vert.

Parameters
----------

A : numpy.ndarray, scipy.sparse
    A non-singular sparse or dense matrix.

    .. note::

        In the eigenvalue method, the matrix cannot be a type of
        :class:`Matrix` or :class:`imate.AffineMatrixFunction` classes.

gram : bool, default=False
    If `True`, the log-determinant of the Gramian matrix,
    :math:`(\\mathbf{A}^{\\intercal}\\mathbf{A})^p`, is computed. The
    Gramian matrix itself is not directly computed. If `False`, the
    log-determinant of :math:`\\mathbf{A}^p` is computed.

p : float, default=1.0
    The real exponent :math:`p` in :math:`\\mathbf{A}^p`.

return_info : bool, default=False
    If `True`, this function also returns a dictionary containing
    information about the inner computation, such as process time,
    algorithm settings, etc.

eigenvalues : array_like [`float`], default=None
    The array of all eigenvalues of `A`, if available. The size of this
    array must be the same as the size of `A`. If `None`, the eigenvalues
    of `A` are computed.

assume_matrix : str {&apos;gen&apos;, &apos;sym&apos;}, default: &apos;gen&apos;
    Type of matrix. `gen` assumes generic matrix, while `sym` assumes
    `A` is symmetric.

non_zero_eig_fraction : float, default=0.9
    A fraction (between `0` and `1`) of eigenvalues assumed to be non-zero.
    For large matrices, it is not possible to compute all eigenvalues, and
    only the largest eigenvalues can be computed and the rest are assumed
    to be negligible. By setting this parameter, a fraction of
    non-negligible eigenvalues is determined.

Returns
-------

logdet : float or numpy.array
    Log-determinant of `A`.

info : dict
    (Only if ``return_info`` is `True`) A dictionary of information with
    the following keys.

    * ``matrix``:
        * ``data_type``: `str`, {`float32`, `float64`, `float128`}, type of
          the matrix data.
        * ``gram``: `bool`, whether the matrix `A` or its Gramian is
          considered.
        * ``exponent``: `float`, the exponent `p` in :math:`\\mathbf{A}^p`.
        * ``assume_matrix``: `str`, {`gen`, `sym`}, determines whether
          matrix is generic or symmetric.
        * ``size``: `int`, the size of matrix `A`.
        * ``sparse``: `bool`, whether the matrix `A` is sparse or dense.
        * ``nnz``: `int`, if `A` is sparse, the number of non-zero elements
          of `A`.
        * ``density``: `float`, if `A` is sparse, the density of `A`, which
          is the `nnz` divided by size squared.
        * ``num_inquiries``: `int`, for the `eigenvalue` method, this is
          always `1`.

    * ``device``:
        * ``num_cpu_threads``: `int`, number of CPU threads used in shared
          memory parallel processing.
        * ``num_gpu_devices``: `int`, for the `eigenvalue` method, this is
          always `0`.
        * ``num_gpu_multiprocessors``: `int`, for the `eigenvalue` method,
          this is always `0`.
        * ``num_gpu_threads_per_multiprocessor``: `int`, for `eigenvalue`
          method, this is always `0`.

    * ``time``:
        * ``tot_wall_time``: `float`, total elapsed time of computation.
        * ``alg_wall_time``: `float`, elapsed time of computation during
          only the algorithm execution.
        * ``cpu_proc_time``: `float`, the CPU processing time of
          computation.

    * ``solver``:
        * ``version``: `str`, version of imate.
        * ``method``: &apos;eigenvalue&apos;

See Also
--------

imate.trace
imate.traceinv
imate.schatten

Notes
-----

**Computational Complexity:**

The eigenvalue method uses spectral decomposition. The computational
complexity of this method is :math:`\\mathcal{O}(n^3)` where :math:`n` is
the matrix size. This method is only suitable for small matrices
(:math:`n &lt; 2^{12}`). The solution is exact and can be used as a benchmark
to test randomized methods of computing log-determinant.

.. warning::

    It is not recommended to use this method for sparse matrices, as not
    all eigenvalues of sparse matrices can be computed.

Examples
--------

**Dense matrix:**

Compute the log-determinant of a sample sparse Toeplitz matrix created
by :func:`imate.toeplitz` function:

.. code-block:: python

    &gt;&gt;&gt; # Import packages
    &gt;&gt;&gt; from imate import toeplitz, logdet

    &gt;&gt;&gt; # Generate a sample symmetric matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)

    &gt;&gt;&gt; # Convert the sparse matrix to a dense matrix
    &gt;&gt;&gt; A = A.toarray()

    &gt;&gt;&gt; # Compute log-determinant with Cholesky method (default method)
    &gt;&gt;&gt; logdet(A, method=&apos;eigenvalue&apos;, assume_matrix=&apos;sym&apos;)
    138.62943611198907

**Precomputed Eigenvalues:**

Alternatively, compute the eigenvalues of `A` in advance, and pass it to
this function:

.. code-block:: python
    :emphasize-lines: 6

    &gt;&gt;&gt; # Compute eigenvalues of symmetric matrix A.
    &gt;&gt;&gt; from scipy.linalg import eigh
    &gt;&gt;&gt; eigenvalues = eigh(A, eigvals_only=True)

    &gt;&gt;&gt; # Pass the eigenvalues to logdet function
    &gt;&gt;&gt; logdet(A, method=&apos;eigenvalue&apos;, eigenvalues=eigenvalues)
    138.62943611198907

Pre-computing eigenvalues can be useful if :func:`imate.logdet` function
should be called repeatedly for the same matrix `A` but other parameters
may change, such as `p`.

**Print Information:**

Print information about the inner computation:

.. code-block:: python

    &gt;&gt;&gt; ld, info = logdet(A, method=&apos;eigenvalue&apos;, return_info=True)
    &gt;&gt;&gt; print(ld)
    138.6294361119891

    &gt;&gt;&gt; # Print dictionary neatly using pprint
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; pprint(info)
    {
        &apos;matrix&apos;: {
            &apos;assume_matrix&apos;: &apos;gen&apos;,
            &apos;data_type&apos;: b&apos;float64&apos;,
            &apos;density&apos;: 1.0,
            &apos;exponent&apos;: 1.0,
            &apos;gram&apos;: False,
            &apos;nnz&apos;: 10000,
            &apos;num_inquiries&apos;: 1,
            &apos;size&apos;: 100,
            &apos;sparse&apos;: False
        },
        &apos;solver&apos;: {
            &apos;method&apos;: &apos;eigenvalue&apos;,
            &apos;version&apos;: &apos;0.13.0&apos;
        },
        &apos;device&apos;: {
            &apos;num_cpu_threads&apos;: 8,
            &apos;num_gpu_devices&apos;: 0,
            &apos;num_gpu_multiprocessors&apos;: 0,
            &apos;num_gpu_threads_per_multiprocessor&apos;: 0
        },
        &apos;time&apos;: {
            &apos;alg_wall_time&apos;: 0.007327683997573331,
            &apos;cpu_proc_time&apos;: 0.014451992999999774,
            &apos;tot_wall_time&apos;: 0.007327683997573331
        }
    }

**Sparse matrix:**

Using a large matrix and ignoring 10% of its eigenvalues:

.. code-block:: python

    &gt;&gt;&gt; # Generate a symmetric sparse matrix
    &gt;&gt;&gt; A = toeplitz(2, 1, size=2000, gram=True)

    &gt;&gt;&gt; # Assume only 80% of eigenvalues of A are non-zero
    &gt;&gt;&gt; logdet(A, method=&apos;eigenvalue&apos;, assume_matrix=&apos;sym&apos;,
    ...        non_zero_eig_fraction=0.9)
    2451.2640192906174

The above result is only an approximation since not all eigenvalues of `A`
are taken into account. To compare with the exact solution, use
:func:`imate.sample_matrices.toeplitz_logdet` function.

.. code-block:: python

    &gt;&gt;&gt; from imate.sample_matrices import toeplitz_logdet
    &gt;&gt;&gt; toeplitz_logdet(2, 1, size=2000, gram=True)
    2772.588722239781

There is a significant difference between the approximation with 90% of
eigenvalues and the actual solution. Because of this, it is not recommended
to use the eigenvalue method to compute the log-determinant.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/logdet/_eigenvalue_method.py" line="32" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/logdet/_eigenvalue_method.py" bodystart="39" bodyend="351"/>
        <references refid="namespaceimate_1_1logdet_1_1__eigenvalue__method_1a02524dd5aef31cf7d1ce62e4f9a0de48" compoundref="logdet_2__eigenvalue__method_8py" startline="359" endline="422">imate.logdet._eigenvalue_method.check_arguments</references>
        <references refid="namespaceimate_1_1logdet_1_1__eigenvalue__method_1ac71640930637e12925d30277f3a16d38" compoundref="logdet_2__eigenvalue__method_8py" startline="427" endline="483">imate.logdet._eigenvalue_method.compute_eigenvalues</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1ab38dbfffdf3dd5a3599ec768dd704ba0" compoundref="matrix__utilities_8py" startline="21" endline="44">imate._linear_algebra.matrix_utilities.get_data_type_name</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1a85bc667db05d03b8beb694a069aa45cd" compoundref="matrix__utilities_8py" startline="60" endline="69">imate._linear_algebra.matrix_utilities.get_density</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1a98ba8778e91264e000ac383db223859b" compoundref="matrix__utilities_8py" startline="45" endline="59">imate._linear_algebra.matrix_utilities.get_nnz</references>
        <referencedby refid="namespaceimate_1_1logdet_1_1logdet_1a8047c87b7c5667157404a6c7b2a435a8" compoundref="logdet_8py" startline="29" endline="397">imate.logdet.logdet.logdet</referencedby>
        <referencedby refid="namespaceimate_1_1trace_1_1trace_1a206ae6c64fe73e263a6da1b0adb8fbff" compoundref="trace_8py" startline="29" endline="404">imate.trace.trace.trace</referencedby>
        <referencedby refid="namespaceimate_1_1traceinv_1_1traceinv_1af09d9b0af1471fa625846f791debb269" compoundref="traceinv_8py" startline="30" endline="440">imate.traceinv.traceinv.traceinv</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1logdet_1_1__eigenvalue__method_1a02524dd5aef31cf7d1ce62e4f9a0de48" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.logdet._eigenvalue_method.check_arguments</definition>
        <argsstring>(A, eigenvalues, gram, p, return_info, assume_matrix, non_zero_eig_fraction)</argsstring>
        <name>check_arguments</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>eigenvalues</type>
          <defname>eigenvalues</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
        </param>
        <param>
          <type>return_info</type>
          <defname>return_info</defname>
        </param>
        <param>
          <type>assume_matrix</type>
          <defname>assume_matrix</defname>
        </param>
        <param>
          <type>non_zero_eig_fraction</type>
          <defname>non_zero_eig_fraction</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Checks the type and value of the parameters.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/logdet/_eigenvalue_method.py" line="352" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/logdet/_eigenvalue_method.py" bodystart="359" bodyend="422"/>
        <referencedby refid="namespaceimate_1_1logdet_1_1__eigenvalue__method_1a9514f0de2c73a9922234ff43d1546c66" compoundref="logdet_2__eigenvalue__method_8py" startline="39" endline="351">imate.logdet._eigenvalue_method.eigenvalue_method</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1logdet_1_1__eigenvalue__method_1ac71640930637e12925d30277f3a16d38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.logdet._eigenvalue_method.compute_eigenvalues</definition>
        <argsstring>(A, assume_matrix, non_zero_eig_fraction, tol=1e-4)</argsstring>
        <name>compute_eigenvalues</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>assume_matrix</type>
          <defname>assume_matrix</defname>
        </param>
        <param>
          <type>non_zero_eig_fraction</type>
          <defname>non_zero_eig_fraction</defname>
        </param>
        <param>
          <type>tol</type>
          <defname>tol</defname>
          <defval>1e-4</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim></verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/logdet/_eigenvalue_method.py" line="423" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/logdet/_eigenvalue_method.py" bodystart="427" bodyend="483"/>
        <referencedby refid="namespaceimate_1_1logdet_1_1__eigenvalue__method_1a9514f0de2c73a9922234ff43d1546c66" compoundref="logdet_2__eigenvalue__method_8py" startline="39" endline="351">imate.logdet._eigenvalue_method.eigenvalue_method</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/logdet/_eigenvalue_method.py" line="1" column="1"/>
  </compounddef>
</doxygen>
