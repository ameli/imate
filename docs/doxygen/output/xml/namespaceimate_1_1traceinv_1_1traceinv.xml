<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespaceimate_1_1traceinv_1_1traceinv" kind="namespace" language="Python">
    <compoundname>imate::traceinv::traceinv</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1traceinv_1af09d9b0af1471fa625846f791debb269" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv.traceinv.traceinv</definition>
        <argsstring>(A, gram=False, p=1, return_info=False, method=&apos;cholesky&apos;, **options)</argsstring>
        <name>traceinv</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
          <defval>1</defval>
        </param>
        <param>
          <type>return_info</type>
          <defname>return_info</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>method</type>
          <defname>method</defname>
          <defval>&apos;cholesky&apos;</defval>
        </param>
        <param>
          <type>**</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Trace of inverse of non-singular matrix or linear operator.

Given the matrix or the linear operator :math:`\\mathbf{A}` and the real
exponent :math:`p`, the following is computed:

.. math::

    \\mathrm{trace} \\left(\\mathbf{A}^{-p} \\right).

If ``gram`` is `True`, then :math:`\\mathbf{A}` in the above is replaced by
the Gramian matrix :math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`, and the
following is instead computed:

.. math::

    \\mathrm{trace} \\left((\\mathbf{A}^{\\intercal}\\mathbf{A})^{-p}
    \\right).

If :math:`\\mathbf{A} = \\mathbf{A}(t)` is a linear operator of the class
:class:`imate.AffineMatrixFunction` with the parameter :math:`t`, then for
an input  tuple :math:`t = (t_1, \\dots, t_q)`, an array output of the size
:math:`q` is returned, namely:

.. math::

    \\mathrm{trace} \\left((\\mathbf{A}(t_i))^{-p} \\right),
    \\quad i=1, \\dots, q.

Parameters
----------

A : numpy.ndarray, scipy.sparse, :class:`imate.Matrix`, or \
        :class:`imate.AffineMatrixFunction`
    A non-singular sparse or dense matrix or linear operator. The linear
    operators :class:`imate.Matrix` and :class:`imate.AffineMatrixFunction`
    can be used only if ``method=slq``. See details in
    :ref:`slq method &lt;imate.traceinv.slq&gt;`. If ``method=cholesky``, the
    matrix `A` should be positive-definite. If ``method=slq`` and
    ``gram=False``, the input matrix `A` should be symmetric.

gram : bool, default=False
    If `True`, the trace of the Gramian matrix,
    :math:`(\\mathbf{A}^{\\intercal}\\mathbf{A})^{-p}`, is computed. The
    Gramian matrix itself is not directly computed. If `False`, the
    trace of :math:`\\mathbf{A}^{-p}` is computed.

p : float, default=1.0
    The exponent :math:`p` in :math:`\\mathbf{A}^{-p}`. 

    * If ``method=eigenvalue``, :math:`p` can be any real number. 
    * If ``method=cholesky``, :math:`p` should be an integer.
    * If ``method=hutchinson``, :math:`p` should be an integer.
    * If ``method=slq``, :math:`p` should be non-negative real number.

    .. note::

        If :math:`p &lt; 0`, use :func:`imate.trace` function.

return_info : bool, default=False
    If `True`, this function also returns a dictionary containing
    information about the inner computation, such as process time,
    algorithm settings, etc. See the documentation for each `method` for
    details.

method : {&apos;eigenvalue&apos;, &apos;cholesky&apos;, &apos;hutchinson&apos;, &apos;slq&apos;}, \
        default=&apos;cholesky&apos;
    The method of computing trace. See documentation for each
    method:

    * :ref:`eigenvalue &lt;imate.traceinv.eigenvalue&gt;`
    * :ref:`cholesky &lt;imate.traceinv.cholesky&gt;`
    * :ref:`hutchinson &lt;imate.traceinv.hutchinson&gt;`
    * :ref:`slq &lt;imate.traceinv.slq&gt;`

options : `**kwargs`
    Extra arguments that are specific to each method. See the documentation
    for each `method` for details.

Returns
-------

traceinv : float or numpy.array
    Trace of inverse of matrix. If ``method=slq`` and if `A` is of type
    :class:`imate.AffineMatrixFunction` with an array of ``parameters``,
    then the output is an array.

info : dict
    (Only if ``return_info`` is `True`) A dictionary of information with at
    least the following keys. Further keys specific to each method can be
    found in the documentation of each method.

    * ``matrix``:
        * ``data_type``: `str`, {`float32`, `float64`, `float128`}, type of
          the matrix data.
        * ``gram``: `bool`, whether the matrix `A` or its Gramian is
          considered.
        * ``exponent``: `float`, the exponent `p` in
          :math:`\\mathbf{A}^{-p}`.
        * ``size``: `int`, The size of matrix `A`.
        * ``sparse``: `bool`, whether the matrix `A` is sparse or dense.
        * ``nnz``: `int`, if `A` is sparse, the number of non-zero elements
          of `A`.
        * ``density``: `float`, if `A` is sparse, the density of `A`, which
          is the `nnz` divided by size squared.
        * ``num_inquiries``: `int`, The size of inquiries of each parameter
          of the linear operator `A`. If `A` is a matrix, this is always
          `1`. For more details see :ref:`slq method &lt;imate.traceinv.slq&gt;`.

    * ``device``:
        * ``num_cpu_threads``: `int`, number of CPU threads used in shared
          memory parallel processing.
        * ``num_gpu_devices``: `int`, number of GPU devices used in the
          multi-GPU (GPU farm) computation.
        * ``num_gpu_multiprocessors``: `int`, number of GPU
          multi-processors.
        * ``num_gpu_threads_per_multiprocessor``: `int`, number of GPU
          threads on each GPU multi-processor.

    * ``time``:
        * ``tot_wall_time``: `float`, total elapsed time of computation.
        * ``alg_wall_time``: `float`, elapsed time of computation during
          only the algorithm execution.
        * ``cpu_proc_time``: `float`, CPU processing time of computation.

    * ``solver``:
        * ``version``: `str`, version of imate.
        * ``method``: `str`, method of computation.

Raises
------

LinAlgError
    If ``method=cholesky`` and `A` is not positive-definite.

ImportError
    If the package has not been compiled with GPU support, but ``gpu`` is
    `True`. Either set ``gpu`` to `False` to use the existing installed
    package. Alternatively, export the environment variable ``USE_CUDA=1``
    and recompile the source code of the package.

See Also
--------

imate.trace
imate.logdet
imate.schatten

Notes
-----

**Method of Computation:**

See documentation for each method below.

* :ref:`eigenvalue &lt;imate.traceinv.eigenvalue&gt;`: uses spectral decomposition.
  Suitable for small matrices (:math:`n &lt; 2^{12}`). The solution is exact.
* :ref:`cholesky &lt;imate.traceinv.cholesky&gt;`: uses Cholesky decomposition.
  Suitable for moderate-size matrices (:math:`n &lt; 2^{15}`). Can only be
  applied to positive-definite matrices. The solution is exact.
* :ref:`hutchinson &lt;imate.traceinv.hutchinson&gt;`: uses stochastic Hutchinson
  method, which is a randomized algorithm. Can be used on very large
  matrices (:math:`n &gt; 2^{12}`). The solution is an approximation.
* :ref:`slq &lt;imate.traceinv.slq&gt;`: uses stochastic Lanczos quadrature
  (SLQ), which is a randomized algorithm. Can be used on very large
  matrices (:math:`n &gt; 2^{12}`). The solution is an approximation.

**Input Matrix:**

The input `A` can be either of:

* A matrix, such as `numpy.ndarray`, or `scipy.sparse`.
* A linear operator representing a matrix using :class:`imate.Matrix` (
  only if ``method=slq``).
* A linear operator representing a one-parameter family of an affine matrix
  function :math:`t \\mapsto \\mathbf{A} + t\\mathbf{B}`, using
  :class:`imate.AffineMatrixFunction` (only if ``method=slq``).

**Output:**

The output is a scalar. However, if `A` is the linear operator of the type
:class:`imate.AffineMatrixFunction` representing the matrix function
:math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{B}`, then if the parameter
:math:`t` is given as the tuple :math:`t = (t_1, \\dots, t_q)`, then the
output of this function is an array of size :math:`q` corresponding to the
trace of each :math:`\\mathbf{A}(t_i)`.

.. note::

    When `A` represents
    :math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{I}`, where
    :math:`\\mathbf{I}` is the identity matrix, and :math:`t` is given by
    a tuple :math:`t = (t_1, \\dots, t_q)`, by setting ``method=slq``, the
    computational cost of an array output of size `q` is the same as
    computing for a single :math:`t_i`. Namely, the trace of inverse of
    only :math:`\\mathbf{A}(t_1)` is computed, and the trace of inverse of
    the rest of :math:`q=2, \\dots, q` are obtained from the result of
    :math:`t_1` immediately.

Examples
--------

**Sparse matrix:**

Compute the trace of inverse of a sample sparse Toeplitz matrix created by
:func:`imate.toeplitz` function.

.. code-block:: python

    &gt;&gt;&gt; # Import packages
    &gt;&gt;&gt; from imate import toeplitz, traceinv

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100)

    &gt;&gt;&gt; # Compute trace of inverse with Cholesky method (default method)
    &gt;&gt;&gt; traceinv(A)
    50.0

Alternatively, compute the trace of
:math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`:

.. code-block:: python

    &gt;&gt;&gt; # Compute trace of inverse of the Gramian to the power of 3:
    &gt;&gt;&gt; traceinv(A, p=3, gram=True)
    13.315500685871099

**Output information:**

Print information about the inner computation:

.. code-block:: python

    &gt;&gt;&gt; ti, info = traceinv(A, return_info=True)
    &gt;&gt;&gt; print(ti)
    50.00

    &gt;&gt;&gt; # Print dictionary neatly using pprint
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; pprint(info)
    {
        &apos;matrix&apos;: {
            &apos;data_type&apos;: b&apos;float64&apos;,
            &apos;density&apos;: 0.0199,
            &apos;exponent&apos;: 1,
            &apos;gram&apos;: False,
            &apos;nnz&apos;: 199,
            &apos;num_inquiries&apos;: 1,
            &apos;size&apos;: 100,
            &apos;sparse&apos;: True
        },
        &apos;solver&apos;: {
            &apos;cholmod_used&apos;: True,
            &apos;invert_cholesky&apos;: True,
            &apos;method&apos;: &apos;cholesky&apos;,
            &apos;version&apos;: &apos;0.16.0&apos;
        },
        &apos;device&apos;: {
            &apos;num_cpu_threads&apos;: 8,
            &apos;num_gpu_devices&apos;: 0,
            &apos;num_gpu_multiprocessors&apos;: 0,
            &apos;num_gpu_threads_per_multiprocessor&apos;: 0
        },
        &apos;time&apos;: {
            &apos;alg_wall_time&apos;: 0.02655635983683169,
          &apos;cpu_proc_time&apos;: 0.028375134000000024,
          &apos;tot_wall_time&apos;: 0.02655635983683169
        }
    }

**Large matrix:**

Compute trace of inverse of a very large sparse matrix using `SLQ` method.
This method does not compute the trace of inverse exactly, rather, the
result is an approximation using Monte-Carlo sampling. The following
example uses at least `100` samples.

.. code-block:: python

    &gt;&gt;&gt; # Generate a matrix of size one million
    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000, gram=True)

    &gt;&gt;&gt; # Approximate of trace of inverse using stochastic Lanczos
    &gt;&gt;&gt; # quadrature with at least 100 Monte-Carlo sampling
    &gt;&gt;&gt; ti, info = traceinv(A, method=&apos;slq&apos;, min_num_samples=100,
    ...                     max_num_samples=200, return_info=True)
    &gt;&gt;&gt; print(ti)
    333440.32441422355

    &gt;&gt;&gt; # Find the time it took to compute the above
    &gt;&gt;&gt; print(info[&apos;time&apos;])
    {
        &apos;tot_wall_time&apos;: 16.256937585072592,
        &apos;alg_wall_time&apos;: 16.236278533935547,
        &apos;cpu_proc_time&apos;: 118.06356006200001
    }

Compare the result of the above approximation with the exact solution of
the trace of inverse using the analytic relation for Toeplitz matrix. See
:func:`imate.sample_matrices.toeplitz_traceinv` for details.

.. code-block:: python

    &gt;&gt;&gt; from imate.sample_matrices import toeplitz_traceinv
    &gt;&gt;&gt; toeplitz_traceinv(2, 1, size=1000000, gram=True)
    333333.2222222222

It can be seen that the error of approximation is :math:`0.032 \\%`. This
accuracy is remarkable considering that the computation on such a large
matrix took only a 16 seconds. Computing the trace of inverse of such a
large matrix using any of the exact methods (such as ``cholesky`` or
``eigenvalue``) is infeasible.

Alternatively, for large matrices, the Hutchinson method can be used:

.. code-block:: python

    &gt;&gt;&gt; # Approximate of trace of inverse using hutchinson method
    &gt;&gt;&gt; # with at least 100 Monte-Carlo sampling
    &gt;&gt;&gt; ti, info = traceinv(A, method=&apos;hutchinson&apos;, min_num_samples=100,
    ...                     max_num_samples=200, return_info=True)
    &gt;&gt;&gt; print(ti)
    333315.65986928536

    &gt;&gt;&gt; # Find the time it took to compute the above
    &gt;&gt;&gt; print(info[&apos;time&apos;])
    {
        &apos;tot_wall_time&apos;: 275.63905002200045,
        &apos;alg_wall_time&apos;: 215.36715987394564,
        &apos;cpu_proc_time&apos;: 860.377073873
    }

The above result with Hutchinson&apos;s method is remarkably close to the true
value with only `0.005 \\%` error, however, it takes longer time compared
to the SLQ method.

**Matrix operator:**

The following example uses an object of :class:`imate.Matrix`. Note that
this can be only applied to ``method=slq``. See further details in
:ref:`slq method &lt;imate.traceinv.slq&gt;`.

.. code-block:: python
    :emphasize-lines: 8

    &gt;&gt;&gt; # Import matrix operator
    &gt;&gt;&gt; from imate import toeplitz, traceinv, Matrix

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)

    &gt;&gt;&gt; # Create a matrix operator object from matrix A
    &gt;&gt;&gt; Aop = Matrix(A)

    &gt;&gt;&gt; # Compute trace of inverse of Aop
    &gt;&gt;&gt; traceinv(Aop, method=&apos;slq&apos;)
    32.996864881260656

**Affine matrix operator:**

The following example uses an object of
:class:`imate.AffineMatrixFunction` to create the linear operator:

.. math::

    t \\mapsto \\mathbf{A} + t \\mathbf{I}

Note that this can be only applied to ``method=slq``. See further details
in :ref:`slq method &lt;imate.traceinv.slq&gt;`.

.. code-block:: python
    :emphasize-lines: 8

    &gt;&gt;&gt; # Import affine matrix function
    &gt;&gt;&gt; from imate import toeplitz, traceinv, AffineMatrixFunction

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)

    &gt;&gt;&gt; # Create a matrix operator object from matrix A
    &gt;&gt;&gt; Aop = AffineMatrixFunction(A)

    &gt;&gt;&gt; # A list of parameters t to pass to Aop
    &gt;&gt;&gt; t = [0.5, 1.0, 1.5]

    &gt;&gt;&gt; # Compute trace of inverse of Aop for all parameters t
    &gt;&gt;&gt; traceinv(Aop, method=&apos;slq&apos;, parameters=t)
    array([26.23076982, 22.18309572, 19.38735934])
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/traceinv.py" line="24" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/traceinv.py" bodystart="30" bodyend="440"/>
        <references refid="namespaceimate_1_1logdet_1_1__cholesky__method_1aa890fbc6de58a24eb061fca38d7e1e81" compoundref="logdet_2__cholesky__method_8py" startline="42" endline="346">imate.logdet._cholesky_method.cholesky_method</references>
        <references refid="namespaceimate_1_1logdet_1_1__eigenvalue__method_1a9514f0de2c73a9922234ff43d1546c66" compoundref="logdet_2__eigenvalue__method_8py" startline="39" endline="351">imate.logdet._eigenvalue_method.eigenvalue_method</references>
        <references refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a62c0bc37cf02ed8dddf9d15fd56112ed" compoundref="__hutchinson__method_8pyx" startline="55" endline="720">imate.traceinv._hutchinson_method.hutchinson_method</references>
        <references refid="namespaceimate_1_1logdet_1_1__slq__method_1a8f7e56fdb6a71674cc894241ca2b152f" compoundref="logdet_2__slq__method_8pyx" startline="43" endline="836">imate.logdet._slq_method.slq_method</references>
        <referencedby refid="namespaceimate_1_1schatten_1_1schatten_1addd398048ffe6f31c8401438d3ab708e" compoundref="schatten_8py" startline="30" endline="467">imate.schatten.schatten.schatten</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/traceinv.py" line="1" column="1"/>
  </compounddef>
</doxygen>
