<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classcVectorOperations" kind="class" language="C++" prot="public">
    <compoundname>cVectorOperations</compoundname>
    <includes refid="c__vector__operations_8h" local="no">c_vector_operations.h</includes>
    <templateparamlist>
      <param>
        <type>typename DataType</type>
      </param>
    </templateparamlist>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classcVectorOperations_1a492894cdc368a4f60b28aa15109cf9bc" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cVectorOperations&lt; DataType &gt;::copy_vector</definition>
        <argsstring>(const DataType *input_vector, const LongIndexType vector_size, DataType *output_vector)</argsstring>
        <name>copy_vector</name>
        <param>
          <type>const DataType *</type>
          <declname>input_vector</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>output_vector</declname>
        </param>
        <briefdescription>
<para>Copies a vector to a new vector. Result is written in-place. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">input_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>A 1D array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of vector array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">output_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>Output vector (written in place). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" line="40" column="21" bodyfile="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.cpp" bodystart="39" bodyend="62"/>
        <referencedby refid="c__lanczos__tridiagonalization_8cpp_1a88831f1a1ba564b198f446a7c8a8d5ef" compoundref="c__lanczos__tridiagonalization_8cpp" startline="117" endline="236">c_lanczos_tridiagonalization</referencedby>
      </memberdef>
      <memberdef kind="function" id="classcVectorOperations_1a6627fe95659faa224dca2af1dab1fab3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cVectorOperations&lt; DataType &gt;::copy_scaled_vector</definition>
        <argsstring>(const DataType *input_vector, const LongIndexType vector_size, const DataType scale, DataType *output_vector)</argsstring>
        <name>copy_scaled_vector</name>
        <param>
          <type>const DataType *</type>
          <declname>input_vector</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>scale</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>output_vector</declname>
        </param>
        <briefdescription>
<para>Scales a vector and stores to a new vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">input_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>A 1D array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of vector array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">scale</parametername>
</parameternamelist>
<parameterdescription>
<para>Scale coefficient to the input vector. If this is equal to one, the function effectively becomes the same as <emphasis>copy_vector</emphasis>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">output_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>Output vector (written in place). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" line="46" column="21" bodyfile="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.cpp" bodystart="81" bodyend="107"/>
        <referencedby refid="c__lanczos__tridiagonalization_8cpp_1a88831f1a1ba564b198f446a7c8a8d5ef" compoundref="c__lanczos__tridiagonalization_8cpp" startline="117" endline="236">c_lanczos_tridiagonalization</referencedby>
        <referencedby refid="classcVectorOperations_1aeb0171f2644e3036907bbbddf47ce998" compoundref="c__vector__operations_8cpp" startline="389" endline="422">cVectorOperations&lt; DataType &gt;::normalize_vector_and_copy</referencedby>
      </memberdef>
      <memberdef kind="function" id="classcVectorOperations_1a9bd28bd08f5a6b096d99a4a2f7d23e90" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cVectorOperations&lt; DataType &gt;::subtract_scaled_vector</definition>
        <argsstring>(const DataType *input_vector, const LongIndexType vector_size, const DataType scale, DataType *output_vector)</argsstring>
        <name>subtract_scaled_vector</name>
        <param>
          <type>const DataType *</type>
          <declname>input_vector</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>scale</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>output_vector</declname>
        </param>
        <briefdescription>
<para>Subtracts the scaled input vector from the output vector. </para>
        </briefdescription>
        <detaileddescription>
<para>Performs the following operation: <formula id="12">\[ \boldsymbol{b} = \boldsymbol{b} - c \boldsymbol{a}, \]</formula> where<itemizedlist>
<listitem><para><formula id="13">$ \boldsymbol{a} $</formula> is the input vector,</para>
</listitem><listitem><para><formula id="14">$ c $</formula> is a scalar scale to the input vector, and</para>
</listitem><listitem><para><formula id="6">$ \boldsymbol{b} $</formula> is the output vector that is written in-place.</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">input_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>A 1D array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of vector array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">scale</parametername>
</parameternamelist>
<parameterdescription>
<para>Scale coefficient to the input vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">output_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>Output vector (written in place). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" line="53" column="21" bodyfile="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.cpp" bodystart="135" bodyend="166"/>
        <referencedby refid="classcAffineMatrixFunction_1a144b790e6cf7ef04d2b140a8031929a4" compoundref="c__affine__matrix__function_8cpp" startline="136" endline="145">cAffineMatrixFunction&lt; DataType &gt;::_add_scaled_vector</referencedby>
        <referencedby refid="c__golub__kahn__bidiagonalization_8cpp_1a6125b021cd93b43ab4d9f20813487f85" compoundref="c__golub__kahn__bidiagonalization_8cpp" startline="111" endline="232">c_golub_kahn_bidiagonalization</referencedby>
        <referencedby refid="c__lanczos__tridiagonalization_8cpp_1a88831f1a1ba564b198f446a7c8a8d5ef" compoundref="c__lanczos__tridiagonalization_8cpp" startline="117" endline="236">c_lanczos_tridiagonalization</referencedby>
        <referencedby refid="classcOrthogonalization_1a1b1bcbb636f1a1608ce7a22d4538b3b3" compoundref="c__orthogonalization_8cpp" startline="125" endline="224">cOrthogonalization&lt; DataType &gt;::gram_schmidt_process</referencedby>
        <referencedby refid="classcOrthogonalization_1a7b017e5520083a1cf3ac2ed27bb811d8" compoundref="c__orthogonalization_8cpp" startline="269" endline="401">cOrthogonalization&lt; DataType &gt;::orthogonalize_vectors</referencedby>
      </memberdef>
      <memberdef kind="function" id="classcVectorOperations_1ab8b945baba573b4479e8095ca87f8b3f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>DataType</type>
        <definition>DataType cVectorOperations&lt; DataType &gt;::inner_product</definition>
        <argsstring>(const DataType *vector1, const DataType *vector2, const LongIndexType vector_size)</argsstring>
        <name>inner_product</name>
        <param>
          <type>const DataType *</type>
          <declname>vector1</declname>
        </param>
        <param>
          <type>const DataType *</type>
          <declname>vector2</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <briefdescription>
<para>Computes Euclidean inner product of two vectors. </para>
        </briefdescription>
        <detaileddescription>
<para>The reduction variable (here, <computeroutput>inner_prod</computeroutput> ) is of the type <computeroutput>long double</computeroutput>. This is becase when <computeroutput>DataType</computeroutput> is <computeroutput>float</computeroutput>, the summation loses the precision, especially when the vector size is large. It seems that using <computeroutput>long double</computeroutput> is slightly faster than using <computeroutput>double</computeroutput>. The advantage of using a type with larger bits for the reduction variable is only sensible if the compiler is optimized with <computeroutput>-O2</computeroutput> or <computeroutput>-O3</computeroutput> flags.</para>
<para>Using a larger bit type for the reduction variable is very important for this function. If <computeroutput>DataType</computeroutput> is <computeroutput>float</computeroutput>, without such consideration, the result of estimation of trace can be completely wrong, just becase of the wrong inner product results. For large array sizes, even libraries such as openblas does not compute the dot product accurately.</para>
<para>The chunk computation of the dot product (as seen in the code with <computeroutput>chunk=5</computeroutput>) improves the preformance with gaining twice speedup. This result is not much dependet on <computeroutput>chunk</computeroutput>. For example, <computeroutput>chunk=10</computeroutput> also yields a similar result.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">vector1</parametername>
</parameternamelist>
<parameterdescription>
<para>1D array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector2</parametername>
</parameternamelist>
<parameterdescription>
<para>1D array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Inner product of two vectors. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" line="60" column="25" bodyfile="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.cpp" bodystart="204" bodyend="244"/>
        <referencedby refid="c__lanczos__tridiagonalization_8cpp_1a88831f1a1ba564b198f446a7c8a8d5ef" compoundref="c__lanczos__tridiagonalization_8cpp" startline="117" endline="236">c_lanczos_tridiagonalization</referencedby>
        <referencedby refid="classcOrthogonalization_1a1b1bcbb636f1a1608ce7a22d4538b3b3" compoundref="c__orthogonalization_8cpp" startline="125" endline="224">cOrthogonalization&lt; DataType &gt;::gram_schmidt_process</referencedby>
        <referencedby refid="classcOrthogonalization_1a7b017e5520083a1cf3ac2ed27bb811d8" compoundref="c__orthogonalization_8cpp" startline="269" endline="401">cOrthogonalization&lt; DataType &gt;::orthogonalize_vectors</referencedby>
      </memberdef>
      <memberdef kind="function" id="classcVectorOperations_1abd0d2c941f9d3598f42026755cbc4709" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>DataType</type>
        <definition>DataType cVectorOperations&lt; DataType &gt;::euclidean_norm</definition>
        <argsstring>(const DataType *vector, const LongIndexType vector_size)</argsstring>
        <name>euclidean_norm</name>
        <param>
          <type>const DataType *</type>
          <declname>vector</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <briefdescription>
<para>Computes the Euclidean norm of a 1D array. </para>
        </briefdescription>
        <detaileddescription>
<para>The reduction variable (here, <computeroutput>inner_prod</computeroutput> ) is of the type <computeroutput>long double</computeroutput>. This is becase when <computeroutput>DataType</computeroutput> is <computeroutput>float</computeroutput>, the summation loses the precision, especially when the vector size is large. It seems that using <computeroutput>long double</computeroutput> is slightly faster than using <computeroutput>double</computeroutput>. The advantage of using a type with larger bits for the reduction variable is only sensible if the compiler is optimized with <computeroutput>-O2</computeroutput> or <computeroutput>-O3</computeroutput> flags.</para>
<para>Using a larger bit type for the reduction variable is very important for this function. If <computeroutput>DataType</computeroutput> is <computeroutput>float</computeroutput>, without such consideration, the result of estimation of trace can be completely wrong, just becase of the wrong norm results. For large array sizes, even libraries such as openblas does not compute the dot product accurately.</para>
<para>The chunk computation of the dot product (as seen in the code with <computeroutput>chunk=5</computeroutput>) improves the preformance with gaining twice speedup. This result is not much dependet on <computeroutput>chunk</computeroutput>. For example, <computeroutput>chunk=10</computeroutput> also yields a similar result.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">vector</parametername>
</parameternamelist>
<parameterdescription>
<para>A pointer to 1D array </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of the array </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Euclidean norm </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" line="66" column="25" bodyfile="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.cpp" bodystart="281" bodyend="321"/>
        <referencedby refid="c__lanczos__tridiagonalization_8cpp_1a88831f1a1ba564b198f446a7c8a8d5ef" compoundref="c__lanczos__tridiagonalization_8cpp" startline="117" endline="236">c_lanczos_tridiagonalization</referencedby>
        <referencedby refid="classcOrthogonalization_1a1b1bcbb636f1a1608ce7a22d4538b3b3" compoundref="c__orthogonalization_8cpp" startline="125" endline="224">cOrthogonalization&lt; DataType &gt;::gram_schmidt_process</referencedby>
        <referencedby refid="classcVectorOperations_1aeb0171f2644e3036907bbbddf47ce998" compoundref="c__vector__operations_8cpp" startline="389" endline="422">cVectorOperations&lt; DataType &gt;::normalize_vector_and_copy</referencedby>
        <referencedby refid="classcVectorOperations_1ab0991d74cadf3a3969f0723dbff55dc9" compoundref="c__vector__operations_8cpp" startline="338" endline="370">cVectorOperations&lt; DataType &gt;::normalize_vector_in_place</referencedby>
        <referencedby refid="classcOrthogonalization_1a7b017e5520083a1cf3ac2ed27bb811d8" compoundref="c__orthogonalization_8cpp" startline="269" endline="401">cOrthogonalization&lt; DataType &gt;::orthogonalize_vectors</referencedby>
      </memberdef>
      <memberdef kind="function" id="classcVectorOperations_1ab0991d74cadf3a3969f0723dbff55dc9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>DataType</type>
        <definition>DataType cVectorOperations&lt; DataType &gt;::normalize_vector_in_place</definition>
        <argsstring>(DataType *vector, const LongIndexType vector_size)</argsstring>
        <name>normalize_vector_in_place</name>
        <param>
          <type>DataType *</type>
          <declname>vector</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <briefdescription>
<para>Normalizes a vector based on Euclidean 2-norm. The result is written in-place. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">vector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input vector to be normalized in-place. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of the input vector </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2-Norm of the input vector (before normalization) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" line="71" column="25" bodyfile="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.cpp" bodystart="338" bodyend="370"/>
        <references refid="classcVectorOperations_1abd0d2c941f9d3598f42026755cbc4709" compoundref="c__vector__operations_8cpp" startline="281" endline="321">cVectorOperations&lt; DataType &gt;::euclidean_norm</references>
        <referencedby refid="c__golub__kahn__bidiagonalization_8cpp_1a6125b021cd93b43ab4d9f20813487f85" compoundref="c__golub__kahn__bidiagonalization_8cpp" startline="111" endline="232">c_golub_kahn_bidiagonalization</referencedby>
      </memberdef>
      <memberdef kind="function" id="classcVectorOperations_1aeb0171f2644e3036907bbbddf47ce998" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>DataType</type>
        <definition>DataType cVectorOperations&lt; DataType &gt;::normalize_vector_and_copy</definition>
        <argsstring>(const DataType *vector, const LongIndexType vector_size, DataType *output_vector)</argsstring>
        <name>normalize_vector_and_copy</name>
        <param>
          <type>const DataType *</type>
          <declname>vector</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>output_vector</declname>
        </param>
        <briefdescription>
<para>Normalizes a vector based on Euclidean 2-norm. The result is written into another vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">vector</parametername>
</parameternamelist>
<parameterdescription>
<para>Input vector. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of the input vector </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">output_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>Output vector, which is the normalization of the input vector. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>2-norm of the input vector </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" line="76" column="25" bodyfile="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.cpp" bodystart="389" bodyend="422"/>
        <references refid="classcVectorOperations_1a6627fe95659faa224dca2af1dab1fab3" compoundref="c__vector__operations_8cpp" startline="81" endline="107">cVectorOperations&lt; DataType &gt;::copy_scaled_vector</references>
        <references refid="classcVectorOperations_1abd0d2c941f9d3598f42026755cbc4709" compoundref="c__vector__operations_8cpp" startline="281" endline="321">cVectorOperations&lt; DataType &gt;::euclidean_norm</references>
        <referencedby refid="c__golub__kahn__bidiagonalization_8cpp_1a6125b021cd93b43ab4d9f20813487f85" compoundref="c__golub__kahn__bidiagonalization_8cpp" startline="111" endline="232">c_golub_kahn_bidiagonalization</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A static class for vector operations, similar to level-1 operations of the BLAS library. This class acts as a templated namespace, where all member methods are <emphasis>public</emphasis> and <emphasis>static</emphasis>. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="see"><para>MatrixOperations </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" line="35" column="1" bodyfile="/home/sia/work/github/imate/imate/_c_basic_algebra/c_vector_operations.h" bodystart="36" bodyend="80"/>
    <listofallmembers>
      <member refid="classcVectorOperations_1a6627fe95659faa224dca2af1dab1fab3" prot="public" virt="non-virtual"><scope>cVectorOperations</scope><name>copy_scaled_vector</name></member>
      <member refid="classcVectorOperations_1a492894cdc368a4f60b28aa15109cf9bc" prot="public" virt="non-virtual"><scope>cVectorOperations</scope><name>copy_vector</name></member>
      <member refid="classcVectorOperations_1abd0d2c941f9d3598f42026755cbc4709" prot="public" virt="non-virtual"><scope>cVectorOperations</scope><name>euclidean_norm</name></member>
      <member refid="classcVectorOperations_1ab8b945baba573b4479e8095ca87f8b3f" prot="public" virt="non-virtual"><scope>cVectorOperations</scope><name>inner_product</name></member>
      <member refid="classcVectorOperations_1aeb0171f2644e3036907bbbddf47ce998" prot="public" virt="non-virtual"><scope>cVectorOperations</scope><name>normalize_vector_and_copy</name></member>
      <member refid="classcVectorOperations_1ab0991d74cadf3a3969f0723dbff55dc9" prot="public" virt="non-virtual"><scope>cVectorOperations</scope><name>normalize_vector_in_place</name></member>
      <member refid="classcVectorOperations_1a9bd28bd08f5a6b096d99a4a2f7d23e90" prot="public" virt="non-virtual"><scope>cVectorOperations</scope><name>subtract_scaled_vector</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
