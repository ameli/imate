<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespaceimate_1_1traceinv_1_1__cholesky__method" kind="namespace" language="Python">
    <compoundname>imate::traceinv::_cholesky_method</compoundname>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__cholesky__method_1a55965849f7d3a74fe6f251971e936515" prot="public" static="no" mutable="no">
        <type>bool</type>
        <definition>bool imate::traceinv::_cholesky_method::suitesparse_installed</definition>
        <argsstring></argsstring>
        <name>suitesparse_installed</name>
        <initializer>=  True</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" line="29" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" bodystart="29" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1__cholesky__method_1ac62318de9c8b4c44b65f2cc72c04f4a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv._cholesky_method.cholesky_method</definition>
        <argsstring>(A, gram=False, p=1, return_info=False, B=None, invert_cholesky=True, cholmod=None)</argsstring>
        <name>cholesky_method</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
          <defval>1</defval>
        </param>
        <param>
          <type>return_info</type>
          <defname>return_info</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>B</type>
          <defname>B</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>invert_cholesky</type>
          <defname>invert_cholesky</defname>
          <defval>True</defval>
        </param>
        <param>
          <type>cholmod</type>
          <defname>cholmod</defname>
          <defval>None</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Trace of inverse of non-singular matrix using Cholesky method.

Given the matrices :math:`\\mathbf{A}` and :math:`\\mathbf{B}` and the
integer exponent :math:`p`, the following is computed:

.. math::

    \\mathrm{trace} \\left(\\mathbf{A}^{-p} \\mathbf{B} \\right).

If ``B`` is `None`, it is assumed that :math:`\\mathbf{B}` is the identity
matrix.

If ``gram`` is `True`, then :math:`\\mathbf{A}` in the above is replaced by
the Gramian matrix :math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`, and the
following is instead computed:

.. math::

    \\mathrm{trace} \\left((\\mathbf{A}^{\\intercal}\\mathbf{A})^{-p}
    \\mathbf{B} \\right).

Parameters
----------

A : numpy.ndarray, scipy.sparse
    A positive-definite sparse or dense matrix.

    .. warning::

        This function does not pre-check whether the input matrix is
        positive-definite.

    .. note::

        In the Cholesky method, the matrix cannot be a type of
        :class:`Matrix` or :class:`imate.AffineMatrixFunction` classes.

gram : bool, default=False
    If `True`, the trace of the Gramian matrix,
    :math:`(\\mathbf{A}^{\\intercal}\\mathbf{A})^{-p}`, is computed. The
    Gramian matrix itself is not directly computed. If `False`, the
    trace of :math:`\\mathbf{A}^{-p}` is computed.

p : float, default=1.0
    The integer exponent :math:`p` in :math:`\\mathbf{A}^p`.

return_info : bool, default=False
    If `True`, this function also returns a dictionary containing
    information about the inner computation, such as process time,
    algorithm settings, etc.

B : numpy.ndarray, scipy.sparse
    A positive-definite sparse or dense matrix. `B` should be the same
    size and type of `A`. If `B` is `None`, is it assumed that the matrix
    `B` is identity.

    .. warning::

        This function does not pre-check whether the input matrix is
        positive-definite.

invert_cholesky : bool, default=True
    If `True`, the inverse of Cholesky decomposition is computed. This
    approach is fast but it is only suitable for small matrices. If set to
    `False`, it uses the inverse of Cholesky matrix indirectly (see Notes).
    This approach is suitable for larger matrices but slower.

cholmod : bool, default=None
    If set to `True`, it uses the `Cholmod` library from `scikit-sparse`
    package to compute the Cholesky decomposition. If set to `False`, it
    uses `scipy.sparse.cholesky` method. If set to `None`, first, it tries
    to use Cholmod library,  but if Cholmod is not available, then it uses
    `scipy.sparse.cholesky` method.

Returns
-------

traceinv : float or numpy.array
    Trace of inverse of `A`.

info : dict
    (Only if ``return_info`` is `True`) A dictionary of information with
    the following keys.

    * ``matrix``:
        * ``data_type``: `str`, {`float32`, `float64`, `float128`}. Type of
          the matrix data.
        * ``gram``: `bool`, whether the matrix `A` or its Gramian is
          considered.
        * ``exponent``: `float`, the exponent `p` in
          :math:`\\mathbf{A}^{-p}`.
        * ``size``: `int`, the size of matrix `A`.
        * ``sparse``: `bool`, whether the matrix `A` is sparse or dense.
        * ``nnz``: `int`, if `A` is sparse, the number of non-zero elements
          of `A`.
        * ``density``: `float`, if `A` is sparse, the density of `A`, which
          is the `nnz` divided by size squared.
        * ``num_inquiries``: `int`, for the `cholesky` method, this is
          always `1`.

    * ``device``:
        * ``num_cpu_threads``: `int`, number of CPU threads used in shared
          memory parallel processing.
        * ``num_gpu_devices``: `int`, for the `cholesky` method, this is
          always `0`.
        * ``num_gpu_multiprocessors``: `int`, for the `cholesky` method,
          this is always `0`.
        * ``num_gpu_threads_per_multiprocessor``: `int`, for the `cholesky`
          method, this is always `0`.

    * ``time``:
        * ``tot_wall_time``: `float`, total elapsed time of computation.
        * ``alg_wall_time``: `float`, elapsed time of computation during
          only the algorithm execution.
        * ``cpu_proc_time``: `float`, CPU processing time of computation.

    * ``solver``:
        * `cholmod_used`: `bool`, whether the Cholmod from SparseSuite
          library was used.
        * ``version``: `str`, version of imate.
        * ``method``: &apos;cholesky&apos;

See Also
--------

imate.trace
imate.logdet
imate.schatten

Notes
-----

**Algorithm:**

The trace of inverse is computed from the Cholesky decompositions
:math:`\\mathbf{A}^{p} = \\mathbf{L}_{\\vert p \\vert}
\\mathbf{L}_{\\vert p \\vert}^{\\intercal}` and :math:`\\mathbf{B} =
\\mathbf{L}_{\\mathbf{B}} \\mathbf{L}_{\\mathbf{B}}^{\\intercal}` as
follows:

.. math::

    \\mathrm{trace} \\left( \\mathbf{A}^{-p} \\mathbf{B} \\right) =
    \\Vert \\mathbf{L}_{\\vert p \\vert}^{-1} \\mathbf{L}_{\\mathbf{B}}
    \\Vert_F^2.

where :math:`\\Vert \\cdot \\Vert_F` is the Frobenius norm. If
``inverst_cholesky`` is `True`, the inverse
:math:`\\mathbf{L}_{\\vert p \\vert}^{-1}` is computed directly. Inverting
this matrix directly is only feasible for small matrices.

For larger matrices, set ``invert_cholesky`` to `False`. This approach
is slower than setting ``invert_cholesky`` to `True`, however, it can
process larger matrices. In this case,
:math:`\\Vert \\mathbf{L}_{\\vert p \\vert}^{-1} \\Vert_F^2`
is computed indirectly by

.. math::


    \\Vert \\mathbf{L}_{\\vert p \\vert}^{-1} \\Vert_F^2 =
    \\sum_{i=1}^n \\Vert \\boldsymbol{x}_i \\Vert^2,

where :math:`\\boldsymbol{x}_i` is solved by the lower-triangular system

.. math::

    \\mathbf{L}_{\\vert p \\vert} \\boldsymbol{x}_i = \\boldsymbol{b}_i,

where :math:`\\boldsymbol{b}_i` is the :math:`i`-th column of
:math:`\\mathbf{L}_{\\mathbf{B}}`. If `B` is `None`, then
:math:`\\mathbf{B}` is assumed to be the identity and hence,
:math:`\\boldsymbol{b}_i = (0, \dots, 0, 1, 0, \dots, 0)` is a
vector of zeross, except its :math:`i`-th element is `1`.

**Computational Complexity:**

The computational complexity of this method is
:math:`\\mathcal{O}(\\frac{1}{3}n^3)` for dense matrices and
:math:`\\mathcal{O}(\\frac{\\rho}{3} n^2)` for sparse matrices where
:math:`n` is the matrix size and :math:`\\rho` is the sparse matrix
density.

**Implementation:**

This function is essentially a wrapper for the Cholesky function of the
`scipy` and `scikit-sparse` packages and is primarily used for testing and
comparison (benchmarking) against the randomized methods that are
implemented in this package. If ``cholmod`` is set to `True`, this function
uses the `Suite Sparse
&lt;https://people.engr.tamu.edu/davis/suitesparse.html&gt;`_ package to compute
the Cholesky decomposition.

Examples
--------

Compute the trace of inverse of a sparse positive-definite Toeplitz matrix:

.. code-block:: python

    &gt;&gt;&gt; # Import packages
    &gt;&gt;&gt; from imate import toeplitz, traceinv

    &gt;&gt;&gt; # Generate a sample symmetric and positive-definite matrix
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)

    &gt;&gt;&gt; # Compute with Cholesky method (default method)
    &gt;&gt;&gt; traceinv(A, method=&apos;cholesky&apos;)
    33.22222222222223

Print information about the inner computation:

.. code-block:: python

    &gt;&gt;&gt; ti, info = traceinv(A, method=&apos;cholesky&apos;, return_info=True)
    &gt;&gt;&gt; print(ti)
    33.22222222222223

    &gt;&gt;&gt; # Print dictionary neatly using pprint
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; pprint(info)
    {
        &apos;matrix&apos;: {
            &apos;data_type&apos;: b&apos;float64&apos;,
            &apos;density&apos;: 0.0298,
            &apos;exponent&apos;: 1,
            &apos;gram&apos;: False,
            &apos;nnz&apos;: 298,
            &apos;num_inquiries&apos;: 1,
            &apos;size&apos;: 100,
            &apos;sparse&apos;: True
        },
        &apos;solver&apos;: {
            &apos;cholmod_used&apos;: True,
            &apos;invert_cholesky&apos;: True,
            &apos;method&apos;: &apos;cholesky&apos;,
            &apos;version&apos;: &apos;0.16.0&apos;
        },
        &apos;device&apos;: {
            &apos;num_cpu_threads&apos;: 8,
            &apos;num_gpu_devices&apos;: 0,
            &apos;num_gpu_multiprocessors&apos;: 0,
            &apos;num_gpu_threads_per_multiprocessor&apos;: 0
        },
        &apos;time&apos;: {
            &apos;alg_wall_time&apos;: 0.031367766903713346,
            &apos;cpu_proc_time&apos;: 0.03275534099998367,
            &apos;tot_wall_time&apos;: 0.031367766903713346
        }
    }
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" line="41" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" bodystart="48" bodyend="465"/>
        <references refid="namespaceimate_1_1traceinv_1_1__cholesky__method_1a6e0bd125eabdda2e4d83eb444e9aaa3f" compoundref="traceinv_2__cholesky__method_8py" startline="466" endline="530">imate.traceinv._cholesky_method.check_arguments</references>
        <references refid="namespaceimate_1_1traceinv_1_1__cholesky__method_1a8d752fa291e2a362a1d6fc7e392d0dd2" compoundref="traceinv_2__cholesky__method_8py" startline="531" endline="618">imate.traceinv._cholesky_method.compute_traceinv_invert_cholesky_directly</references>
        <references refid="namespaceimate_1_1traceinv_1_1__cholesky__method_1a64ef38548373fcb38023c24933f95970" compoundref="traceinv_2__cholesky__method_8py" startline="620" endline="752">imate.traceinv._cholesky_method.compute_traceinv_invert_cholesky_indirectly</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1ab38dbfffdf3dd5a3599ec768dd704ba0" compoundref="matrix__utilities_8py" startline="21" endline="44">imate._linear_algebra.matrix_utilities.get_data_type_name</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1a85bc667db05d03b8beb694a069aa45cd" compoundref="matrix__utilities_8py" startline="60" endline="69">imate._linear_algebra.matrix_utilities.get_density</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1a98ba8778e91264e000ac383db223859b" compoundref="matrix__utilities_8py" startline="45" endline="59">imate._linear_algebra.matrix_utilities.get_nnz</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1sparse__cholesky_1a98ab770378a6efc51dbd1b62a233e75a" compoundref="sparse__cholesky_8py" startline="23" endline="67">imate._linear_algebra.sparse_cholesky.sparse_cholesky</references>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1__cholesky__method_1a6e0bd125eabdda2e4d83eb444e9aaa3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv._cholesky_method.check_arguments</definition>
        <argsstring>(A, B, gram, p, invert_cholesky, cholmod)</argsstring>
        <name>check_arguments</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>B</type>
          <defname>B</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
        </param>
        <param>
          <type>invert_cholesky</type>
          <defname>invert_cholesky</defname>
        </param>
        <param>
          <type>cholmod</type>
          <defname>cholmod</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Checks the type and value of the parameters.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" line="466" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" bodystart="466" bodyend="530"/>
        <referencedby refid="namespaceimate_1_1traceinv_1_1__cholesky__method_1ac62318de9c8b4c44b65f2cc72c04f4a1" compoundref="traceinv_2__cholesky__method_8py" startline="48" endline="465">imate.traceinv._cholesky_method.cholesky_method</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1__cholesky__method_1a8d752fa291e2a362a1d6fc7e392d0dd2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv._cholesky_method.compute_traceinv_invert_cholesky_directly</definition>
        <argsstring>(L_A, L_B, sparse, use_cholmod)</argsstring>
        <name>compute_traceinv_invert_cholesky_directly</name>
        <param>
          <type>L_A</type>
          <defname>L_A</defname>
        </param>
        <param>
          <type>L_B</type>
          <defname>L_B</defname>
        </param>
        <param>
          <type>sparse</type>
          <defname>sparse</defname>
        </param>
        <param>
          <type>use_cholmod</type>
          <defname>use_cholmod</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Compute the trace of inverse by directly inverting the Cholesky matrix
:math:`\\mathbb{L}`.

.. note::

    * For small matrices: This method is much faster for small matrices
      than :py:func:`compute_traceinv_invert_cholesky_indirectly`.
    * For large matrices: This method is very slow and results are
      unstable.

.. warning::

    If scikit-sparse package is used to compute Cholesky decomposition,
    all computations are done using ``float64`` data type. The 32-bit type
    is not available in that package.

:param L_A: Cholesky factorization of matrix A
:type L_A: numpy.ndarray, scipy.sprase matrix, or sksparse.cholmod.Factor

:param L_B: Cholesky factorization of matrix B. If set to None, it is
    assumed that matrix B, and hence L_B, is identify.
:type L_B: numpy.ndarray, scipy.sprase matrix, or sksparse.cholmod.Factor

:param sparse: Flag, if ``true``, the matrix `L`` is considered as sparse.
:type sparse: bool

:param use_cholmod: If ``True``, uses ``scikit-sparse`` package to compute
    the Cholesky decomposition. If ``False``, uses ``scipy.sparse``
    package.
:type use_cholmod: bool

:return: Trace of matrix ``A``.
:rtype: float
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" line="531" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" bodystart="531" bodyend="618"/>
        <referencedby refid="namespaceimate_1_1traceinv_1_1__cholesky__method_1ac62318de9c8b4c44b65f2cc72c04f4a1" compoundref="traceinv_2__cholesky__method_8py" startline="48" endline="465">imate.traceinv._cholesky_method.cholesky_method</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1__cholesky__method_1a64ef38548373fcb38023c24933f95970" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv._cholesky_method.compute_traceinv_invert_cholesky_indirectly</definition>
        <argsstring>(L_A, L_B, n, sparse, use_cholmod, dtype)</argsstring>
        <name>compute_traceinv_invert_cholesky_indirectly</name>
        <param>
          <type>L_A</type>
          <defname>L_A</defname>
        </param>
        <param>
          <type>L_B</type>
          <defname>L_B</defname>
        </param>
        <param>
          <type>n</type>
          <defname>n</defname>
        </param>
        <param>
          <type>sparse</type>
          <defname>sparse</defname>
        </param>
        <param>
          <type>use_cholmod</type>
          <defname>use_cholmod</defname>
        </param>
        <param>
          <type>dtype</type>
          <defname>dtype</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Computes the trace of inverse by solving a linear system for Cholesky
matrix and each column of the identity matrix to obtain the inverse of
``L`` sub-sequentially.

The matrix :math:`\\mathbf{L}` is not inverted directly, rather, the linear
system

.. math::

    \\mathbf{L} \\boldsymbol{x}_i =
    \\boldsymbol{e}_i, \\qquad i = 1,\\dots,n

is solved, where
:math:`\\boldsymbol{e}_i = (0, \\dots, 0, 1, 0, \\dots, 0)^{\\intercal}` is
a column vector of zeros except its :math:`i`:superscript:`th` entry is one
and :math:`n` is the size of the square matrix :math:`\\mathbf{A}`. The
solution :math:`\\boldsymbol{x}_i` is the :math:`i`:superscript:`th` column
of :math:`\\mathbf{L}^{-1}`. Then, its Frobenius norm is

.. math::

    \\| \\mathbf{L} \\|_F^2 = \\sum_{i=1}^n \\| \\boldsymbol{x}_i \\|^2.

The method is memory efficient as the vectors :math:`\\boldsymbol{x}_i` do
not need to be stored, rather, their norm can be stored in each iteration.

.. note::

    This method is slow, and it should be used only if the direct matrix
    inversion can not be computed (such as for large matrices).

.. warning::

    If scikit-sparse package is used to compute Cholesky decomposition,
    all computations are done using ``float64`` data type. The 32-bit type
    is not available in that package.

:param L_A: Cholesky factorization of matrix A
:type L_A: numpy.ndarray, scipy.sprase matrix, or sksparse.cholmod.Factor

:param L_B: Cholesky factorization of matrix B. If set to None, it is
    assumed that matrix B, and hence L_B, is identify.
:type L_B: numpy.ndarray, scipy.sprase matrix, or sksparse.cholmod.Factor

:param sparse: Flag, if ``true``, the matrix ``L`` is considered as sparse.
:type sparse: bool

:param use_cholmod: If ``True``, uses ``scikit-sparse`` package to compute
    the Cholesky decomposition. If ``False``, uses ``scipy.sparse``
    package.
:type use_cholmod: bool

:param dtype: The data type of matrix.
:type dtype: string or numpy.dtype

:return: Trace of matrix ``A``.
:rtype: float
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" line="619" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" bodystart="620" bodyend="752"/>
        <referencedby refid="namespaceimate_1_1traceinv_1_1__cholesky__method_1ac62318de9c8b4c44b65f2cc72c04f4a1" compoundref="traceinv_2__cholesky__method_8py" startline="48" endline="465">imate.traceinv._cholesky_method.cholesky_method</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_cholesky_method.py" line="1" column="1"/>
  </compounddef>
</doxygen>
