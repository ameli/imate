<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classcuOrthogonalization" kind="class" language="C++" prot="public">
    <compoundname>cuOrthogonalization</compoundname>
    <includes refid="cu__orthogonalization_8h" local="no">cu_orthogonalization.h</includes>
    <templateparamlist>
      <param>
        <type>typename DataType</type>
      </param>
    </templateparamlist>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classcuOrthogonalization_1a47d7334cf9d9b69bb2feb047d40e0a23" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cuOrthogonalization&lt; DataType &gt;::gram_schmidt_process</definition>
        <argsstring>(cublasHandle_t cublas_handle, const DataType *V, const LongIndexType vector_size, const IndexType num_vectors, const IndexType last_vector, const FlagType num_ortho, DataType *r)</argsstring>
        <name>gram_schmidt_process</name>
        <param>
          <type>cublasHandle_t</type>
          <declname>cublas_handle</declname>
        </param>
        <param>
          <type>const DataType *</type>
          <declname>V</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>num_vectors</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>last_vector</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a67de833a333e9264ce27ee3d6e4b2732" kindref="member">FlagType</ref></type>
          <declname>num_ortho</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>r</declname>
          <defname>v</defname>
        </param>
        <briefdescription>
<para>Modified Gram-Schmidt orthogonalization process to orthogonalize the vector <computeroutput>v</computeroutput> against a subset of the column vectors in the array <computeroutput>V</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><computeroutput>V</computeroutput> is 1D array of the length <computeroutput>vector_size*num_vectors</computeroutput> to represent a 2D array of a set of <computeroutput>num_vectors</computeroutput> column vectors, each of the length <computeroutput>vector_size</computeroutput>. The length of <computeroutput>v</computeroutput> is also <computeroutput>vector_size</computeroutput>.</para>
<para><computeroutput>v</computeroutput> is orthogonalized against the last <computeroutput>num_ortho</computeroutput> columns of <computeroutput>V</computeroutput> starting from the column vector of the index <computeroutput>last_vector</computeroutput>. If the backward indexing from <computeroutput>last_vector</computeroutput> becomes a negative index, the index wraps around from the last column vector index, i.e., <computeroutput>num_vectors-1</computeroutput> .</para>
<para><itemizedlist>
<listitem><para>If <computeroutput>num_ortho</computeroutput> is zero, or if <computeroutput>num_vectors</computeroutput> is zero, no orthogonalization is performed.</para>
</listitem><listitem><para>If <computeroutput>num_ortho</computeroutput> is negative (usually set to <computeroutput>-1</computeroutput>), then <computeroutput>v</computeroutput> is orthogonalized against all column vectors of <computeroutput>V</computeroutput>.</para>
</listitem><listitem><para>If <computeroutput>num_ortho</computeroutput> is larger than <computeroutput>num_vectors</computeroutput>, then <computeroutput>v</computeroutput> is orthogonalized against all column vectors of <computeroutput>V</computeroutput>.</para>
</listitem><listitem><para>If <computeroutput>num_ortho</computeroutput> is smaller than <computeroutput>num_vectors</computeroutput>, then <computeroutput>v</computeroutput> is orthogonalized against the last <computeroutput>num_ortho</computeroutput> column vectors of <computeroutput>V</computeroutput>, starting from the column vector with the index <computeroutput>last_vector</computeroutput> toward its previous vectors. If the iteration runs into negativen column indices, the column indexing wraps around from the end of the columns from <computeroutput>num_vectors-1</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>The result of the newer <computeroutput>v</computeroutput> is written in-place in <computeroutput>v</computeroutput>.</para>
<para>If vector <computeroutput>v</computeroutput> is identical to one of the vectors in <computeroutput>V</computeroutput>, the orthogonalization against the identical vector is skipped.</para>
<para>If one of the column vectors of <computeroutput>V</computeroutput> is zero (have zero norm), that vector is ignored.</para>
<para><simplesect kind="note"><para>It is assumed that the caller function fills the column vectors of <computeroutput>V</computeroutput> periodically in a <emphasis>wrapped around</emphasis> order from column index <computeroutput>0</computeroutput>,1,... to <computeroutput>num_vectors-1</computeroutput>, and newer vectors are replaced on the wrapped index starting from index <computeroutput>0</computeroutput>,1,... again. Thus, <computeroutput>V</computeroutput> only stores the last <computeroutput>num_vectors</computeroutput> column vectors. The index of the last filled vector is indicated by <computeroutput>last_vector</computeroutput>.</para>
</simplesect>
<simplesect kind="warning"><para>The vector <computeroutput>v</computeroutput> can be indeed one of the columns of <computeroutput>V</computeroutput> itself. However, in this case, vector <computeroutput>v</computeroutput> must <emphasis>NOT</emphasis> be orthogonalized against itself, rather, it should only be orthogonalized to the other vectors in <computeroutput>V</computeroutput>. For instance, if <computeroutput>num_vectors=10</computeroutput>, and <computeroutput>v</computeroutput> is the 3rd vector of <computeroutput>V</computeroutput>, and if <computeroutput>num_ortho</computeroutput> is <computeroutput>6</computeroutput>, then we may set <computeroutput>last_vector=2</computeroutput>. Then <computeroutput>v</computeroutput> is orthogonalized againts the six columns <computeroutput>2</computeroutput>,1,0,9,8,7, where the last three of them are wrapped around the end of the columns.</para>
</simplesect>
<simplesect kind="see"><para>cu_golub_kahn_bidiagonalizaton, cu_lanczos_bidiagonalization</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">cublas_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuBLAS object handle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">V</parametername>
</parameternamelist>
<parameterdescription>
<para>1D coalesced array of vectors representing a 2D array. The length of this 1D array is <computeroutput>vector_size*num_vectors</computeroutput>, which indicates a 2D array with the shape <computeroutput></computeroutput>(vector_size,num_vectors). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>The length of each vector. If we assume <computeroutput>V</computeroutput> indicates a 2D vector, this is the number of rows of <computeroutput>V</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">num_vectors</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of column vectors. If we assume <computeroutput>V</computeroutput> indicates a 2D vector, this the number of columns of <computeroutput>V</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">last_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>The column vectors of the array <computeroutput>V</computeroutput> are rewritten by the caller function in wrapped-around order. That is, once all the columns (from the zeroth to the <computeroutput>num_vector-1</computeroutput> vector) are filled, the next vector is rewritten in the place of the zeroth vector, and the indices of newer vectors wrap around the columns of <computeroutput>V</computeroutput>. Thus, <computeroutput>V</computeroutput> only retains the last <computeroutput>num_vectors</computeroutput> vectors. The column index of the last written vector is given by <computeroutput>last_vector</computeroutput>. This index is a number between <computeroutput>0</computeroutput> and <computeroutput>num_vectors-1</computeroutput>. The index of the last i-th vector is winding back from the last vector by <computeroutput>last_vector-i+1 mod num_vectors</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">num_ortho</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of vectors to be orthogonalized starting from the last vector. <computeroutput>0</computeroutput> indicates no orthogonalization will be performed and the function just returns. A negative value means all vectors will be orthogonalized. A poisitive value will orthogonalize the given number of vectors. This value cannot be larger than the number of vectors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">v</parametername>
</parameternamelist>
<parameterdescription>
<para>The vector that will be orthogonalized against the columns of <computeroutput>V</computeroutput>. The length of <computeroutput>v</computeroutput> is <computeroutput>vector_size</computeroutput>. This vector is modified in-place. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_cu_trace_estimator/cu_orthogonalization.h" line="41" column="21" bodyfile="/home/sia/work/github/imate/imate/_cu_trace_estimator/cu_orthogonalization.cu" bodystart="128" bodyend="228"/>
        <references refid="classcuVectorOperations_1adc247988515923e3c79226e891c9f3e1" compoundref="cu__vector__operations_8cu" startline="201" endline="215">cuVectorOperations&lt; DataType &gt;::euclidean_norm</references>
        <references refid="classcuVectorOperations_1a88c6373da3d2fef0dca236aef3ef1ec1" compoundref="cu__vector__operations_8cu" startline="166" endline="183">cuVectorOperations&lt; DataType &gt;::inner_product</references>
        <references refid="classcuVectorOperations_1a516e90d70f99436cf48cd5b7deeb69c7" compoundref="cu__vector__operations_8cu" startline="126" endline="147">cuVectorOperations&lt; DataType &gt;::subtract_scaled_vector</references>
        <referencedby refid="cu__golub__kahn__bidiagonalization_8cu_1aa755f765f48f41b63d9dab3528b5f0b2" compoundref="cu__golub__kahn__bidiagonalization_8cu" startline="113" endline="242">cu_golub_kahn_bidiagonalization</referencedby>
        <referencedby refid="cu__lanczos__tridiagonalization_8cu_1a30ec831ebcc2ce17eefefb770b13773d" compoundref="cu__lanczos__tridiagonalization_8cu" startline="119" endline="248">cu_lanczos_tridiagonalization</referencedby>
      </memberdef>
      <memberdef kind="function" id="classcuOrthogonalization_1aefd27369921be5760a998a60aca49b56" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cuOrthogonalization&lt; DataType &gt;::orthogonalize_vectors</definition>
        <argsstring>(cublasHandle_t cublas_handle, DataType *vectors, const LongIndexType vector_size, const IndexType num_vectors)</argsstring>
        <name>orthogonalize_vectors</name>
        <param>
          <type>cublasHandle_t</type>
          <declname>cublas_handle</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>vectors</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a4918759cb64dcead17269b3613b27d25" kindref="member">LongIndexType</ref></type>
          <declname>vector_size</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>num_vectors</declname>
        </param>
        <briefdescription>
<para>Orthogonalizes set of vectors mutually using modified Gram-Schmidt process. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>Let <computeroutput>m</computeroutput> be the number of vectors (<computeroutput>num_vectors</computeroutput>), and let <computeroutput>n</computeroutput> be the size of each vector (<computeroutput>vector_size</computeroutput>). In general, <computeroutput>n</computeroutput> is much larger (large matrix size), and <computeroutput>m</computeroutput> is small, in order of a couple of hundred. But for small matrices (where <computeroutput>n</computeroutput> could be smaller then <computeroutput>m</computeroutput>), then each vector can be orthogonalized at most to <computeroutput>n</computeroutput> other vectors. This is because the dimension of the vector space is <computeroutput>n</computeroutput>. Thus, if there are extra vectors, each vector is orthogonalized to window of the previous <computeroutput>n</computeroutput> vector.</para>
</simplesect>
If one of the column vectors is identical to one of other column vectors in <computeroutput>V</computeroutput>, one of the vectors is regenerated by random array and the orthogonalization is repeated.</para>
<para><simplesect kind="note"><para>If two vectors are identical (or the norm of their difference is very small), they cannot be orthogonalized against each other. In this case, one of the vectors is re-generated by new random numbers.</para>
</simplesect>
<simplesect kind="warning"><para>if <computeroutput>num_vectors</computeroutput> is larger than <computeroutput>vector_size</computeroutput>, the orthogonalization fails since not all vectors are independent, and at least one vector becomes zero.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">cublas_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>The cuBLAS object handle. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">vectors</parametername>
</parameternamelist>
<parameterdescription>
<para>2D array of size <computeroutput>vector_size*num_vectors</computeroutput>. This array will be modified in-place and will be output of this function. Note that this is Fortran ordering, meaning that the first index is contiguous. Hence, to call the j-th element of the i-th vector, use <computeroutput>&amp;vectors</computeroutput>[i*vector_size + j]. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">num_vectors</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of columns of vectors array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vector_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows of vectors array. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_cu_trace_estimator/cu_orthogonalization.h" line="51" column="21" bodyfile="/home/sia/work/github/imate/imate/_cu_trace_estimator/cu_orthogonalization.cu" bodystart="275" bodyend="436"/>
        <references refid="classCudaInterface_1a95efada2ca34b3490f96ccfa97b4d6eb" compoundref="cuda__interface_8cu" startline="142" endline="151">CudaInterface&lt; ArrayType &gt;::copy_to_device</references>
        <references refid="classcuVectorOperations_1adc247988515923e3c79226e891c9f3e1" compoundref="cu__vector__operations_8cu" startline="201" endline="215">cuVectorOperations&lt; DataType &gt;::euclidean_norm</references>
        <references refid="classRandomArrayGenerator_1a3a577526f391d531fe4d66bdfa0107db" compoundref="random__array__generator_8cpp" startline="63" endline="160">RandomArrayGenerator&lt; DataType &gt;::generate_random_array</references>
        <references refid="classcuVectorOperations_1a88c6373da3d2fef0dca236aef3ef1ec1" compoundref="cu__vector__operations_8cu" startline="166" endline="183">cuVectorOperations&lt; DataType &gt;::inner_product</references>
        <references refid="classcuVectorOperations_1a516e90d70f99436cf48cd5b7deeb69c7" compoundref="cu__vector__operations_8cu" startline="126" endline="147">cuVectorOperations&lt; DataType &gt;::subtract_scaled_vector</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A static class for orthogonalization of vector bases. This class acts as a templated namespace, where all member methods are <emphasis>public</emphasis> and <emphasis>static</emphasis>. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="see"><para>RandomVectors </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="/home/sia/work/github/imate/imate/_cu_trace_estimator/cu_orthogonalization.h" line="36" column="1" bodyfile="/home/sia/work/github/imate/imate/_cu_trace_estimator/cu_orthogonalization.h" bodystart="37" bodyend="56"/>
    <listofallmembers>
      <member refid="classcuOrthogonalization_1a47d7334cf9d9b69bb2feb047d40e0a23" prot="public" virt="non-virtual"><scope>cuOrthogonalization</scope><name>gram_schmidt_process</name></member>
      <member refid="classcuOrthogonalization_1aefd27369921be5760a998a60aca49b56" prot="public" virt="non-virtual"><scope>cuOrthogonalization</scope><name>orthogonalize_vectors</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
