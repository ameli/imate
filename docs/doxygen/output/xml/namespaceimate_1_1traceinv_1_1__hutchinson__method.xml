<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespaceimate_1_1traceinv_1_1__hutchinson__method" kind="namespace" language="Python">
    <compoundname>imate::traceinv::_hutchinson_method</compoundname>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a5c0ee10f6b319d85c405a472c17ad4b6" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate::traceinv::_hutchinson_method.OpE</definition>
        <argsstring></argsstring>
        <name>OpE</name>
        <initializer>=  <ref refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1ab5336c2a043e91f8cbd8770a608bd3cb" kindref="member">_operator_dot</ref>(A, AtA, p, gram, assume_matrix, solver_tol, B, E)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="957" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="957" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1acca0bb5046e28f7d03f85ac967d0234a" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate::traceinv::_hutchinson_method.memoryview_E</definition>
        <argsstring></argsstring>
        <name>memoryview_E</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="964" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="964" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a1e6c31419e99911fbfefddd7aed3ff96" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate::traceinv::_hutchinson_method.cE</definition>
        <argsstring></argsstring>
        <name>cE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="965" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="965" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1aaa47cfd43f1ea4dc63ec8cf839f64574" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate::traceinv::_hutchinson_method.memoryview_OpE</definition>
        <argsstring></argsstring>
        <name>memoryview_OpE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="968" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="968" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a0e40e1c0432edbd1685f5ea088661471" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate::traceinv::_hutchinson_method.cOpE</definition>
        <argsstring></argsstring>
        <name>cOpE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="969" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="969" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1ac91710305a887e168c64096ecc63db6c" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate::traceinv::_hutchinson_method.vector_size</definition>
        <argsstring></argsstring>
        <name>vector_size</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="972" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="972" bodyend="-1"/>
        <referencedby refid="classcAffineMatrixFunction_1a144b790e6cf7ef04d2b140a8031929a4" compoundref="c__affine__matrix__function_8cpp" startline="136" endline="145">cAffineMatrixFunction&lt; DataType &gt;::_add_scaled_vector</referencedby>
        <referencedby refid="classcuAffineMatrixFunction_1af0a51e03280f6700f6534a94874436c1" compoundref="cu__affine__matrix__function_8cu" startline="131" endline="144">cuAffineMatrixFunction&lt; DataType &gt;::_add_scaled_vector</referencedby>
        <referencedby refid="classcVectorOperations_1a6627fe95659faa224dca2af1dab1fab3" compoundref="c__vector__operations_8cpp" startline="81" endline="107">cVectorOperations&lt; DataType &gt;::copy_scaled_vector</referencedby>
        <referencedby refid="classcuVectorOperations_1a18e8a8069b986b0b559f8ac97b72a495" compoundref="cu__vector__operations_8cu" startline="73" endline="96">cuVectorOperations&lt; DataType &gt;::copy_scaled_vector</referencedby>
        <referencedby refid="classcVectorOperations_1a492894cdc368a4f60b28aa15109cf9bc" compoundref="c__vector__operations_8cpp" startline="39" endline="62">cVectorOperations&lt; DataType &gt;::copy_vector</referencedby>
        <referencedby refid="classcuVectorOperations_1a08467db301f35f715fb07e4ec4907406" compoundref="cu__vector__operations_8cu" startline="38" endline="52">cuVectorOperations&lt; DataType &gt;::copy_vector</referencedby>
        <referencedby refid="namespacecusparse__interface_1a3d268461daf7d42e2a41d13ea8f3b762" compoundref="cusparse__interface_8cu" startline="122" endline="131">cusparse_interface::create_cusparse_vector&lt; double &gt;</referencedby>
        <referencedby refid="namespacecusparse__interface_1a9b5ea1b0435f889dd218d36e892ad529" compoundref="cusparse__interface_8cu" startline="98" endline="107">cusparse_interface::create_cusparse_vector&lt; float &gt;</referencedby>
        <referencedby refid="classcVectorOperations_1abd0d2c941f9d3598f42026755cbc4709" compoundref="c__vector__operations_8cpp" startline="281" endline="321">cVectorOperations&lt; DataType &gt;::euclidean_norm</referencedby>
        <referencedby refid="classcuVectorOperations_1adc247988515923e3c79226e891c9f3e1" compoundref="cu__vector__operations_8cu" startline="201" endline="215">cuVectorOperations&lt; DataType &gt;::euclidean_norm</referencedby>
        <referencedby refid="classcOrthogonalization_1a1b1bcbb636f1a1608ce7a22d4538b3b3" compoundref="c__orthogonalization_8cpp" startline="125" endline="224">cOrthogonalization&lt; DataType &gt;::gram_schmidt_process</referencedby>
        <referencedby refid="classcuOrthogonalization_1a47d7334cf9d9b69bb2feb047d40e0a23" compoundref="cu__orthogonalization_8cu" startline="128" endline="228">cuOrthogonalization&lt; DataType &gt;::gram_schmidt_process</referencedby>
        <referencedby refid="classcVectorOperations_1ab8b945baba573b4479e8095ca87f8b3f" compoundref="c__vector__operations_8cpp" startline="204" endline="244">cVectorOperations&lt; DataType &gt;::inner_product</referencedby>
        <referencedby refid="classcuVectorOperations_1a88c6373da3d2fef0dca236aef3ef1ec1" compoundref="cu__vector__operations_8cu" startline="166" endline="183">cuVectorOperations&lt; DataType &gt;::inner_product</referencedby>
        <referencedby refid="classcVectorOperations_1aeb0171f2644e3036907bbbddf47ce998" compoundref="c__vector__operations_8cpp" startline="389" endline="422">cVectorOperations&lt; DataType &gt;::normalize_vector_and_copy</referencedby>
        <referencedby refid="classcuVectorOperations_1ace661476791a4a662aab05c9af19b94a" compoundref="cu__vector__operations_8cu" startline="273" endline="290">cuVectorOperations&lt; DataType &gt;::normalize_vector_and_copy</referencedby>
        <referencedby refid="classcuVectorOperations_1a624e0023a7be0d361c31be756229b68c" compoundref="cu__vector__operations_8cu" startline="234" endline="252">cuVectorOperations&lt; DataType &gt;::normalize_vector_in_place</referencedby>
        <referencedby refid="classcVectorOperations_1ab0991d74cadf3a3969f0723dbff55dc9" compoundref="c__vector__operations_8cpp" startline="338" endline="370">cVectorOperations&lt; DataType &gt;::normalize_vector_in_place</referencedby>
        <referencedby refid="classcuOrthogonalization_1aefd27369921be5760a998a60aca49b56" compoundref="cu__orthogonalization_8cu" startline="275" endline="436">cuOrthogonalization&lt; DataType &gt;::orthogonalize_vectors</referencedby>
        <referencedby refid="classcOrthogonalization_1a7b017e5520083a1cf3ac2ed27bb811d8" compoundref="c__orthogonalization_8cpp" startline="269" endline="401">cOrthogonalization&lt; DataType &gt;::orthogonalize_vectors</referencedby>
        <referencedby refid="classcVectorOperations_1a9bd28bd08f5a6b096d99a4a2f7d23e90" compoundref="c__vector__operations_8cpp" startline="135" endline="166">cVectorOperations&lt; DataType &gt;::subtract_scaled_vector</referencedby>
        <referencedby refid="classcuVectorOperations_1a516e90d70f99436cf48cd5b7deeb69c7" compoundref="cu__vector__operations_8cu" startline="126" endline="147">cuVectorOperations&lt; DataType &gt;::subtract_scaled_vector</referencedby>
      </memberdef>
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a485cb195e35ed2931730416ae58dfce3" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate::traceinv::_hutchinson_method.inner_prod</definition>
        <argsstring></argsstring>
        <name>inner_prod</name>
        <initializer>=  <ref refid="classcVectorOperations" kindref="compound">cVectorOperations</ref>[float].inner_product(<ref refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a0e40e1c0432edbd1685f5ea088661471" kindref="member">cOpE</ref>, <ref refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a0e40e1c0432edbd1685f5ea088661471" kindref="member">cOpE</ref>,
                                                            <ref refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1ac91710305a887e168c64096ecc63db6c" kindref="member">vector_size</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="976" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="976" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a495f2b2a971c802f8b6bbefe563f93c1" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate::traceinv::_hutchinson_method.trace_estimate</definition>
        <argsstring></argsstring>
        <name>trace_estimate</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="983" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="983" bodyend="-1"/>
        <referencedby refid="classcTraceEstimator_1a02afa505a915c58380b99a62e4d56b30" compoundref="c__trace__estimator_8cpp" startline="401" endline="644">cTraceEstimator&lt; DataType &gt;::_c_stochastic_lanczos_quadrature</referencedby>
        <referencedby refid="classcuTraceEstimator_1ab4edc323dc7dcc98f401eeec9276e245" compoundref="cu__trace__estimator_8cu" startline="409" endline="652">cuTraceEstimator&lt; DataType &gt;::_cu_stochastic_lanczos_quadrature</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a62c0bc37cf02ed8dddf9d15fd56112ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv._hutchinson_method.hutchinson_method</definition>
        <argsstring>(A, gram=False, p=1, return_info=False, B=None, C=None, assume_matrix=&apos;gen&apos;, min_num_samples=10, max_num_samples=50, error_atol=None, error_rtol=1e-2, confidence_level=0.95, outlier_significance_level=0.001, solver_tol=1e-6, orthogonalize=True, num_threads=0, verbose=False, plot=False)</argsstring>
        <name>hutchinson_method</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
          <defval>1</defval>
        </param>
        <param>
          <type>return_info</type>
          <defname>return_info</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>B</type>
          <defname>B</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>C</type>
          <defname>C</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>assume_matrix</type>
          <defname>assume_matrix</defname>
          <defval>&apos;gen&apos;</defval>
        </param>
        <param>
          <type>min_num_samples</type>
          <defname>min_num_samples</defname>
          <defval>10</defval>
        </param>
        <param>
          <type>max_num_samples</type>
          <defname>max_num_samples</defname>
          <defval>50</defval>
        </param>
        <param>
          <type>error_atol</type>
          <defname>error_atol</defname>
          <defval>None</defval>
        </param>
        <param>
          <type>error_rtol</type>
          <defname>error_rtol</defname>
          <defval>1e-2</defval>
        </param>
        <param>
          <type>confidence_level</type>
          <defname>confidence_level</defname>
          <defval>0.95</defval>
        </param>
        <param>
          <type>outlier_significance_level</type>
          <defname>outlier_significance_level</defname>
          <defval>0.001</defval>
        </param>
        <param>
          <type>solver_tol</type>
          <defname>solver_tol</defname>
          <defval>1e-6</defval>
        </param>
        <param>
          <type>orthogonalize</type>
          <defname>orthogonalize</defname>
          <defval>True</defval>
        </param>
        <param>
          <type>num_threads</type>
          <defname>num_threads</defname>
          <defval>0</defval>
        </param>
        <param>
          <type>verbose</type>
          <defname>verbose</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>plot</type>
          <defname>plot</defname>
          <defval>False</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Trace of matrix or linear operator using stochastic Lanczos quadrature
method.

If `C` is `None`, given the matrices :math:`\\mathbf{A}` and
:math:`\\mathbf{B}` and the integer exponent :math:`p`, the following is
computed:

.. math::

    \\mathrm{trace} \\left(\\mathbf{B} \\mathbf{A}^{-p} \\right).

If `B` is `None`, it is assumed that :math:`\\mathbf{B}` is the identity
matrix.

If `C` is not `None`, given the matrix :math:`\\mathbf{C}`, the following
is instead computed:

.. math::

    \\mathrm{trace} \\left(\\mathbf{B} \\mathbf{A}^{-p} \\mathbf{C}
    \\mathbf{A}^{-p} \\right).

If ``gram`` is `True`, then :math:`\\mathbf{A}` in the above is replaced by
the Gramian matrix :math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`. Namely, if
`C` is `None`:

.. math::

    \\mathrm{trace} \\left(\\mathbf{B} 
    (\\mathbf{A}^{\\intercal}\\mathbf{A})^{-p} \\right),

and if `C` is not `None`,

.. math::

    \\mathrm{trace} \\left(\\mathbf{B} 
    (\\mathbf{A}^{\\intercal}\\mathbf{A})^{-p} \\mathbf{C}
    (\\mathbf{A}^{\\intercal}\\mathbf{A})^{-p} \\right).

Parameters
----------

A : numpy.ndarray, scipy.sparse
    A sparse or dense matrix.

    .. note::

        In the Hutchinson method, the matrix cannot be a type of
        :class:`Matrix` or :class:`imate.AffineMatrixFunction` classes.

gram : bool, default=False
    If `True`, the trace of the Gramian matrix,
    :math:`(\\mathbf{A}^{\\intercal}\\mathbf{A})^p`, is computed. The
    Gramian matrix itself is not directly computed. If `False`, the
    trace of :math:`\\mathbf{A}^p` is computed.

p : float, default=1.0
    The integer exponent :math:`p` in :math:`\\mathbf{A}^{-p}`.

return_info : bool, default=False
    If `True`, this function also returns a dictionary containing
    information about the inner computation, such as process time,
    algorithm settings, etc.

B : numpy.ndarray, scipy.sparse
    A sparse or dense matrix. `B` should be the same size and type of `A`.
    if `B` is `None`, it is assumed that `B` is the identity matrix.

C : numpy.ndarray, scipy.sparse
    A sparse or dense matrix. `C` should be the same size and type of `A`.

assume_matrix : str {&apos;gen&apos;, &apos;sym&apos;, &apos;pos&apos;, &apos;sym_pos&apos;}, default: &apos;gen&apos;
    Type of matrix `A`:

    * ``gen`` assumes `A` is a generic matrix.
    * ``sym`` assumes `A` is symmetric.
    * ``pos`` assumes `A` is positive-definite.
    * ``sym_pos`` assumes `A` is symmetric and positive-definite.

min_num_samples : int, default=10
    The minimum number of Monte-Carlo samples. If the convergence criterion
    is reached before finishing the minimum number of iterations, the
    iterations are forced to continue till the minimum number of iterations
    is finished. This value should be smaller than
    ``maximum_num_samples``.

max_num_samples : int, default=50
    The maximum number of Monte-Carlo samples. If the convergence criterion
    is not reached by the maximum number of iterations, the iterations are
    forced to stop. This value should be larger than
    ``minimum_num_samples``.

error_atol : float, default=None
    Tolerance of the absolute error of convergence of the output. Once the
    error of convergence reaches ``error_atol + error_rtol * output``, the
    iteration is terminated. If the convergence criterion is not met by the
    tolerance, then the iterations continue till reaching
    ``max_num_samples`` iterations. If `None`, the termination criterion
    does not depend on this parameter.

error_rtol : float, default=None
    Tolerance of the relative error of convergence of the output. Once the
    error of convergence reaches ``error_atol + error_rtol * output``, the
    iteration is terminated. If the convergence criterion is not met by the
    tolerance, then the iterations continue till reaching
    ``max_num_samples`` iterations. If `None`, the termination criterion
    does not depend on this parameter.

confidence_level : float, default=0.95
    Confidence level of error, which is a number between `0` and `1`. The
    error of convergence of the population of samples is defined by their
    standard deviation times the Z-score, which depends on the confidence
    level. See notes below for details.

outlier_significance_level : float, default=0.001
    One minus the confidence level of the uncertainty of the outliers of
    the output samples. This is a number between `0` and `1`.

solver_tol : float, default=1e-6
    Tolerance of solving linear system.

orthogonalize : int, default=0
    If `True`, it orthogonalizes the set of random vectors used for
    Monte-Carlo sampling. This might lead to a better estimation of the
    output.

num_threads : int, default=0
    Number of processor threads to employ for parallel computation on CPU.
    If set to `0` or a number larger than the available number of threads,
    all threads of the processor are used. The parallelization is performed
    over the Monte-Carlo iterations.

verbose : bool, default=False
    Prints extra information about the computations.

plot : bool, default=False
    Plots convergence of samples. For this, the packages `matplotlib` and
    `seaborn` should be installed. If no display is available (such as
    running this code on remote machines), the plots are saved as an `SVG`
    file in the current directory.

Returns
-------

traceinv : float or numpy.array
    Trace of inverse of matrix.

info : dict
    (Only if ``return_info`` is `True`) A dictionary of information with
    the following.

    * ``matrix``:
        * ``data_type``: `str`, {`float32`, `float64`, `float128`}. Type of
          the matrix data.
        * ``gram``: `bool`, whether the matrix `A` or its Gramian is
          considered.
        * ``exponent``: `float`, the exponent `p` in :math:`\\mathbf{A}^p`.
        * ``assume_matrix``: `str`, {`gen`, `sym`, `pos`, `sym_pos`},
          determines the type of matrix `A`.
        * ``size``: (int) The size of matrix `A`.
        * ``sparse``: `bool`, whether the matrix `A` is sparse or dense.
        * ``nnz``: `int`, if `A` is sparse, the number of non-zero elements
          of `A`.
        * ``density``: `float`, if `A` is sparse, the density of `A`, which
          is the `nnz` divided by size squared.
        * ``num_inquiries``: `int`, the size of inquiries of each parameter
          of the linear operator `A`. If `A` is a matrix, this is always
          `1`. If `A` is a type of :class:`AffineMatrixFunction`, this
          value is the number of :math:`t_i` parameters.

    * ``convergence``:
        * ``converged``: `bool`, whether the Monte-Carlo sampling
          converged.
        * ``min_num_samples``: `int`, the minimum number of Monte-Carlo
          iterations.
        * ``max_num_samples``: `int`, the maximum number of Monte-Carlo
          iterations.
        * ``num_outliers``: `int`, number of outliers found during search
          for outliers among the array of output.
        * ``num_samples_used``: `int`, number of Monte-Carlo samples used
          to produce the output. This is the total number of iterations
          minus the number of outliers.
        * ``samples``: `array` [`float`], an array of the size
          `max_num_samples`. The first few entries (`num_samples_used`) of
          this array are the output results of the Monte-Carlo sampling.
          The average of these samples is the final result. The rest of
          this array is `nan`.
        * ``samples_mean``: `float`, mean of the `samples` array, excluding
          the `nan` values.
        * ``samples_processed_order``: `array` [`int`], in parallel
          processing, samples are processed in non-sequential order. This
          array, which has the same size as `samples`, keeps track of the
          order in which each sample is processed.

    * ``error``:
        * ``absolute_error``: `float`, the absolute error of the
          convergence of samples.
        * ``confidence_level``: `float`, the confidence level used to
          calculate the error from standard deviation of samples.
        * ``error_atol``: `float`, the tolerance of absolute error of the
          convergence of samples.
        * ``error_rtol``: `float`, the tolerance of relative error of the
          convergence of samples.
        * ``outlier_significance_level``: `float`, the significance level
          used to determine the outliers in samples.
        * ``relative_error``: `float`, the relative error of the
          convergence of samples.

    * ``device``:
        * ``num_cpu_threads``: `int`, number of CPU threads used in shared
          memory parallel processing.
        * ``num_gpu_devices``: `int`, number of GPU devices used in the
          multi-GPU (GPU farm) computation.
        * ``num_gpu_multiprocessors``: `int`, number of GPU
          multi-processors.
        * ``num_gpu_threads_per_multiprocessor``: `int`, number of GPU
          threads on each GPU multi-processor.

    * ``time``:
        * ``tot_wall_time``: `float`, total elapsed time of computation.
        * ``alg_wall_time``: `float`, elapsed time of computation during
          only the algorithm execution.
        * ``cpu_proc_time``: `float`, the CPU processing time of
          computation.

    * ``solver``:
        * ``version``: `str`, version of imate.
        * ``method``: &apos;hutchinson&apos;.
        * ``solver_tol``: `float`, tolerance of solving linear system.
        * ``orthogonalize``: `bool`, orthogonalization flag.

Raises
------

ImportError
    If the package has not been compiled with GPU support, but ``gpu`` is
    set to `True`. To resolve the issue, set ``gpu`` to `False` to be able
    to use the existing installation. Alternatively,  export the
    environment variable ``USE_CUDA=1`` and recompile the source code of
    the package.

See Also
--------

imate.logdet
imate.trace
imate.schatten

Notes
-----

**Computational Complexity:**

This method uses the Hutchinson, which is a randomized algorithm. The
computational complexity of this method is

.. math::

    \\mathcal{O}((\\rho n^2s),

where :math:`n` is the matrix size, :math:`\\rho` is the density of
sparse matrix (for dense matrix, :math:`\\rho=1`), and :math:`s` is the
number of samples (set with ``min_num_samples`` and ``max_num_samples``).

This method can be used on very large matrices (:math:`n &gt; 2^{12}`). The
solution is an approximation.

**Convergence criterion:**

Let :math:`n_{\\min}` and :math:`n_{\\max}` be the minimum and maximum
number of iterations respectively defined by ``min_num_samples`` and
``max_num_samples``. The iterations terminate at
:math:`n_{\\min} \\leq i \\leq n_{\\max}` where :math:`i` is the
iteration counter. The iterations stop earlier at :math:`i &lt; n_{\\max}` if
the convergence error of the mean of the samples is satisfied, as follows.

Suppose :math:`s(j)` and :math:`\\sigma(i)` are respectively the mean and
standard deviation of samples after :math:`j` iterations. The error of
convergence, :math:`e(j)`, is defined by

.. math::

    e(j) = \\frac{\\sigma(j)}{\\sqrt{j}} Z

where :math:`Z` is the Z-score defined by

.. math::

    Z = \\sqrt{2} \\mathrm{erf}^{-1}(\\phi).

In the above, :math:`\\phi` is the confidence level and set by
``confidence_level`` argument, and :math:`\\mathrm{erf}^{-1}` is the
inverse error function. A confidence level of 95%, for instance, means that
the Z-score is 1.96, which means the confidence interval is
:math:`\\pm 1.96 \\sigma`.

The termination criterion is

.. math::

    e(j) &lt; \\epsilon_a + s(j) \\epsilon_r,

where :math:`\\epsilon_{a}` and :math:`\\epsilon_r` are the absolute and
relative error tolerances respectively, and they are set by ``error_atol``
and ``error_rtol``.

**Plotting:**

If ``plot`` is set to `True`, it plots the convergence of samples and their
relative error.

* If no graphical backend exists (such as running the code on a remote
  server or manually disabling the X11 backend), the plot will not be
  shown, rather, it will be saved as an ``svg`` file in the current
  directory.
* If the executable ``latex`` is available on ``PATH``, the plot is
  rendered using :math:`\\rm\\LaTeX` and it may take slightly longer to
  produce the plot.
* If :math:`\\rm\\LaTeX` is not installed, it uses any available San-Serif
  font to render the plot.

To manually disable interactive plot display and save the plot as
``svg`` instead, add the following at the very beginning of your code
before importing :mod:`imate`:

.. code-block:: python

    &gt;&gt;&gt; import os
    &gt;&gt;&gt; os.environ[&apos;IMATE_NO_DISPLAY&apos;] = &apos;True&apos;

References
----------

* `Ubaru, S., Chen, J., and Saad, Y. (2017)
  &lt;https://www-users.cs.umn.edu/~saad/PDF/ys-2016-04.pdf&gt;`_,
  Fast Estimation of :math:`\\mathrm{tr}(F(A))` Via Stochastic Lanczos
  Quadrature, SIAM J. Matrix Anal. Appl., 38(4), 1075-1099.

Examples
--------

**Basic Usage:**

Compute the trace of :math:`\\mathbf{A}^{-2}`:

.. code-block:: python

    &gt;&gt;&gt; # Import packages
    &gt;&gt;&gt; from imate import toeplitz, traceinv

    &gt;&gt;&gt; # Generate a sample matrix
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100)

    &gt;&gt;&gt; # Compute trace of inverse
    &gt;&gt;&gt; traceinv(A, p=2, method=&apos;hutchinson&apos;)
    24.73726368966402

Compute the trace of :math:`(\\mathbf{A}^{\\intercal} \\mathbf{A})^{-2}`:

.. code-block:: python

    &gt;&gt;&gt; # Using Gramian matrix of A
    &gt;&gt;&gt; traceinv(A, gram=True, p=2, method=&apos;hutchinson&apos;)
    17.751659383784748

Compute the trace of :math:`\\mathbf{B} \\mathbf{A}^{-2}`:

.. code-block:: python

    &gt;&gt;&gt; # Generate another sample matrix
    &gt;&gt;&gt; B = toeplitz(4, 3, size=100)

    &gt;&gt;&gt; # Using Gramian matrix of A
    &gt;&gt;&gt; traceinv(A, p=2, method=&apos;hutchinson&apos;, B=B)
    99.8817360381704

Compute the trace of :math:`\\mathbf{B} \\mathbf{A}^{-2} \\mathbf{C}
\\mathbf{A}^{-2}`:

.. code-block:: python

    &gt;&gt;&gt; # Generate another sample matrix
    &gt;&gt;&gt; C = toeplitz(5, 4, size=100)

    &gt;&gt;&gt; # Using Gramian matrix of A
    &gt;&gt;&gt; traceinv(A, p=2, method=&apos;hutchinson&apos;, B=B, C=C)
    124.45436379980006

Compute the trace of :math:`\\mathbf{B} (\\mathbf{A}^{\\intercal}
\\mathbf{A})^{-2} \\mathbf{C} (\\mathbf{A}^{\\intercal} \\mathbf{A})^{-2}`:

.. code-block:: python

    &gt;&gt;&gt; # Using Gramian matrix of A
    &gt;&gt;&gt; traceinv(A, gram=True, p=2, method=&apos;hutchinson&apos;, B=B, C=C)
    5.517453125230929

**Verbose output:**

By setting ``verbose`` to `True`, useful info about the process is
printed.

.. literalinclude:: ../_static/data/imate.traceinv.hutchinson-verbose.txt
    :language: python

**Output information:**

Print information about the inner computation:

.. code-block:: python

    &gt;&gt;&gt; ti, info = traceinv(A, method=&apos;hutchinson&apos;, return_info=True)
    &gt;&gt;&gt; print(ti)
    50.059307947603585

    &gt;&gt;&gt; # Print dictionary neatly using pprint
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; pprint(info)
    {
        &apos;matrix&apos;: {
            &apos;assume_matrix&apos;: &apos;gen&apos;,
            &apos;data_type&apos;: b&apos;float64&apos;,
            &apos;density&apos;: 0.0199,
            &apos;exponent&apos;: 1,
            &apos;gram&apos;: False,
            &apos;nnz&apos;: 199,
            &apos;num_inquiries&apos;: 1,
            &apos;size&apos;: 100,
            &apos;sparse&apos;: True
        },
        &apos;convergence&apos;: {
            &apos;converged&apos;: False,
             &apos;max_num_samples&apos;: 50,
             &apos;min_num_samples&apos;: 10,
             &apos;num_outliers&apos;: 0,
             &apos;num_samples_used&apos;: 50,
             &apos;samples&apos;: array([52.237154, ..., 51.37932704]),
             &apos;samples_mean&apos;: 50.059307947603585,
             &apos;samples_processed_order&apos;: array([ 0, ..., 49])
        },
        &apos;error&apos;: {
            &apos;absolute_error&apos;: 0.8111131801161796,
           &apos;confidence_level&apos;: 0.95,
           &apos;error_atol&apos;: 0.0,
           &apos;error_rtol&apos;: 0.01,
           &apos;outlier_significance_level&apos;: 0.001,
           &apos;relative_error&apos;: 0.016203044216375525
        },
        &apos;solver&apos;: {
            &apos;method&apos;: &apos;hutchinson&apos;,
            &apos;orthogonalize&apos;: True,
            &apos;solver_tol&apos;: 1e-06,
            &apos;version&apos;: &apos;0.16.0&apos;
        },
        &apos;device&apos;: {
            &apos;num_cpu_threads&apos;: 8,
            &apos;num_gpu_devices&apos;: 0,
            &apos;num_gpu_multiprocessors&apos;: 0,
            &apos;num_gpu_threads_per_multiprocessor&apos;: 0
        },
        &apos;time&apos;: {
            &apos;alg_wall_time&apos;: 0.03236744087189436,
          &apos;cpu_proc_time&apos;: 0.047695197999999994,
          &apos;tot_wall_time&apos;: 0.033352302853018045
        }
    }

**Large matrix:**

Compute the trace of :math:`\\mathbf{A}^{-1}` for a very large sparse
matrix using at least `100` samples.

.. code-block:: python
    :emphasize-lines: 5, 6, 7

    &gt;&gt;&gt; # Create a symmetric positive-definite matrix of size one million.
    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000, gram=True)

    &gt;&gt;&gt; # Approximate trace using hutchinson method
    &gt;&gt;&gt; ti, info = traceinv(A, method=&apos;hutchinson&apos;, solver_tol=1e-4,
    ...                     assume_matrix=&apos;sym_pos&apos;, min_num_samples=100,
    ...                     max_num_samples=200, return_info=True)
    &gt;&gt;&gt; print(ti)
    333292.3226031165

    &gt;&gt;&gt; # Find the time it took to compute the above
    &gt;&gt;&gt; print(info[&apos;time&apos;])
    {
        &apos;tot_wall_time&apos;: 175.93423152901232,
        &apos;alg_wall_time&apos;: 119.86316476506181,
        &apos;cpu_proc_time&apos;: 572.180877451
    }

Compare the result of the above approximation with the exact solution of
the trace using the analytic relation for Toeplitz matrix. See
:func:`imate.sample_matrices.toeplitz_traceinv` for details.

.. code-block:: python

    &gt;&gt;&gt; from imate.sample_matrices import toeplitz_traceinv
    &gt;&gt;&gt; toeplitz_traceinv(2, 1, size=1000000, gram=True)
    333333.2222222222

It can be seen that the error of approximation is :math:`0.012 \\%`. This
accuracy is remarkable considering that the computation on such a large
matrix took on 119 seconds. Computing the trace of such a large matrix
using any of the exact methods (such as ``exact`` or ``eigenvalue``) is
infeasible.

**Plotting:**

By setting ``plot`` to `True`, plots of samples during Monte-Carlo
iterations and the convergence of their mean are generated.

.. code-block:: python

    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000, gram=True)
    &gt;&gt;&gt; traceinv(A, method=&apos;hutchinson&apos;, assume_matrix=&apos;sym_pos&apos;,
    ...          solver_tol=1e-4, min_num_samples=50, max_num_samples=150,
    ...          error_rtol=2e-4, confidence_level=0.95,
    ...          outlier_significance_level=0.001, plot=True)

.. image:: ../_static/images/plots/traceinv_hutchinson_convergence.png
    :align: center
    :class: custom-dark

In the left plot, the samples are shown in circles and the cumulative mean
of the samples is shown by a solid black curve. The shaded area corresponds
to the 95% confidence interval :math:`\\pm 1.96 \\sigma`, which is set by
``confidence_level=0.95``. The samples outside the interval of 99.9% are
considered outliers, which is set by the significance level
``outlier_significance_level=0.001``.

In the right plot, the darker shaded area in the interval :math:`[0, 50]`
shows the minimum number of samples and is set by ``min_num_samples=50``.
The iterations do not stop till the minimum number of iterations is passed.
We can observe that sampling is terminated after 140 iterations where the
relative error of samples reaches 0.02% since we set ``error_rtol=2e-4``.
The lighter shaded area in the interval :math:`[140, 150]` corresponds to
the iterations that were not performed to reach the specified maximum
iterations by ``max_num_samples=150``.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="37" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="55" bodyend="720"/>
        <references refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1af61e24be718bb3a8f8c762e2d88356fc" compoundref="__hutchinson__method_8pyx" startline="832" endline="912">imate.traceinv._hutchinson_method._hutchinson_method_double</references>
        <references refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1ad1edc7413c75730ea3bd454a0c4ed435" compoundref="__hutchinson__method_8pyx" startline="736" endline="816">imate.traceinv._hutchinson_method._hutchinson_method_float</references>
        <references refid="namespaceimate_1_1logdet_1_1__slq__method_1a180f2ca4df8f7eea76f5e92aa120e406" compoundref="logdet_2__slq__method_8pyx" startline="837" endline="845">imate.logdet._slq_method.check_arguments</references>
        <references refid="namespaceimate_1_1traceinv_1_1__hutchinson__method__utilities_1a565ddb00fbf9fc2ec312022775a650fe" compoundref="__hutchinson__method__utilities_8pyx" startline="242" endline="424">imate.traceinv._hutchinson_method_utilities.print_summary</references>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1ad1edc7413c75730ea3bd454a0c4ed435" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv._hutchinson_method._hutchinson_method_float</definition>
        <argsstring>(A, B, C, gram, p, assume_matrix, min_num_samples, max_num_samples, error_atol, error_rtol, confidence_level, outlier_significance_level, solver_tol, orthogonalize, num_threads)</argsstring>
        <name>_hutchinson_method_float</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>B</type>
          <defname>B</defname>
        </param>
        <param>
          <type>C</type>
          <defname>C</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
        </param>
        <param>
          <type>assume_matrix</type>
          <defname>assume_matrix</defname>
        </param>
        <param>
          <type>min_num_samples</type>
          <defname>min_num_samples</defname>
        </param>
        <param>
          <type>max_num_samples</type>
          <defname>max_num_samples</defname>
        </param>
        <param>
          <type>error_atol</type>
          <defname>error_atol</defname>
        </param>
        <param>
          <type>error_rtol</type>
          <defname>error_rtol</defname>
        </param>
        <param>
          <type>confidence_level</type>
          <defname>confidence_level</defname>
        </param>
        <param>
          <type>outlier_significance_level</type>
          <defname>outlier_significance_level</defname>
        </param>
        <param>
          <type>solver_tol</type>
          <defname>solver_tol</defname>
        </param>
        <param>
          <type>orthogonalize</type>
          <defname>orthogonalize</defname>
        </param>
        <param>
          <type>num_threads</type>
          <defname>num_threads</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>This method processes single precision (32-bit) matrix ``A``.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="721" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="736" bodyend="816"/>
        <referencedby refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a62c0bc37cf02ed8dddf9d15fd56112ed" compoundref="__hutchinson__method_8pyx" startline="55" endline="720">imate.traceinv._hutchinson_method.hutchinson_method</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1af61e24be718bb3a8f8c762e2d88356fc" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv._hutchinson_method._hutchinson_method_double</definition>
        <argsstring>(A, B, C, gram, p, assume_matrix, min_num_samples, max_num_samples, error_atol, error_rtol, confidence_level, outlier_significance_level, solver_tol, orthogonalize, num_threads)</argsstring>
        <name>_hutchinson_method_double</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>B</type>
          <defname>B</defname>
        </param>
        <param>
          <type>C</type>
          <defname>C</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
        </param>
        <param>
          <type>assume_matrix</type>
          <defname>assume_matrix</defname>
        </param>
        <param>
          <type>min_num_samples</type>
          <defname>min_num_samples</defname>
        </param>
        <param>
          <type>max_num_samples</type>
          <defname>max_num_samples</defname>
        </param>
        <param>
          <type>error_atol</type>
          <defname>error_atol</defname>
        </param>
        <param>
          <type>error_rtol</type>
          <defname>error_rtol</defname>
        </param>
        <param>
          <type>confidence_level</type>
          <defname>confidence_level</defname>
        </param>
        <param>
          <type>outlier_significance_level</type>
          <defname>outlier_significance_level</defname>
        </param>
        <param>
          <type>solver_tol</type>
          <defname>solver_tol</defname>
        </param>
        <param>
          <type>orthogonalize</type>
          <defname>orthogonalize</defname>
        </param>
        <param>
          <type>num_threads</type>
          <defname>num_threads</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>This method processes double precision (64-bit) matrix ``A``.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="817" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="832" bodyend="912"/>
        <referencedby refid="namespaceimate_1_1traceinv_1_1__hutchinson__method_1a62c0bc37cf02ed8dddf9d15fd56112ed" compoundref="__hutchinson__method_8pyx" startline="55" endline="720">imate.traceinv._hutchinson_method.hutchinson_method</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1traceinv_1_1__hutchinson__method_1ab5336c2a043e91f8cbd8770a608bd3cb" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.traceinv._hutchinson_method._operator_dot</definition>
        <argsstring>(A, AtA, p, gram, assume_matrix, solver_tol, B, E)</argsstring>
        <name>_operator_dot</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>AtA</type>
          <defname>AtA</defname>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
        </param>
        <param>
          <type>assume_matrix</type>
          <defname>assume_matrix</defname>
        </param>
        <param>
          <type>solver_tol</type>
          <defname>solver_tol</defname>
        </param>
        <param>
          <type>B</type>
          <defname>B</defname>
        </param>
        <param>
          <type>E</type>
          <defname>E</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Computes either of the followings:

* Ainv * B * E
* (Ainv ** p) * B * E
* AtA * B * E
* (AtA ** p) * B * E
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="1071" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" bodystart="1071" bodyend="1132"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/traceinv/_hutchinson_method.pyx" line="1" column="1"/>
  </compounddef>
</doxygen>
