<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classcTraceEstimator" kind="class" language="C++" prot="public">
    <compoundname>cTraceEstimator</compoundname>
    <includes refid="c__trace__estimator_8h" local="no">c_trace_estimator.h</includes>
    <templateparamlist>
      <param>
        <type>typename DataType</type>
      </param>
    </templateparamlist>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classcTraceEstimator_1a29144b4d62c71f0889002754384f57f4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="types_8h_1a67de833a333e9264ce27ee3d6e4b2732" kindref="member">FlagType</ref></type>
        <definition>FlagType cTraceEstimator&lt; DataType &gt;::c_trace_estimator</definition>
        <argsstring>(cLinearOperator&lt; DataType &gt; *A, DataType *parameters, const IndexType num_inquiries, const Function *matrix_function, const FlagType gram, const DataType exponent, const FlagType orthogonalize, const IndexType lanczos_degree, const DataType lanczos_tol, const IndexType min_num_samples, const IndexType max_num_samples, const DataType error_atol, const DataType error_rtol, const DataType confidence_level, const DataType outlier_significance_level, const IndexType num_threads, DataType *trace, DataType *error, DataType **samples, IndexType *processed_samples_indices, IndexType *num_samples_used, IndexType *num_outliers, FlagType *converged, float &amp;alg_wall_time)</argsstring>
        <name>c_trace_estimator</name>
        <param>
          <type><ref refid="classcLinearOperator" kindref="compound">cLinearOperator</ref>&lt; DataType &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>parameters</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>num_inquiries</declname>
        </param>
        <param>
          <type>const <ref refid="classFunction" kindref="compound">Function</ref> *</type>
          <declname>matrix_function</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a67de833a333e9264ce27ee3d6e4b2732" kindref="member">FlagType</ref></type>
          <declname>gram</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>exponent</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a67de833a333e9264ce27ee3d6e4b2732" kindref="member">FlagType</ref></type>
          <declname>orthogonalize</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>lanczos_degree</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>lanczos_tol</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>min_num_samples</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>max_num_samples</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>error_atol</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>error_rtol</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>confidence_level</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>outlier_significance_level</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>num_threads</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>trace</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>error</declname>
        </param>
        <param>
          <type>DataType **</type>
          <declname>samples</declname>
        </param>
        <param>
          <type><ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref> *</type>
          <declname>processed_samples_indices</declname>
        </param>
        <param>
          <type><ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref> *</type>
          <declname>num_samples_used</declname>
        </param>
        <param>
          <type><ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref> *</type>
          <declname>num_outliers</declname>
        </param>
        <param>
          <type><ref refid="types_8h_1a67de833a333e9264ce27ee3d6e4b2732" kindref="member">FlagType</ref> *</type>
          <declname>converged</declname>
        </param>
        <param>
          <type>float &amp;</type>
          <declname>alg_wall_time</declname>
        </param>
        <briefdescription>
<para>Stochastic Lanczos quadrature method to estimate trace of a function of a linear operator. Both function and the linear operator can be defined with parameters. </para>
        </briefdescription>
        <detaileddescription>
<para>Multiple batches of parameters of the linear operator can be passed to this function. In such a case, the output trace is an array of the of the number of the inquired parameters.</para>
<para>The stochastic estimator computes multiple samples of trace and the final result is the average of the samples. This function outputs both the samples of estimated trace values (in <computeroutput>samples</computeroutput> array) and their average (in <computeroutput>trace</computeroutput> array).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>An instance of a class derived from <computeroutput>LinearOperator</computeroutput> class. This object will perform the matrix-vector operation and/or transposed matrix-vector operation for a linear operator. The linear operator can represent a fixed matrix, or a combination of matrices together with some given parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">parameters</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the linear operator <computeroutput>A</computeroutput>. The size of this array is <computeroutput>num_parameters*num_inquiries</computeroutput> where <computeroutput>num_parameters</computeroutput> is the number of parameters that define the linear operator <computeroutput>A</computeroutput>, and <computeroutput>num_inquiries</computeroutput> is the number of different set of parameters to compute trace on different parametrized operators. The j-th set of parameters are stored in <computeroutput>parameters</computeroutput>[j*num_parameters:(j+1)*num_parameters]. That is, this array is contiguous over each batch of parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">num_inquiries</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of batches of parameters. This function computes <computeroutput>num_inquiries</computeroutput> values of trace corresponding to different batch of parameters of the linear operator <computeroutput>A</computeroutput>. Hence, the number of output trace is <computeroutput>num_inquiries</computeroutput>. Hence, it is the number of columns of the output array <computeroutput>samples</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">matrix_function</parametername>
</parameternamelist>
<parameterdescription>
<para>An instance of <computeroutput><ref refid="classFunction" kindref="compound">Function</ref></computeroutput> class which has the function <computeroutput>function</computeroutput>. This function defines the matrix function, and operates on scalar eigenvalues of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">gram</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether the linear operator <computeroutput>A</computeroutput> is Gramian. If the linear operator is:<itemizedlist>
<listitem><para>Gramian, then, Lanczos tridiagonalization method is employed. This method requires only matrix-vector multiplication.</para>
</listitem><listitem><para>not Gramian, then, Golub-Kahn bidiagonalization method is employed. This method requires both matrix and transposed-matrix vector multiplications. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">exponent</parametername>
</parameternamelist>
<parameterdescription>
<para>The exponent parameter <computeroutput>p</computeroutput> in the trace of the expression <formula id="31">$ f((\mathbf{A} + t \mathbf{B})^p) $</formula>. The exponent is a real number and by default it is set to <computeroutput>1.0</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">orthogonalize</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether to orthogonalize the orthogonal eigenvectors during Lanczos recursive iterations.<itemizedlist>
<listitem><para>If set to <computeroutput>0</computeroutput>, no orthogonalization is performed.</para>
</listitem><listitem><para>If set to a negative integer, a newly computed eigenvector is orthogonalized against all the previous eigenvectors (full reorthogonalization).</para>
</listitem><listitem><para>If set to a positive integer, say <computeroutput>q</computeroutput> less than <computeroutput>lanczos_degree</computeroutput>, the newly computed eigenvector is orthogonalized against the last <computeroutput>q</computeroutput> previous eigenvectors (partial reorthogonalization).</para>
</listitem><listitem><para>If set to an integer larger than <computeroutput>lanczos_degree</computeroutput>, it is cut to <computeroutput>lanczos_degree</computeroutput>, which effectively orthogonalizes against all previous eigenvectors (full reorthogonalization). </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">lanczos_degree</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of Lanczos recursive iterations. The operator <computeroutput>A</computeroutput> is reduced to a square tridiagonal (or bidiagonal) matrix of the size <computeroutput>lanczos_degree</computeroutput>. The eigenvalues (or singular values) of this reduced matrix is computed and used in the stochastic Lanczos quadrature method. The larger Lanczos degree leads to a better estimation. The computational cost is quadratically increases with the lanczos degree. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">lanczos_tol</parametername>
</parameternamelist>
<parameterdescription>
<para>The tolerance to stop the Lanczos recursive iterations before the end of iterations reached. If the tolerance is not met, the iterations (total of <computeroutput>lanczos_degree</computeroutput> iterations) continue till end. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">min_num_samples</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum number of times that the trace estimation is repeated. Within the min number of samples, the Monte-Carlo continues even if convergence is reached. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_num_samples</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of times that the trace estimation is repeated. The output trace value is the average of the samples. Hence, this is the number of rows of the output array <computeroutput>samples</computeroutput>. Larger number of samples leads to a better trace estimation. The computational const linearly increases with number of samples. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">error_atol</parametername>
</parameternamelist>
<parameterdescription>
<para>Absolute tolerance criterion for early termination during the computation of trace samples. If the tolerance is not met, then all iterations (total of <computeroutput>max_num_samples</computeroutput>) proceed till end. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">error_rtol</parametername>
</parameternamelist>
<parameterdescription>
<para>Relative tolerance criterion for early termination during the computation of trace samples. If the tolerance is not met, then all iterations (total of <computeroutput>max_num_samples</computeroutput>) proceed till end. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">confidence_level</parametername>
</parameternamelist>
<parameterdescription>
<para>The confidence level of the error, which is a number between <computeroutput>0</computeroutput> and <computeroutput>1</computeroutput>. This affects the scale of <computeroutput>error</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">outlier_significance_level</parametername>
</parameternamelist>
<parameterdescription>
<para>One minus the confidence level of the uncertainty band of the outlier. This is a number between <computeroutput>0</computeroutput> and <computeroutput>1</computeroutput>. Confidence level of outleir and significance level of outlier are complement of each other. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">num_threads</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of OpenMP parallel processes. The parallelization is implemented over the Monte-Carlo iterations. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">trace</parametername>
</parameternamelist>
<parameterdescription>
<para>The output trace of size <computeroutput>num_inquiries</computeroutput>. These values are the average of the rows of <computeroutput>samples</computeroutput> array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">error</parametername>
</parameternamelist>
<parameterdescription>
<para>The error of estimation of trace, which is the standard deviation of the rows of <computeroutput>samples</computeroutput> array. The size of this array is <computeroutput>num_inquiries</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">samples</parametername>
</parameternamelist>
<parameterdescription>
<para>2D array of all estimated trace samples. The shape of this array is <computeroutput></computeroutput>(max_num_samples*num_inquiries). The average of the rows is also given in <computeroutput>trace</computeroutput> array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">processed_samples_indices</parametername>
</parameternamelist>
<parameterdescription>
<para>A 1D array indicating the processing order of rows of the <computeroutput>samples</computeroutput>. In parallel processing, this order of processing the rows of <computeroutput>samples</computeroutput> is not necessarly sequential. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">num_samples_used</parametername>
</parameternamelist>
<parameterdescription>
<para>1D array of the size of the number of columns of <computeroutput>samples</computeroutput>. Each element indicates how many iterations were used till convergence is reached for each column of the <computeroutput>samples</computeroutput>. The number of iterations should be a number between <computeroutput>min_num_samples</computeroutput> and <computeroutput>max_num_samples</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">num_outliers</parametername>
</parameternamelist>
<parameterdescription>
<para>1D array with the size of number of columns of <computeroutput>samples</computeroutput>. Each element indicates how many rows of the <computeroutput>samples</computeroutput> array were outliers and were removed during averaging rows of <computeroutput>samples</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">converged</parametername>
</parameternamelist>
<parameterdescription>
<para>1D array of the size of the number of columns of <computeroutput>samples</computeroutput>. Each element indicates which column of <computeroutput>samples</computeroutput> has converged to the tolerance criteria. Normally, if the <computeroutput>num_samples</computeroutput> used is less than <computeroutput>max_num_samples</computeroutput>, it indicates that the convergence has reached. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">alg_wall_time</parametername>
</parameternamelist>
<parameterdescription>
<para>The elapsed time that takes for the SLQ algorithm. This does not include array allocation/deallocation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A signal to indicate the status of computation:<itemizedlist>
<listitem><para><computeroutput>1</computeroutput> indicates successful convergence within the given tolerances was met. Convergence is achieved when all elements of <computeroutput>convergence</computeroutput> array are below <computeroutput>convergence_atol</computeroutput> or <computeroutput>convergence_rtol</computeroutput> times <computeroutput>trace</computeroutput>.</para>
</listitem><listitem><para><computeroutput>0</computeroutput> indicates the convergence criterion was not met for at least one of the trace inquiries. </para>
</listitem></itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_trace_estimator/c_trace_estimator.h" line="44" column="25" bodyfile="/home/sia/work/github/imate/imate/_c_trace_estimator/c_trace_estimator.cpp" bodystart="183" bodyend="297"/>
        <references refid="classcTraceEstimator_1a02afa505a915c58380b99a62e4d56b30" compoundref="c__trace__estimator_8cpp" startline="401" endline="644">cTraceEstimator&lt; DataType &gt;::_c_stochastic_lanczos_quadrature</references>
        <references refid="classConvergenceTools_1a88ae9fc09aa9af950d41cf803934c028" compoundref="convergence__tools_8cpp" startline="256" endline="376">ConvergenceTools&lt; DataType &gt;::average_estimates</references>
        <references refid="classConvergenceTools_1a5a0602ee4f933a4521ccf9ea137dd191" compoundref="convergence__tools_8cpp" startline="95" endline="194">ConvergenceTools&lt; DataType &gt;::check_convergence</references>
        <references refid="classTimer_1a6a89a613c2af9b0d1e5f7e4ba9e46c54" compoundref="timer_8cpp" startline="92" endline="95">Timer::elapsed</references>
        <references refid="classcLinearOperator_1aecc5b62db1d8a41f5112b289c7031aaf" compoundref="c__linear__operator_8cpp" startline="79" endline="82">cLinearOperator&lt; DataType &gt;::get_num_rows</references>
        <references refid="classTimer_1a3a8b5272198d029779dc9302a54305a8" compoundref="timer_8cpp" startline="66" endline="69">Timer::start</references>
        <references refid="classTimer_1a63f0eb44b27402196590a03781515dba" compoundref="timer_8cpp" startline="79" endline="82">Timer::stop</references>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-func">
      <memberdef kind="function" id="classcTraceEstimator_1a02afa505a915c58380b99a62e4d56b30" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void cTraceEstimator&lt; DataType &gt;::_c_stochastic_lanczos_quadrature</definition>
        <argsstring>(cLinearOperator&lt; DataType &gt; *A, DataType *parameters, const IndexType num_inquiries, const Function *matrix_function, const FlagType gram, const DataType exponent, const FlagType orthogonalize, const IndexType lanczos_degree, const DataType lanczos_tol, RandomNumberGenerator &amp;random_number_generator, DataType *random_vector, FlagType *converged, DataType *trace_estimate)</argsstring>
        <name>_c_stochastic_lanczos_quadrature</name>
        <param>
          <type><ref refid="classcLinearOperator" kindref="compound">cLinearOperator</ref>&lt; DataType &gt; *</type>
          <declname>A</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>parameters</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>num_inquiries</declname>
        </param>
        <param>
          <type>const <ref refid="classFunction" kindref="compound">Function</ref> *</type>
          <declname>matrix_function</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a67de833a333e9264ce27ee3d6e4b2732" kindref="member">FlagType</ref></type>
          <declname>gram</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>exponent</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1a67de833a333e9264ce27ee3d6e4b2732" kindref="member">FlagType</ref></type>
          <declname>orthogonalize</declname>
        </param>
        <param>
          <type>const <ref refid="types_8h_1ab1b7173c76e5040d0161e695a129dafe" kindref="member">IndexType</ref></type>
          <declname>lanczos_degree</declname>
        </param>
        <param>
          <type>const DataType</type>
          <declname>lanczos_tol</declname>
        </param>
        <param>
          <type><ref refid="classRandomNumberGenerator" kindref="compound">RandomNumberGenerator</ref> &amp;</type>
          <declname>random_number_generator</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>random_vector</declname>
        </param>
        <param>
          <type><ref refid="types_8h_1a67de833a333e9264ce27ee3d6e4b2732" kindref="member">FlagType</ref> *</type>
          <declname>converged</declname>
        </param>
        <param>
          <type>DataType *</type>
          <declname>trace_estimate</declname>
        </param>
        <briefdescription>
<para>For a given random input vector, computes one Monte-Carlo sample to estimate trace using Lanczos quadrature method. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>In special case when an eigenvalue relation is known, this function sets the converged inquiries to &quot;not&quot; converged in order to continue updating those inquiries. This is because in this special case, computing for other inquiries is free.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">A</parametername>
</parameternamelist>
<parameterdescription>
<para>An instance of a class derived from <computeroutput>LinearOperator</computeroutput> class. This object will perform the matrix-vector operation and/or transposed matrix-vector operation for a linear operator. The linear operator can represent a fixed matrix, or a combination of matrices together with some given parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">parameters</parametername>
</parameternamelist>
<parameterdescription>
<para>The parameters of the linear operator <computeroutput>A</computeroutput>. The size of this array is <computeroutput>num_parameters*num_inquiries</computeroutput> where <computeroutput>num_parameters</computeroutput> is the number of parameters that define the linear operator <computeroutput>A</computeroutput>, and <computeroutput>num_inquiries</computeroutput> is the number of different set of parameters to compute trace on different parametrized operators. The j-th set of parameters are stored in <computeroutput>parameters</computeroutput>[j*num_parameters:(j+1)*num_parameters]. That is, this array is contiguous over each batch of parameters. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">num_inquiries</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of batches of parameters. This function computes <computeroutput>num_inquiries</computeroutput> values of trace corresponding to different batch of parameters of the linear operator <computeroutput>A</computeroutput>. Hence, the number of output trace is <computeroutput>num_inquiries</computeroutput>. Hence, it is the number of columns of the output array <computeroutput>samples</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">matrix_function</parametername>
</parameternamelist>
<parameterdescription>
<para>An instance of <computeroutput><ref refid="classFunction" kindref="compound">Function</ref></computeroutput> class which has the function <computeroutput>function</computeroutput>. This function defines the matrix function, and operates on scalar eigenvalues of the matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">gram</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating whether the linear operator <computeroutput>A</computeroutput> is Gramian. If the linear operator is:<itemizedlist>
<listitem><para>Gramian, then, Lanczos tridiagonalization method is employed. This method requires only matrix-vector multiplication.</para>
</listitem><listitem><para>not Gramian, then, Golub-Kahn bidiagonalization method is employed. This method requires both matrix and transposed-matrix vector multiplications. </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">exponent</parametername>
</parameternamelist>
<parameterdescription>
<para>The exponent parameter <computeroutput>p</computeroutput> in the trace of the expression <formula id="31">$ f((\mathbf{A} + t \mathbf{B})^p) $</formula>. The exponent is a real number and by default it is set to <computeroutput>1.0</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">orthogonalize</parametername>
</parameternamelist>
<parameterdescription>
<para>Indicates whether to orthogonalize the orthogonal eigenvectors during Lanczos recursive iterations.<itemizedlist>
<listitem><para>If set to <computeroutput>0</computeroutput>, no orthogonalization is performed.</para>
</listitem><listitem><para>If set to a negative integer, a newly computed eigenvector is orthogonalized against all the previous eigenvectors (full reorthogonalization).</para>
</listitem><listitem><para>If set to a positive integer, say <computeroutput>q</computeroutput> less than <computeroutput>lanczos_degree</computeroutput>, the newly computed eigenvector is orthogonalized against the last <computeroutput>q</computeroutput> previous eigenvectors (partial reorthogonalization).</para>
</listitem><listitem><para>If set to an integer larger than <computeroutput>lanczos_degree</computeroutput>, it is cut to <computeroutput>lanczos_degree</computeroutput>, which effectively orthogonalizes against all previous eigenvectors (full reorthogonalization). </para>
</listitem></itemizedlist>
</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">lanczos_degree</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of Lanczos recursive iterations. The operator <computeroutput>A</computeroutput> is reduced to a square tridiagonal (or bidiagonal) matrix of the size <computeroutput>lanczos_degree</computeroutput>. The eigenvalues (or singular values) of this reduced matrix is computed and used in the stochastic Lanczos quadrature method. The larger Lanczos degre leads to a better estimation. The computational cost is quadratically increases with the lanczos degree. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">lanczos_tol</parametername>
</parameternamelist>
<parameterdescription>
<para>The tolerance to stop the Lanczos recursive iterations before the end of iterations reached. If the tolerance is not met, the iterations (total of <computeroutput>lanczos_degree</computeroutput> iterations) continue till end. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">random_number_generator</parametername>
</parameternamelist>
<parameterdescription>
<para>Generates random numbers that fills <computeroutput>random_vector</computeroutput>. In each parallel thread, an independent sequence of random numbers are generated. This object should be initialized by <computeroutput>num_threads</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">random_vector</parametername>
</parameternamelist>
<parameterdescription>
<para>A 1D vector of the size of matrix <computeroutput>A</computeroutput>. The Lanczos iterations start off from this random vector. Each given random vector is used per a Monte-Carlo computation of the SLQ method. In the Lanczos iterations, other vectors are generated orthogonal to this initial random vector. This array is filled inside this function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">converged</parametername>
</parameternamelist>
<parameterdescription>
<para>1D array of the size of the number of columns of <computeroutput>samples</computeroutput>. Each element indicates which column of <computeroutput>samples</computeroutput> has converged to the tolerance criteria. Normally, if the <computeroutput>num_samples</computeroutput> used is less than <computeroutput>max_num_samples</computeroutput>, it indicates that the convergence has reached. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">trace_estimate</parametername>
</parameternamelist>
<parameterdescription>
<para>1D array of the size of the number of columns of <computeroutput>samples</computeroutput> array. This array constitures each row of <computeroutput>samples</computeroutput> array. Each element of <computeroutput>trace_estimates</computeroutput> is the estimated trace for each parameter inquiry. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/github/imate/imate/_c_trace_estimator/c_trace_estimator.h" line="73" column="21" bodyfile="/home/sia/work/github/imate/imate/_c_trace_estimator/c_trace_estimator.cpp" bodystart="401" bodyend="644"/>
        <references refid="c__golub__kahn__bidiagonalization_8cpp_1a6125b021cd93b43ab4d9f20813487f85" compoundref="c__golub__kahn__bidiagonalization_8cpp" startline="111" endline="232">c_golub_kahn_bidiagonalization</references>
        <references refid="c__lanczos__tridiagonalization_8cpp_1a88831f1a1ba564b198f446a7c8a8d5ef" compoundref="c__lanczos__tridiagonalization_8cpp" startline="117" endline="236">c_lanczos_tridiagonalization</references>
        <references refid="classDiagonalization_1a18924365b0d74983ead3901886d51204" compoundref="diagonalization_8cpp" startline="90" endline="119">Diagonalization&lt; DataType &gt;::eigh_tridiagonal</references>
        <references refid="classRandomArrayGenerator_1a3a577526f391d531fe4d66bdfa0107db" compoundref="random__array__generator_8cpp" startline="63" endline="160">RandomArrayGenerator&lt; DataType &gt;::generate_random_array</references>
        <references refid="classcLinearOperator_1a0dd6306a434563e4a48a806b43f23d03">cLinearOperator&lt; DataType &gt;::get_eigenvalue</references>
        <references refid="classcLinearOperator_1af9be60b44a47eed5b2c98f077ff54987" compoundref="c__linear__operator_8cpp" startline="119" endline="122">cLinearOperator&lt; DataType &gt;::get_num_parameters</references>
        <references refid="classcLinearOperator_1aecc5b62db1d8a41f5112b289c7031aaf" compoundref="c__linear__operator_8cpp" startline="79" endline="82">cLinearOperator&lt; DataType &gt;::get_num_rows</references>
        <references refid="classcLinearOperator_1af0c980ca87c2795e0dbfda1c84f74591" compoundref="c__linear__operator_8cpp" startline="136" endline="139">cLinearOperator&lt; DataType &gt;::is_eigenvalue_relation_known</references>
        <references refid="classcLinearOperator_1ad7395bd04ec8014c9dd0e66c318ae125" compoundref="c__linear__operator_8cpp" startline="108" endline="111">cLinearOperator&lt; DataType &gt;::set_parameters</references>
        <references refid="classDiagonalization_1a636b5e32ca7211d60dadc62b2258b8ea" compoundref="diagonalization_8cpp" startline="191" endline="232">Diagonalization&lt; DataType &gt;::svd_bidiagonal</references>
        <referencedby refid="classcTraceEstimator_1a29144b4d62c71f0889002754384f57f4" compoundref="c__trace__estimator_8cpp" startline="183" endline="297">cTraceEstimator&lt; DataType &gt;::c_trace_estimator</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A static class to compute the trace of implicit matrix functions using stochastic Lanczos quadrature method. This class acts as a templated namespace, where the member methods is <emphasis>public</emphasis> and <emphasis>static</emphasis>. The internal private member functions are also static. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="see"><para><ref refid="classDiagonalization" kindref="compound">Diagonalization</ref> </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="/home/sia/work/github/imate/imate/_c_trace_estimator/c_trace_estimator.h" line="39" column="1" bodyfile="/home/sia/work/github/imate/imate/_c_trace_estimator/c_trace_estimator.h" bodystart="40" bodyend="87"/>
    <listofallmembers>
      <member refid="classcTraceEstimator_1a02afa505a915c58380b99a62e4d56b30" prot="private" virt="non-virtual"><scope>cTraceEstimator</scope><name>_c_stochastic_lanczos_quadrature</name></member>
      <member refid="classcTraceEstimator_1a29144b4d62c71f0889002754384f57f4" prot="public" virt="non-virtual"><scope>cTraceEstimator</scope><name>c_trace_estimator</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
