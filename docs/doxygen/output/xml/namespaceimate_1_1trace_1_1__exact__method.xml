<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespaceimate_1_1trace_1_1__exact__method" kind="namespace" language="Python">
    <compoundname>imate::trace::_exact_method</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceimate_1_1trace_1_1__exact__method_1aa850a16211fcd604802a40f1c6bde907" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.trace._exact_method.exact_method</definition>
        <argsstring>(A, gram=False, p=1.0, return_info=False)</argsstring>
        <name>exact_method</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
          <defval>1.0</defval>
        </param>
        <param>
          <type>return_info</type>
          <defname>return_info</defname>
          <defval>False</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Trace of matrix using exact (direct) method.

Given the matrix :math:`\\mathbf{A}` and the non-negative integer exponent
:math:`p \\geq 0`, the following is computed:

.. math::

    \\mathrm{trace} \\left(\\mathbf{A}^p \\right).

If ``gram`` is `True`, then :math:`\\mathbf{A}` in the above is replaced by
the Gramian matrix :math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`, and the
following is instead computed:

.. math::

    \\mathrm{trace} \\left((\\mathbf{A}^{\\intercal}\\mathbf{A})^p
    \\right).

Parameters
----------

A : numpy.ndarray, scipy.sparse
    A sparse or dense matrix.

    .. note::

        In the exact method, the matrix cannot be a type of
        :class:`Matrix` or :class:`imate.AffineMatrixFunction` classes.

gram : bool, default=False
    If `True`, the trace of the Gramian matrix,
    :math:`(\\mathbf{A}^{\\intercal}\\mathbf{A})^p`, is computed. The
    Gramian matrix itself is not directly computed. If `False`, the
    trace of :math:`\\mathbf{A}^p` is computed.

p : float, default=1.0
    The non-negative integer exponent :math:`p` in :math:`\\mathbf{A}^p`.

return_info : bool, default=False
    If `True`, this function also returns a dictionary containing
    information about the inner computation, such as process time,
    algorithm settings, etc.

Returns
-------

trace : float or numpy.array
    Trace of matrix.

info : dict
    (Only if ``return_info`` is `True`) A dictionary of information with
    the following keys.

    * ``matrix``:
        * ``data_type``: `str`, {`float32`, `float64`, `float128`}. Type of
          the matrix data.
        * ``gram``: `bool`, whether the matrix `A` or its Gramian is
          considered.
        * ``exponent``: `float`, the exponent `p` in :math:`\\mathbf{A}^p`.
        * ``size``: `int`, the size of matrix `A`.
        * ``sparse``: `bool`, whether the matrix `A` is sparse or dense.
        * ``nnz``: `int`, if `A` is sparse, the number of non-zero elements
          of `A`.
        * ``density``: `float`, if `A` is sparse, the density of `A`, which
          is the `nnz` divided by size squared.
        * ``num_inquiries``: `int`, for the `cholesky` method, this is
          always `1`.

    * ``device``:
        * ``num_cpu_threads``: `int`, number of CPU threads used in shared
          memory parallel processing.
        * ``num_gpu_devices``: `int`, for the `cholesky` method, this is
          always `0`.
        * ``num_gpu_multiprocessors``: `int`, for the `cholesky` method,
          this is always `0`.
        * ``num_gpu_threads_per_multiprocessor``: `int`, for the `cholesky`
          method, this is always `0`.

    * ``time``:
        * ``tot_wall_time``: `float`, total elapsed time of computation.
        * ``alg_wall_time``: `float`, elapsed time of computation during
          only the algorithm execution.
        * ``cpu_proc_time``: `float`, CPU processing time of computation.

    * ``solver``:
        * ``version``: `str`, version of imate.
        * ``method``: &apos;exact&apos;

See Also
--------

imate.logdet
imate.traceinv
imate.schatten

Notes
-----

With the `exact` method, the trace is computed directly by summing up the
diagonal elements of the matrix.

**Computational Complexity:**

* If :math:`p=1` and ``gram`` is `False`, the computational complexity is
  :math:`\\mathcal{O}(n)`.
  methods.

* If :math:`p=1` and ``gram`` is `True`, the computational complexity is
  :math:`\\mathcal{O}(n^2)`.

* If :math:`p=2` and ``gram`` is `False`, the computational complexity is
  :math:`\\mathcal{O}(n^3)`.

* If :math:`p=2` and ``gram`` is `True`, the computational complexity is
  :math:`\\mathcal{O}(n^3)`.

* If :math:`p&gt;2`, the computational complexity is
  :math:`\\mathcal{O}(n^3)`.

.. note::

    When :math:`p=1` and ``gram`` is `False`, the `exact` method should
    always be used. If :math:`p \\neq 1`, use the other methods.

Examples
--------

Compute the trace of a sample sparse Toeplitz matrix created by
:func:`imate.toeplitz` function.

.. code-block:: python

    &gt;&gt;&gt; # Import packages
    &gt;&gt;&gt; from imate import toeplitz, trace

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100)

    &gt;&gt;&gt; # Compute trace with the exact method (default method)
    &gt;&gt;&gt; trace(A)
    200.0

Compute the trace of
:math:`(\\mathbf{A}^{\\intercal} \\mathbf{A})^3`:

.. code-block:: python

    &gt;&gt;&gt; # Compute trace of the Gramian of A^3 using exact method
    &gt;&gt;&gt; trace(A, p=3, gram=True)
    24307.0

Print information about the inner computation:

.. code-block:: python

    &gt;&gt;&gt; tr, info = trace(A, return_info=True)
    &gt;&gt;&gt; print(tr)
    200.0

    &gt;&gt;&gt; # Print dictionary neatly using pprint
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; pprint(info)
    {
        &apos;matrix&apos;: {
            &apos;data_type&apos;: b&apos;float64&apos;,
            &apos;density&apos;: 0.0199,
            &apos;exponent&apos;: 1.0,
            &apos;gram&apos;: False,
            &apos;nnz&apos;: 199,
            &apos;num_inquiries&apos;: 1,
            &apos;size&apos;: 100,
            &apos;sparse&apos;: True
        },
        &apos;solver&apos;: {
            &apos;method&apos;: &apos;exact&apos;,
            &apos;version&apos;: &apos;0.14.0&apos;
        },
        &apos;device&apos;: {
            &apos;num_cpu_threads&apos;: 8,
            &apos;num_gpu_devices&apos;: 0,
            &apos;num_gpu_multiprocessors&apos;: 0,
            &apos;num_gpu_threads_per_multiprocessor&apos;: 0
        },
        &apos;time&apos;: {
            &apos;alg_wall_time&apos;: 0.00013329205103218555,
            &apos;cpu_proc_time&apos;: 0.00017459900000016404,
            &apos;tot_wall_time&apos;: 0.00013329205103218555
        }
    }

**Large matrix:**

For large matrices, use the `exact` method only if :math:`p = 1` and if
``gram`` is `False`.

.. code-block:: python

    &gt;&gt;&gt; # Generate a matrix of size one million
    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000)

    &gt;&gt;&gt; # Approximate trace using stochastic Lanczos quadrature
    &gt;&gt;&gt; # with at least 100 Monte-Carlo sampling
    &gt;&gt;&gt; tr, info = trace(A, p=1, gram=False, return_info=True)
    &gt;&gt;&gt; print(tr)
    2000000.0

    &gt;&gt;&gt; # Find the time it took to compute the above
    &gt;&gt;&gt; print(info[&apos;time&apos;])
    {
        &apos;tot_wall_time&apos;: 0.004113928065635264,
        &apos;alg_wall_time&apos;: 0.004113928065635264,
        &apos;cpu_proc_time&apos;: 0.0041158319999681225
    }
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/trace/_exact_method.py" line="30" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/trace/_exact_method.py" bodystart="34" bodyend="378"/>
        <references refid="namespaceimate_1_1trace_1_1__exact__method_1a2066b1f1024cba05cc30046d03cc796b" compoundref="trace_2__exact__method_8py" startline="379" endline="408">imate.trace._exact_method.check_arguments</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1ab38dbfffdf3dd5a3599ec768dd704ba0" compoundref="matrix__utilities_8py" startline="21" endline="44">imate._linear_algebra.matrix_utilities.get_data_type_name</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1a85bc667db05d03b8beb694a069aa45cd" compoundref="matrix__utilities_8py" startline="60" endline="69">imate._linear_algebra.matrix_utilities.get_density</references>
        <references refid="namespaceimate_1_1__linear__algebra_1_1matrix__utilities_1a98ba8778e91264e000ac383db223859b" compoundref="matrix__utilities_8py" startline="45" endline="59">imate._linear_algebra.matrix_utilities.get_nnz</references>
        <referencedby refid="namespaceimate_1_1trace_1_1trace_1a206ae6c64fe73e263a6da1b0adb8fbff" compoundref="trace_8py" startline="29" endline="404">imate.trace.trace.trace</referencedby>
      </memberdef>
      <memberdef kind="function" id="namespaceimate_1_1trace_1_1__exact__method_1a2066b1f1024cba05cc30046d03cc796b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.trace._exact_method.check_arguments</definition>
        <argsstring>(A, gram, p)</argsstring>
        <name>check_arguments</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Checks the type and value of the parameters.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/trace/_exact_method.py" line="379" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/trace/_exact_method.py" bodystart="379" bodyend="408"/>
        <referencedby refid="namespaceimate_1_1trace_1_1__exact__method_1aa850a16211fcd604802a40f1c6bde907" compoundref="trace_2__exact__method_8py" startline="34" endline="378">imate.trace._exact_method.exact_method</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/trace/_exact_method.py" line="1" column="1"/>
  </compounddef>
</doxygen>
