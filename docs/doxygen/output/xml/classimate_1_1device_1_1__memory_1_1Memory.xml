<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classimate_1_1device_1_1__memory_1_1Memory" kind="class" language="Python" prot="public">
    <compoundname>imate::device::_memory::Memory</compoundname>
    <basecompoundref prot="public" virt="non-virtual">object</basecompoundref>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="classimate_1_1device_1_1__memory_1_1Memory_1ac8af7208b0c26491a5397c43fe3d8dcf" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate.device._memory.Memory::init_mem</definition>
        <argsstring></argsstring>
        <name>init_mem</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="138" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="138" bodyend="-1"/>
        <referencedby refid="classimate_1_1device_1_1__memory_1_1Memory_1aadcc8985580b5a40bd68df7711e0c58c" compoundref="__memory_8py" startline="197" endline="293">imate.device._memory.Memory.read</referencedby>
        <referencedby refid="classimate_1_1device_1_1__memory_1_1Memory_1a4a361493f6199aa44152b2ddd1dc5d0f" compoundref="__memory_8py" startline="147" endline="192">imate.device._memory.Memory.start</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classimate_1_1device_1_1__memory_1_1Memory_1ab12598eb6ed4475e7df4149ccb501e53" prot="public" static="no" mutable="no">
        <type></type>
        <definition>imate.device._memory.Memory::mem_diff</definition>
        <argsstring></argsstring>
        <name>mem_diff</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="141" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="141" bodyend="-1"/>
        <referencedby refid="classimate_1_1device_1_1__memory_1_1Memory_1aadcc8985580b5a40bd68df7711e0c58c" compoundref="__memory_8py" startline="197" endline="293">imate.device._memory.Memory.read</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classimate_1_1device_1_1__memory_1_1Memory_1a3212b897034199ff8690e828b1d14b64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.device._memory.Memory.__init__</definition>
        <argsstring>(self)</argsstring>
        <name>__init__</name>
        <param>
          <type>self</type>
          <defname>self</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Initialization.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="132" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="132" bodyend="142"/>
      </memberdef>
      <memberdef kind="function" id="classimate_1_1device_1_1__memory_1_1Memory_1a4a361493f6199aa44152b2ddd1dc5d0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.device._memory.Memory.start</definition>
        <argsstring>(self)</argsstring>
        <name>start</name>
        <param>
          <type>self</type>
          <defname>self</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Sets the start points to track the memory change.

.. note::

    This method should be called before calling
    :meth:`imate.Memory.read`.

See Also
--------

imate.Memory.read

Examples
--------

.. code-block:: python
    :emphasize-lines: 10

    &gt;&gt;&gt; # Create an object of Memory class
    &gt;&gt;&gt; from imate import Memory
    &gt;&gt;&gt; mem = Memory()

    &gt;&gt;&gt; # Create a matrix
    &gt;&gt;&gt; from imate import toeplitz, logdet
    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000, gram=True)

    &gt;&gt;&gt; # Start tracking memory change from here
    &gt;&gt;&gt; mem.start()

    &gt;&gt;&gt; # Compute the log-determinant of the matrix
    &gt;&gt;&gt; ld = logdet(A)

    &gt;&gt;&gt; # Read acquired memory is acquired from start to this point
    &gt;&gt;&gt; mem.read()
    (679936, &apos;b&apos;)

    &gt;&gt;&gt; # Or, read acquired memory in human-readable format
    &gt;&gt;&gt; mem.read(human_readable=True)
    (664.0, &apos;Kb&apos;)
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="147" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="147" bodyend="192"/>
        <references refid="classimate_1_1device_1_1__memory_1_1Memory_1ac8af7208b0c26491a5397c43fe3d8dcf" compoundref="__memory_8py" startline="138">imate.device._memory.Memory.init_mem</references>
      </memberdef>
      <memberdef kind="function" id="classimate_1_1device_1_1__memory_1_1Memory_1aadcc8985580b5a40bd68df7711e0c58c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.device._memory.Memory.read</definition>
        <argsstring>(self, human_readable=False)</argsstring>
        <name>read</name>
        <param>
          <type>self</type>
          <defname>self</defname>
        </param>
        <param>
          <type>human_readable</type>
          <defname>human_readable</defname>
          <defval>False</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Returns the memory used in the current process.

.. note::

    This method should be called after :py:meth:`imate.Memory.start` is
    called.

Parameters
----------

human_readable : bool, default=False
    If `False`, the output is in Bytes. If `True`, the output is
    converted to a human readable unit. The unit can be checked by
    ``Memory.mem_unit`` attribute.

Returns
-------

mem_tuple : tuple (int, str)
    A tuple consists of the amount of acquired memory together with a
    string indicating the unit in which the memory is reported. If
    ``human_readable`` is `False` the unit is ``&apos;b&apos;`` indicating Bytes
    unit. If ``human_readable`` is `True`, other units may be used as
    follows:

    * ``&quot;b&quot;``: indicates Bytes
    * ``&quot;KB&quot;``: indicates Kilo-Bytes
    * ``&quot;MB&quot;``: indicates Mega-Bytes
    * ``&quot;GB&quot;``: indicates Giga-Bytes
    * ``&quot;TB&quot;``: indicates Tera-Bytes
    * ``&quot;PB&quot;``: indicates Peta-Bytes
    * ``&quot;EB&quot;``: indicates Exa-Bytes
    * ``&quot;ZB&quot;``: indicates Zetta-Bytes
    * ``&quot;YB&quot;``: indicates Yotta-Bytes

See Also
--------

imate.Memory.start
imate.Memory.get_resident_memory

Notes
-----

This method reads the *difference* between the resident memory from
when :meth:`imate.Memory.start` is called to the point where this
method is called. Hence, this method measures the *acquired* memory
in between two points.

In contrast, the function :meth:`imate.Memory.get_resident_memory`
returns the current memory that resides in the hardware.

Examples
--------

.. code-block:: python
    :emphasize-lines: 16, 20

    &gt;&gt;&gt; # Create an object of Memory class
    &gt;&gt;&gt; from imate import Memory
    &gt;&gt;&gt; mem = Memory()

    &gt;&gt;&gt; # Create a matrix
    &gt;&gt;&gt; from imate import toeplitz, logdet
    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000, gram=True)

    &gt;&gt;&gt; # Start tracking memory change from here
    &gt;&gt;&gt; mem.start()

    &gt;&gt;&gt; # Compute the log-determinant of the matrix
    &gt;&gt;&gt; ld = logdet(A)

    &gt;&gt;&gt; # Read acquired memory is acquired from start to this point
    &gt;&gt;&gt; mem.read()
    (679936, &apos;b&apos;)

    &gt;&gt;&gt; # Or, read acquired memory in human-readable format
    &gt;&gt;&gt; mem.read(human_readable=True)
    (664.0, &apos;Kb&apos;)
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="197" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="197" bodyend="293"/>
        <references refid="classimate_1_1device_1_1__memory_1_1Memory_1ac8af7208b0c26491a5397c43fe3d8dcf" compoundref="__memory_8py" startline="138">imate.device._memory.Memory.init_mem</references>
        <references refid="classimate_1_1device_1_1__memory_1_1Memory_1ab12598eb6ed4475e7df4149ccb501e53" compoundref="__memory_8py" startline="141">imate.device._memory.Memory.mem_diff</references>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classimate_1_1device_1_1__memory_1_1Memory_1aabf3d37857159f1398e360f36c059921" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.device._memory.Memory.get_resident_memory</definition>
        <argsstring>(human_readable=False)</argsstring>
        <name>get_resident_memory</name>
        <param>
          <type>human_readable</type>
          <defname>human_readable</defname>
          <defval>False</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Returns the resident memory of the current process.

This method is a *static method* and does not require to instantiate
:class:`imate.Memory` class.

Parameters
----------

human_readable : bool, default=False
    If `False`, the output is in Bytes. If `True`, the output is
    converted to a human readable unit.

Returns
-------

mem_tuple : tuple (int, str)
    A tuple consists of the resident memory together with a string
    indicating the unit in which the memory is reported. If
    ``human_readable`` is `False` the unit is ``&apos;b&apos;`` indicating Bytes
    unit. If ``human_readable`` is `True`, other units may be used as
    follows:

    * ``&quot;b&quot;``: indicates Bytes
    * ``&quot;KB&quot;``: indicates Kilo-Bytes
    * ``&quot;MB&quot;``: indicates Mega-Bytes
    * ``&quot;GB&quot;``: indicates Giga-Bytes
    * ``&quot;TB&quot;``: indicates Tera-Bytes
    * ``&quot;PB&quot;``: indicates Peta-Bytes
    * ``&quot;EB&quot;``: indicates Exa-Bytes
    * ``&quot;ZB&quot;``: indicates Zetta-Bytes
    * ``&quot;YB&quot;``: indicates Yotta-Bytes

See Also
--------

imate.Memory.read

Notes
-----
This function returns the resident memory that currently resides in the
hardware.

Note that, in contrast, :meth:`imate.Memory.read` reads the
*difference* between the resident memory from when
:meth:`imate.Memory.start` is called to the point where this method is
called, hence measures the *acquired* memory in between two points.

Examples
--------

.. code-block:: python

    &gt;&gt;&gt; # Load Memory module
    &gt;&gt;&gt; from imate import Memory

    &gt;&gt;&gt; # Get resident memory in bytes
    &gt;&gt;&gt; Memory.get_resident_memory()
    (92954624, &apos;b&apos;)

    &gt;&gt;&gt; # Get resident memory in human-readable format
    &gt;&gt;&gt; Memory.get_resident_memory(human_readable=True)
    (88.6484375, &apos;Mb&apos;)
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="299" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="299" bodyend="375"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-func">
      <memberdef kind="function" id="classimate_1_1device_1_1__memory_1_1Memory_1a11106da747b82ac6424a05eacc34f5df" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.device._memory.Memory._get_resident_memory_in_bytes</definition>
        <argsstring>()</argsstring>
        <name>_get_resident_memory_in_bytes</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Returns the resident memory in the current process.

Returns
-------

mem : int
    The current resident memory in the current Python process. The
    memory is in Bytes unit.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="381" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="381" bodyend="451"/>
      </memberdef>
      <memberdef kind="function" id="classimate_1_1device_1_1__memory_1_1Memory_1ac5defe9625ec014658f96744d74c7df6" prot="private" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.device._memory.Memory._human_readable_memory</definition>
        <argsstring>(mem_bytes)</argsstring>
        <name>_human_readable_memory</name>
        <param>
          <type>mem_bytes</type>
          <defname>mem_bytes</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Converts memory in Bytes to human readable unit.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="457" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="457" bodyend="490"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><verbatim>Measures resident memory size or its change for the Python process.

Attributes
----------

ini_mem_used : default=0
    The initial resident memory when :meth:`imate.Memory.start` is called.

mem : int default=0
    The difference between the current resident memory when
    :meth:`imate.Memory.read` is called and the initial resident memory.

Methods
-------
start
read
get_resident_memory

See Also
--------

imate.info
imate.Timer

Notes
-----

**Resident Memory:**

The resident set size (or RSS) is the occupied memory of the current
python process which resides on the RAM. If the memory of the current
process overflows onto the disk&apos;s swap space, only the memory residing on
RAM is measured by RSS.

**How to Use:**

* To measure the resident memory in the current Python process, call
  :meth:`imate.Memory.get_resident_memory` function. For this, the class
  :meth:`imate.Memory` does not needed to be instantiated.

* To measure the *acquired* memory between two points of the code (that is,
  finding the *difference* of the resident memory), first instantiate the
  :class:`imate.Memory` class. Then call the two functions
  :meth:`imate.Memory.start` and :meth:`imate.Memory.read` of the
  instantiated object on the two points where the memory difference should
  be measured.

Examples
--------

The following example tracks the resident memory *acquired* during the
computation of the log-determinant of a matrix. In particular, the
:meth:`imate.Memory.read` in this example reads the *difference* between
the resident memory of the two lines highlighted below.

.. code-block:: python
    :emphasize-lines: 10, 16

    &gt;&gt;&gt; # Create an object of Memory class
    &gt;&gt;&gt; from imate import Memory
    &gt;&gt;&gt; mem = Memory()

    &gt;&gt;&gt; # Create a matrix
    &gt;&gt;&gt; from imate import toeplitz, logdet
    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000, gram=True)

    &gt;&gt;&gt; # Start tracking memory change from here
    &gt;&gt;&gt; mem.start()

    &gt;&gt;&gt; # Compute the log-determinant of the matrix
    &gt;&gt;&gt; ld = logdet(A)

    &gt;&gt;&gt; # Read acquired memory is acquired from start to this point
    &gt;&gt;&gt; mem.read()
    (679936, &apos;b&apos;)

    &gt;&gt;&gt; # Or, read acquired memory in human-readable format
    &gt;&gt;&gt; mem.read(human_readable=True)
    (664.0, &apos;Kb&apos;)

The following example shows the current resident memory of the process
as is at the current reading on the hardware.

.. code-block:: python

    &gt;&gt;&gt; # Load Memory module
    &gt;&gt;&gt; from imate import Memory

    &gt;&gt;&gt; # Get resident memory in bytes
    &gt;&gt;&gt; Memory.get_resident_memory()
    (92954624, &apos;b&apos;)

    &gt;&gt;&gt; # Get resident memory in human-readable format
    &gt;&gt;&gt; Memory.get_resident_memory(human_readable=True)
    (88.6484375, &apos;Mb&apos;)
</verbatim> </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>imate.device._memory.Memory</label>
        <link refid="classimate_1_1device_1_1__memory_1_1Memory"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>object</label>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="1">
        <label>imate.device._memory.Memory</label>
        <link refid="classimate_1_1device_1_1__memory_1_1Memory"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>object</label>
      </node>
    </collaborationgraph>
    <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" line="29" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/device/_memory.py" bodystart="29" bodyend="490"/>
    <listofallmembers>
      <member refid="classimate_1_1device_1_1__memory_1_1Memory_1a3212b897034199ff8690e828b1d14b64" prot="public" virt="non-virtual"><scope>imate::device::_memory::Memory</scope><name>__init__</name></member>
      <member refid="classimate_1_1device_1_1__memory_1_1Memory_1a11106da747b82ac6424a05eacc34f5df" prot="private" virt="non-virtual"><scope>imate::device::_memory::Memory</scope><name>_get_resident_memory_in_bytes</name></member>
      <member refid="classimate_1_1device_1_1__memory_1_1Memory_1ac5defe9625ec014658f96744d74c7df6" prot="private" virt="non-virtual"><scope>imate::device::_memory::Memory</scope><name>_human_readable_memory</name></member>
      <member refid="classimate_1_1device_1_1__memory_1_1Memory_1aabf3d37857159f1398e360f36c059921" prot="public" virt="non-virtual"><scope>imate::device::_memory::Memory</scope><name>get_resident_memory</name></member>
      <member refid="classimate_1_1device_1_1__memory_1_1Memory_1ac8af7208b0c26491a5397c43fe3d8dcf" prot="public" virt="non-virtual"><scope>imate::device::_memory::Memory</scope><name>init_mem</name></member>
      <member refid="classimate_1_1device_1_1__memory_1_1Memory_1ab12598eb6ed4475e7df4149ccb501e53" prot="public" virt="non-virtual"><scope>imate::device::_memory::Memory</scope><name>mem_diff</name></member>
      <member refid="classimate_1_1device_1_1__memory_1_1Memory_1aadcc8985580b5a40bd68df7711e0c58c" prot="public" virt="non-virtual"><scope>imate::device::_memory::Memory</scope><name>read</name></member>
      <member refid="classimate_1_1device_1_1__memory_1_1Memory_1a4a361493f6199aa44152b2ddd1dc5d0f" prot="public" virt="non-virtual"><scope>imate::device::_memory::Memory</scope><name>start</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
