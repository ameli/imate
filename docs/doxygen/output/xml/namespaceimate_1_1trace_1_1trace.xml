<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespaceimate_1_1trace_1_1trace" kind="namespace" language="Python">
    <compoundname>imate::trace::trace</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceimate_1_1trace_1_1trace_1a206ae6c64fe73e263a6da1b0adb8fbff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def imate.trace.trace.trace</definition>
        <argsstring>(A, gram=False, p=1.0, return_info=False, method=&apos;exact&apos;, **options)</argsstring>
        <name>trace</name>
        <param>
          <type>A</type>
          <defname>A</defname>
        </param>
        <param>
          <type>gram</type>
          <defname>gram</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>p</type>
          <defname>p</defname>
          <defval>1.0</defval>
        </param>
        <param>
          <type>return_info</type>
          <defname>return_info</defname>
          <defval>False</defval>
        </param>
        <param>
          <type>method</type>
          <defname>method</defname>
          <defval>&apos;exact&apos;</defval>
        </param>
        <param>
          <type>**</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>Trace of matrix or linear operator.

Given the matrix or the linear operator :math:`\\mathbf{A}` and the real
non-negative exponent :math:`p \\geq 0`, the following is computed:

.. math::

    \\mathrm{trace} \\left(\\mathbf{A}^p \\right).

If ``gram`` is `True`, then :math:`\\mathbf{A}` in the above is replaced by
the Gramian matrix :math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`, and the
following is instead computed:

.. math::

    \\mathrm{trace} \\left((\\mathbf{A}^{\\intercal}\\mathbf{A})^p
    \\right).

If :math:`\\mathbf{A} = \\mathbf{A}(t)` is a linear operator of the class
:class:`imate.AffineMatrixFunction` with the parameter :math:`t`, then for
an input  tuple :math:`t = (t_1, \\dots, t_q)`, an array output of the size
:math:`q` is returned, namely:

.. math::

    \\mathrm{trace} \\left((\\mathbf{A}(t_i))^p \\right),
    \\quad i=1, \\dots, q.

Parameters
----------

A : numpy.ndarray, scipy.sparse, :class:`imate.Matrix`, or \
        :class:`imate.AffineMatrixFunction`
    A non-singular sparse or dense matrix or linear operator. The linear
    operators :class:`imate.Matrix` and :class:`imate.AffineMatrixFunction`
    can be used only if ``method=slq``. See details in
    :ref:`slq method &lt;imate.trace.slq&gt;`. If ``method=slq`` and
    ``gram=False``, the input matrix `A` should be symmetric.

gram : bool, default=False
    If `True`, the trace of the Gramian matrix,
    :math:`(\\mathbf{A}^{\\intercal}\\mathbf{A})^p`, is computed. The
    Gramian matrix itself is not directly computed. If `False`, the
    trace of :math:`\\mathbf{A}^p` is computed.

p : float, default=1.0
    The exponent :math:`p` in :math:`\\mathbf{A}^p`.

    * If ``method=exact``, :math:`p` should be a non-negative integer.
    * If ``method=eigenvalue``, :math:`p` can be any real number. 
    * If ``method=slq``, :math:`p` should be non-negative real number.

    .. note::

        If :math:`p &lt; 0`, use :func:`imate.traceinv` function.

return_info : bool, default=False
    If `True`, this function also returns a dictionary containing
    information about the inner computation, such as process time,
    algorithm settings, etc. See the documentation for each `method` for
    details.

method : {&apos;exact&apos;, &apos;eigenvalue&apos;, &apos;slq&apos;}, default=&apos;exact&apos;
    The method of computing trace. See documentation for each method:

    * :ref:`exact &lt;imate.trace.exact&gt;`
    * :ref:`eigenvalue &lt;imate.trace.eigenvalue&gt;`
    * :ref:`slq &lt;imate.trace.slq&gt;`

options : `**kwargs`
    Extra arguments that are specific to each method. See the documentation
    for each `method` for details.

Returns
-------

trace : float or numpy.array
    Trace of matrix. If ``method=slq`` and if `A` is of type
    :class:`imate.AffineMatrixFunction` with an array of ``parameters``,
    then the output is an array.

info : dict
    (Only if ``return_info`` is `True`) A dictionary of information with at
    least the following keys. Further keys specific to each method can be
    found in the documentation of each method.

    * ``matrix``:
        * ``data_type``: `str`, {`float32`, `float64`, `float128`}, type of
          the matrix data.
        * ``gram``: `bool`, whether the matrix `A` or its Gramian is
          considered.
        * ``exponent``: `float`, the exponent `p` in :math:`\\mathbf{A}^p`.
        * ``size``: `int`, The size of matrix `A`.
        * ``sparse``: `bool`, whether the matrix `A` is sparse or dense.
        * ``nnz``: `int`, if `A` is sparse, the number of non-zero elements
          of `A`.
        * ``density``: `float`, if `A` is sparse, the density of `A`, which
          is the `nnz` divided by size squared.
        * ``num_inquiries``: `int`, The size of inquiries of each parameter
          of the linear operator `A`. If `A` is a matrix, this is always
          `1`. For more details see :ref:`slq method &lt;imate.trace.slq&gt;`.

    * ``device``:
        * ``num_cpu_threads``: `int`, number of CPU threads used in shared
          memory parallel processing.
        * ``num_gpu_devices``: `int`, number of GPU devices used in the
          multi-GPU (GPU farm) computation.
        * ``num_gpu_multiprocessors``: `int`, number of GPU
          multi-processors.
        * ``num_gpu_threads_per_multiprocessor``: `int`, number of GPU
          threads on each GPU multi-processor.

    * ``time``:
        * ``tot_wall_time``: `float`, total elapsed time of computation.
        * ``alg_wall_time``: `float`, elapsed time of computation during
          only the algorithm execution.
        * ``cpu_proc_time``: `float`, CPU processing time of computation.

    * ``solver``:
        * ``version``: `str`, version of imate.
        * ``method``: `str`, method of computation.

Raises
------

ImportError
    If the package has not been compiled with GPU support, but ``gpu`` is
    `True`. Either set ``gpu`` to `False` to use the existing installed
    package. Alternatively, export the environment variable ``USE_CUDA=1``
    and recompile the source code of the package.

See Also
--------

imate.logdet
imate.traceinv
imate.schatten

Notes
-----

**Method of Computation:**

See documentation for each method below.

* :ref:`exact &lt;imate.trace.exact&gt;`: Computes trace directly from its
  diagonal entries. This is used when :math:`p` is integer. If :math:`p=1`,
  this method is preferred.
* :ref:`eigenvalue &lt;imate.trace.eigenvalue&gt;`: uses spectral decomposition.
  Suitable for small matrices (:math:`n &lt; 2^{12}`). The solution is exact.
* :ref:`slq &lt;imate.trace.slq&gt;`: uses stochastic Lanczos quadrature (SLQ),
  which is a randomized algorithm. Can be used on very large matrices
  (:math:`n &gt; 2^{12}`). The solution is an approximation.

.. note::

    If :math:`p=1` and ``gram`` is `False`, always use `exact` method.
    If :math:`p` is non-integer, you may use `eigenvalue` or `slq` method,
    though, for large matrices, the `slq` method is preferred.

**Input Matrix:**

The input `A` can be either of:

* A matrix, such as `numpy.ndarray`, or `scipy.sparse`.
* A linear operator representing a matrix using :class:`imate.Matrix` (
  only if ``method=slq``).
* A linear operator representing a one-parameter family of an affine matrix
  function :math:`t \\mapsto \\mathbf{A} + t\\mathbf{B}`, using
  :class:`imate.AffineMatrixFunction` (only if ``method=slq``).

**Output:**

The output is a scalar. However, if `A` is the linear operator of the type
:class:`imate.AffineMatrixFunction` representing the matrix function
:math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{B}`, then if the parameter
:math:`t` is given as the tuple :math:`t = (t_1, \\dots, t_q)`, then the
output of this function is an array of size :math:`q` corresponding to the
trace of each :math:`\\mathbf{A}(t_i)`.

.. note::

    When `A` represents
    :math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{I}`, where
    :math:`\\mathbf{I}` is the identity matrix, and :math:`t` is given by
    a tuple :math:`t = (t_1, \\dots, t_q)`, by setting ``method=slq``, the
    computational cost of an array output of size `q` is the same as
    computing for a single :math:`t_i`. Namely, the trace of only
    :math:`\\mathbf{A}(t_1)` is computed, and the trace of the rest of
    :math:`q=2, \\dots, q` are obtained from the result of :math:`t_1`
    immediately.

Examples
--------

**Sparse matrix:**

Compute the trace of a sample sparse Toeplitz matrix created by
:func:`imate.toeplitz` function.

.. code-block:: python

    &gt;&gt;&gt; # Import packages
    &gt;&gt;&gt; from imate import toeplitz, trace

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100)

    &gt;&gt;&gt; # Compute trace with the exact method (default method)
    &gt;&gt;&gt; trace(A)
    200.0

Compute the trace of
:math:`(\\mathbf{A}^{\\intercal} \\mathbf{A})^3`:

.. code-block:: python

    &gt;&gt;&gt; # Compute trace of the Gramian of A to the power of 3.
    &gt;&gt;&gt; trace(A, p=3, gram=True)
    24307.0

**Output information:**

Print information about the inner computation:

.. code-block:: python

    &gt;&gt;&gt; tr, info = trace(A, return_info=True)
    &gt;&gt;&gt; print(tr)
    200.0

    &gt;&gt;&gt; # Print dictionary neatly using pprint
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; pprint(info)
    {
        &apos;matrix&apos;: {
            &apos;data_type&apos;: b&apos;float64&apos;,
            &apos;density&apos;: 0.0199,
            &apos;exponent&apos;: 1.0,
            &apos;gram&apos;: False,
            &apos;nnz&apos;: 199,
            &apos;num_inquiries&apos;: 1,
            &apos;size&apos;: 100,
            &apos;sparse&apos;: True
        },
        &apos;solver&apos;: {
            &apos;method&apos;: &apos;exact&apos;,
            &apos;version&apos;: &apos;0.14.0&apos;
        },
        &apos;device&apos;: {
            &apos;num_cpu_threads&apos;: 8,
            &apos;num_gpu_devices&apos;: 0,
            &apos;num_gpu_multiprocessors&apos;: 0,
            &apos;num_gpu_threads_per_multiprocessor&apos;: 0
        },
        &apos;time&apos;: {
            &apos;alg_wall_time&apos;: 0.00013329205103218555,
            &apos;cpu_proc_time&apos;: 0.00017459900000016404,
            &apos;tot_wall_time&apos;: 0.00013329205103218555
        }
    }

**Large matrix:**

Compute the trace of a very large sparse matrix using `SLQ` method. This
method does not compute the trace exactly, rather, the result is an
approximation using Monte-Carlo sampling. The following example uses at
least `100` samples.

.. code-block:: python

    &gt;&gt;&gt; # Generate a matrix of size one million
    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000)

    &gt;&gt;&gt; # Approximate trace using stochastic Lanczos quadrature
    &gt;&gt;&gt; # with at least 100 Monte-Carlo sampling
    &gt;&gt;&gt; tr, info = trace(A, method=&apos;slq&apos;, min_num_samples=100,
    ...                  max_num_samples=200, return_info=True)
    &gt;&gt;&gt; print(tr)
    4999741.080000001

    &gt;&gt;&gt; # Find the time it took to compute the above
    &gt;&gt;&gt; print(info[&apos;time&apos;])
    {
        &apos;tot_wall_time&apos;: 16.221865047933534,
        &apos;alg_wall_time&apos;: 16.20779037475586,
        &apos;cpu_proc_time&apos;: 116.213995219
    }

Compare the result of the above approximation with the exact solution of
the trace using the analytic relation for Toeplitz matrix. See
:func:`imate.sample_matrices.toeplitz_trace` for details.

.. code-block:: python

    &gt;&gt;&gt; from imate.sample_matrices import toeplitz_trace
    &gt;&gt;&gt; toeplitz_trace(2, 1, size=1000000)
    4999999

It can be seen that the error of approximation is :math:`0.0018 \\%`. This
accuracy is remarkable considering that the computation on such a large
matrix took only a 16 seconds. Computing the trace of such a
large matrix using any of the exact methods (such as ``exact`` or
``eigenvalue``) is infeasible.

**Matrix operator:**

The following example uses an object of :class:`imate.Matrix`. Note that
this can be only applied to ``method=slq``. See further details in
:ref:`slq method &lt;imate.trace.slq&gt;`.

.. code-block:: python
    :emphasize-lines: 8

    &gt;&gt;&gt; # Import matrix operator
    &gt;&gt;&gt; from imate import toeplitz, trace, Matrix

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)

    &gt;&gt;&gt; # Create a matrix operator object from matrix A
    &gt;&gt;&gt; Aop = Matrix(A)

    &gt;&gt;&gt; # Compute trace of Aop
    &gt;&gt;&gt; trace(Aop, method=&apos;slq&apos;)
    495.0

**Affine matrix operator:**

The following example uses an object of
:class:`imate.AffineMatrixFunction` to create the linear operator:

.. math::

    t \\mapsto \\mathbf{A} + t \\mathbf{I}

Note that this can be only applied to ``method=slq``. See further details
in :ref:`slq method &lt;imate.trace.slq&gt;`.

.. code-block:: python
    :emphasize-lines: 8

    &gt;&gt;&gt; # Import affine matrix function
    &gt;&gt;&gt; from imate import toeplitz, trace, AffineMatrixFunction

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)

    &gt;&gt;&gt; # Create a matrix operator object from matrix A
    &gt;&gt;&gt; Aop = AffineMatrixFunction(A)

    &gt;&gt;&gt; # A list of parameters t to pass to Aop
    &gt;&gt;&gt; t = [-1.0, 0.0, 1.0]

    &gt;&gt;&gt; # Compute trace of Aop with non-integer power for all parameters t
    &gt;&gt;&gt; trace(Aop, method=&apos;slq&apos;, parameters=t)
    array([398.04, 498.04, 598.04])
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/trace/trace.py" line="23" column="1" bodyfile="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/trace/trace.py" bodystart="29" bodyend="404"/>
        <references refid="namespaceimate_1_1logdet_1_1__eigenvalue__method_1a9514f0de2c73a9922234ff43d1546c66" compoundref="logdet_2__eigenvalue__method_8py" startline="39" endline="351">imate.logdet._eigenvalue_method.eigenvalue_method</references>
        <references refid="namespaceimate_1_1trace_1_1__exact__method_1aa850a16211fcd604802a40f1c6bde907" compoundref="trace_2__exact__method_8py" startline="34" endline="378">imate.trace._exact_method.exact_method</references>
        <references refid="namespaceimate_1_1logdet_1_1__slq__method_1a8f7e56fdb6a71674cc894241ca2b152f" compoundref="logdet_2__slq__method_8pyx" startline="43" endline="836">imate.logdet._slq_method.slq_method</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/trace/trace.py" line="1" column="1"/>
  </compounddef>
</doxygen>
