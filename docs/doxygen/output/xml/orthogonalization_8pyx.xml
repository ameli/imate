<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="orthogonalization_8pyx" kind="file" language="Python">
    <compoundname>orthogonalization.pyx</compoundname>
    <innernamespace refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization">imate::_linear_algebra::orthogonalization</innernamespace>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">#<sp/>SPDX-FileCopyrightText:<sp/>Copyright<sp/>2021,<sp/>Siavash<sp/>Ameli<sp/>&lt;sameli@berkeley.edu&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="comment">#<sp/>SPDX-License-Identifier:<sp/>BSD-3-Clause</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="comment">#<sp/>SPDX-FileType:<sp/>SOURCE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="comment">#</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="comment">#<sp/>This<sp/>program<sp/>is<sp/>free<sp/>software:<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify<sp/>it<sp/>under</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="comment">#<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>license<sp/>found<sp/>in<sp/>the<sp/>LICENSE.txt<sp/>file<sp/>in<sp/>the<sp/>root<sp/>directory</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="comment">#<sp/>of<sp/>this<sp/>source<sp/>tree.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="comment">#<sp/>=======</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="comment">#<sp/>Imports</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="comment">#<sp/>=======</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>.._c_basic_algebra<sp/>cimport<sp/>cVectorOperations</highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>.._random_generator<sp/>cimport<sp/>py_generate_random_array</highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>.._definitions.types<sp/>cimport<sp/>DataType,<sp/>IndexType,<sp/>LongIndexType,<sp/>FlagType</highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>libc.math<sp/>cimport<sp/>fmax,<sp/>fabs,<sp/>sqrt</highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>libc.stdio<sp/>cimport<sp/>printf</highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="keyword">from</highlight><highlight class="normal"><sp/>libc.stdlib<sp/>cimport<sp/>abort</highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="comment">#<sp/>====================</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="comment">#<sp/>gram<sp/>schmidt<sp/>process</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="comment">#<sp/>====================</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal">cdef<sp/>void<sp/>gram_schmidt_process(</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>DataType*<sp/>V,</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>LongIndexType<sp/>vector_size,</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexType<sp/>num_vectors,</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>FlagType<sp/>ortho_depth,</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DataType*<sp/>v)<sp/>nogil:</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="33"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Modified<sp/>Gram-Schmidt<sp/>orthogonalization<sp/>process<sp/>to<sp/>orthogonalize<sp/>the<sp/>vector</highlight></codeline>
<codeline lineno="34"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>``v``<sp/>against<sp/>a<sp/>subset<sp/>of<sp/>the<sp/>column<sp/>vectors<sp/>in<sp/>the<sp/>array<sp/>``V``.</highlight></codeline>
<codeline lineno="35"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="36"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>``V``<sp/>is<sp/>1D<sp/>array<sp/>of<sp/>the<sp/>length<sp/>``vector_size<sp/>*<sp/>num_vectors``<sp/>to<sp/>represent</highlight></codeline>
<codeline lineno="37"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>a<sp/>2D<sp/>array<sp/>of<sp/>a<sp/>set<sp/>of<sp/>``num_vectors``<sp/>column<sp/>vectors,<sp/>each<sp/>of<sp/>the<sp/>length</highlight></codeline>
<codeline lineno="38"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>``vector_size``.<sp/>The<sp/>length<sp/>of<sp/>``v``<sp/>is<sp/>also<sp/>``vector_size``.</highlight></codeline>
<codeline lineno="39"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="40"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>``v``<sp/>is<sp/>orthogonalized<sp/>against<sp/>the<sp/>last<sp/>``ortho_depth``<sp/>columns<sp/>of<sp/>``V``.</highlight></codeline>
<codeline lineno="41"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="42"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>If<sp/>``ortho_depth``<sp/>is<sp/>zero,<sp/>no<sp/>orthogonalization<sp/>is<sp/>performed.</highlight></codeline>
<codeline lineno="43"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>If<sp/>``ortho-depth``<sp/>is<sp/>negative<sp/>(usually<sp/>set<sp/>to<sp/>``-1``),<sp/>then<sp/>``v``<sp/>is</highlight></codeline>
<codeline lineno="44"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>orthogonalized<sp/>against<sp/>all<sp/>column<sp/>vectors<sp/>of<sp/>``V``.</highlight></codeline>
<codeline lineno="45"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>If<sp/>`ortho_depth``<sp/>is<sp/>larger<sp/>than<sp/>``num_vectors``,<sp/>then<sp/>``v``<sp/>is</highlight></codeline>
<codeline lineno="46"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>orthogonalized<sp/>against<sp/>all<sp/>column<sp/>vectors<sp/>of<sp/>``V``.</highlight></codeline>
<codeline lineno="47"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>If<sp/>``ortho-depth``<sp/>is<sp/>smaller<sp/>than<sp/>``num_vectors``,<sp/>then<sp/>``v``<sp/>is</highlight></codeline>
<codeline lineno="48"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>orthogonalized<sp/>against<sp/>the<sp/>last<sp/>``orth-depth``<sp/>column<sp/>vectors<sp/>of</highlight></codeline>
<codeline lineno="49"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>``V``.</highlight></codeline>
<codeline lineno="50"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="51"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>The<sp/>result<sp/>of<sp/>the<sp/>newer<sp/>``v``<sp/>is<sp/>written<sp/>in-place<sp/>in<sp/>``v``.</highlight></codeline>
<codeline lineno="52"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="53"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>..<sp/>note::</highlight></codeline>
<codeline lineno="54"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="55"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>If<sp/>two<sp/>vectors<sp/>are<sp/>identical<sp/>(or<sp/>the<sp/>norm<sp/>of<sp/>their<sp/>difference<sp/>is<sp/>very</highlight></codeline>
<codeline lineno="56"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>small),<sp/>they<sp/>cannot<sp/>be<sp/>orthogonalized<sp/>against<sp/>each<sp/>other.<sp/>In<sp/>this<sp/>case,</highlight></codeline>
<codeline lineno="57"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>orthogonalization<sp/>is<sp/>skipped<sp/>against<sp/>the<sp/>identical<sp/>vector.</highlight></codeline>
<codeline lineno="58"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="59"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>V:<sp/>1D<sp/>coalesced<sp/><sp/>array<sp/>of<sp/>vectors<sp/>representing<sp/>a<sp/>2D<sp/>array.</highlight></codeline>
<codeline lineno="60"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>The<sp/>length<sp/>of<sp/>this<sp/>1D<sp/>array<sp/>is<sp/>vector_size*num_vectors,<sp/>which<sp/>indicates</highlight></codeline>
<codeline lineno="61"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a<sp/>2D<sp/>array<sp/>with<sp/>the<sp/>shape<sp/>``(vector_size,<sp/>num_vectors)``.</highlight></codeline>
<codeline lineno="62"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>V:<sp/>C<sp/>pointer<sp/>(DataType)</highlight></codeline>
<codeline lineno="63"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="64"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>vector_size:<sp/>The<sp/>length<sp/>of<sp/>each<sp/>vector.<sp/>If<sp/>we<sp/>assume<sp/>``V``<sp/>indicates</highlight></codeline>
<codeline lineno="65"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a<sp/>2D<sp/>vector,<sp/>this<sp/>the<sp/>number<sp/>of<sp/>rows<sp/>of<sp/>``V``.</highlight></codeline>
<codeline lineno="66"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>vector_size:<sp/>int</highlight></codeline>
<codeline lineno="67"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="68"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>num_vector:<sp/>The<sp/>number<sp/>of<sp/>column<sp/>vectors.<sp/>If<sp/>we<sp/>assume<sp/>``V``</highlight></codeline>
<codeline lineno="69"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indicates<sp/>a<sp/>2D<sp/>vector,<sp/>this<sp/>the<sp/>number<sp/>of<sp/>columns<sp/>of<sp/>``V``.</highlight></codeline>
<codeline lineno="70"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>num_vectors:<sp/>int</highlight></codeline>
<codeline lineno="71"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="72"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>ortho_depth:<sp/>The<sp/>number<sp/>of<sp/>vectors<sp/>to<sp/>be<sp/>orthogonalized<sp/>starting</highlight></codeline>
<codeline lineno="73"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>from<sp/>the<sp/>last<sp/>vector.<sp/>``0``<sp/>indicates<sp/>no<sp/>orthogonalization<sp/>will<sp/>be</highlight></codeline>
<codeline lineno="74"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>performed<sp/>and<sp/>the<sp/>function<sp/>just<sp/>returns.<sp/>A<sp/>negative<sp/>value<sp/>means<sp/>all</highlight></codeline>
<codeline lineno="75"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectors<sp/>will<sp/>be<sp/>orthogonalized.<sp/>A<sp/>poisitive<sp/>value<sp/>will<sp/>orthogonalize</highlight></codeline>
<codeline lineno="76"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>the<sp/>given<sp/>number<sp/>of<sp/>vectors.<sp/>This<sp/>value<sp/>cannot<sp/>be<sp/>larger<sp/>than<sp/>the</highlight></codeline>
<codeline lineno="77"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>number<sp/>of<sp/>vectors.</highlight></codeline>
<codeline lineno="78"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>ortho_depth:<sp/>FlagType</highlight></codeline>
<codeline lineno="79"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="80"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>v:<sp/>The<sp/>vector<sp/>that<sp/>will<sp/>be<sp/>orthogonalized<sp/>against<sp/>the<sp/>columns<sp/>of</highlight></codeline>
<codeline lineno="81"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>`V``.<sp/>The<sp/>length<sp/>of<sp/>``v``<sp/>is<sp/>``vector_size``.<sp/>This<sp/>vector<sp/>is<sp/>modified</highlight></codeline>
<codeline lineno="82"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>in-place.</highlight></codeline>
<codeline lineno="83"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>v:<sp/>C<sp/>pointer<sp/>(DataType)</highlight></codeline>
<codeline lineno="84"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="85"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>vector_size:<sp/>The<sp/>length<sp/>of<sp/>each<sp/>vector.<sp/>This<sp/>the<sp/>number<sp/>of<sp/>rows<sp/>of</highlight></codeline>
<codeline lineno="86"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>``basis``<sp/>as<sp/>a<sp/>2D<sp/>array.</highlight></codeline>
<codeline lineno="87"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>vector_size:<sp/>int</highlight></codeline>
<codeline lineno="88"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="89"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>num_vector:<sp/>The<sp/>number<sp/>of<sp/>column<sp/>vectors.<sp/>This<sp/>the<sp/>number<sp/>of<sp/>columns</highlight></codeline>
<codeline lineno="90"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>of<sp/>``basis``<sp/>as<sp/>a<sp/>2D<sp/>array.</highlight></codeline>
<codeline lineno="91"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>num_vectors:<sp/>int</highlight></codeline>
<codeline lineno="92"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>&quot;&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>i</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>LongIndexType<sp/>j</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>num_steps</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>inner_prod</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>norm</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>norm_v</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>scale</highlight></codeline>
<codeline lineno="101" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a496d519a97741ad75d01932f5b520116" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>epsilon<sp/>=<sp/>1e-15</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Determine<sp/>how<sp/>many<sp/>previous<sp/>vectors<sp/>to<sp/>orthogonalize<sp/>against</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>ortho_depth<sp/>==<sp/>0:</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>No<sp/>orthogonalization<sp/>is<sp/>performed</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">elif</highlight><highlight class="normal"><sp/>(ortho_depth<sp/>&lt;<sp/>0)<sp/></highlight><highlight class="keywordflow">or</highlight><highlight class="normal"><sp/>(ortho_depth<sp/>&gt;<sp/>&lt;FlagType&gt;<sp/>num_vectors):</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Orthogonalize<sp/>against<sp/>all<sp/>vectors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="110" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a9c813b0708bb6f50644f24111951a4e4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_steps<sp/>=<sp/>num_vectors</highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Orthogonalize<sp/>against<sp/>only<sp/>the<sp/>last<sp/>ortho_depth<sp/>vectors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_steps<sp/>=<sp/>ortho_depth</highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Vectors<sp/>can<sp/>be<sp/>orthogonalized<sp/>at<sp/>most<sp/>to<sp/>the<sp/>full<sp/>basis<sp/>of<sp/>the<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>space.<sp/>Thus,<sp/>num_steps<sp/>cannot<sp/>be<sp/>larger<sp/>than<sp/>the<sp/>dimension<sp/>of<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>space,<sp/>which<sp/>is<sp/>vector_size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>num_steps<sp/>&gt;<sp/>&lt;IndexType&gt;(vector_size):</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_steps<sp/>=<sp/>vector_size</highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Iterate<sp/>over<sp/>vectors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>i<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(num_vectors-1,<sp/>num_vectors-num_steps-1,<sp/>-1):</highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Norm<sp/>of<sp/>j-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="126" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1aa6222d9a709e4e5595e92b03f97fd3ed" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>norm<sp/>=<sp/>cVectorOperations[DataType].euclidean_norm(</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;V[vector_size*i],<sp/>vector_size)</highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>norm<sp/>&lt;<sp/>epsilon<sp/>*<sp/>sqrt(vector_size):</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&apos;WARNING:<sp/>norm<sp/>of<sp/>the<sp/>given<sp/>vector<sp/>is<sp/>too<sp/>small.<sp/>Cannot<sp/>&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&apos;reorthogonalize<sp/>against<sp/>zero<sp/>vector.<sp/>Skipping\n&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Projection</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="135" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1aa29e7df02219567fb0178c9fe964bbe3" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inner_prod<sp/>=<sp/>cVectorOperations[DataType].inner_product(</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;V[vector_size*i],<sp/>v,<sp/>vector_size)</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>scale<sp/>for<sp/>subtraction</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="139" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a7b11f96e13c69a4a062cd7efe1f59f61" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scale<sp/>=<sp/>inner_prod<sp/>/<sp/>(norm**2)</highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>If<sp/>scale<sp/>is<sp/>is<sp/>1,<sp/>it<sp/>is<sp/>possible<sp/>that<sp/>vector<sp/>v<sp/>and<sp/>j-th<sp/>vector<sp/>are</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>identical<sp/>(or<sp/>close).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>fabs(scale<sp/>-<sp/>1.0)<sp/>&lt;=<sp/>2.0<sp/>*<sp/>epsilon:</highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Norm<sp/>of<sp/>the<sp/>vector<sp/>v</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="146" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a2840602f25956f73b1454c47faecb1eb" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>norm_v<sp/>=<sp/>cVectorOperations[DataType].euclidean_norm(v,<sp/>vector_size)</highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Compute<sp/>distance<sp/>between<sp/>the<sp/>j-th<sp/>vector<sp/>and<sp/>vector<sp/>v</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="149" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1af4f0b73939b2a45b0db8a5bf98c0a545" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>distance<sp/>=<sp/>sqrt(norm_v**2<sp/>-<sp/>2.0*inner_prod<sp/>+<sp/>norm**2)</highlight></codeline>
<codeline lineno="150"><highlight class="normal"></highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>If<sp/>distance<sp/>is<sp/>zero,<sp/>do<sp/>not<sp/>reorthogonalize<sp/>i-th<sp/>against</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>the<sp/>j-th<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>distance<sp/>&lt;<sp/>2.0<sp/>*<sp/>epsilon<sp/>*<sp/>sqrt(vector_size):</highlight></codeline>
<codeline lineno="154"><highlight class="normal"></highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Skip<sp/>orthogonalizing<sp/>against<sp/>j-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Subtraction</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cVectorOperations[DataType].subtract_scaled_vector(</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;V[vector_size*i],<sp/>vector_size,<sp/>scale,<sp/>v)</highlight></codeline>
<codeline lineno="161"><highlight class="normal"></highlight></codeline>
<codeline lineno="162"><highlight class="normal"></highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight><highlight class="comment">#<sp/>=====================</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight><highlight class="comment">#<sp/>orthogonalize<sp/>vectors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"></highlight><highlight class="comment">#<sp/>=====================</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="166"><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal">cdef<sp/>void<sp/>orthogonalize_vectors(</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DataType*<sp/>vectors,</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>LongIndexType<sp/>vector_size,</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexType<sp/>num_vectors)<sp/>nogil:</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;&quot;&quot;</highlight></codeline>
<codeline lineno="172"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>Orthogonalizes<sp/>set<sp/>of<sp/>vectors<sp/>mutually<sp/>using<sp/>modified<sp/>Gram-Schmidt<sp/>process.</highlight></codeline>
<codeline lineno="173"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="174"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>..<sp/>note::</highlight></codeline>
<codeline lineno="175"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="176"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Let<sp/>``m``<sp/>be<sp/>the<sp/>number<sp/>of<sp/>vectors<sp/>(``num_vectors``),<sp/>and<sp/>let<sp/>``n``<sp/>be</highlight></codeline>
<codeline lineno="177"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>the<sp/>size<sp/>of<sp/>each<sp/>vector<sp/>(``vector_size``).<sp/>In<sp/>general,<sp/>``n``<sp/>is<sp/>much</highlight></codeline>
<codeline lineno="178"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>larger<sp/>(large<sp/>matrix<sp/>size),<sp/>and<sp/>``m``<sp/>is<sp/>small,<sp/>in<sp/>order<sp/>of<sp/>a<sp/>couple<sp/>of</highlight></codeline>
<codeline lineno="179"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hundred.<sp/>But<sp/>for<sp/>small<sp/>matrices<sp/>(where<sp/>``n``<sp/>could<sp/>be<sp/>smaller<sp/>then</highlight></codeline>
<codeline lineno="180"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>``m``),<sp/>then<sp/>each<sp/>vector<sp/>can<sp/>be<sp/>orthogonalized<sp/>at<sp/>most<sp/>to<sp/>``n``<sp/>other</highlight></codeline>
<codeline lineno="181"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectors.<sp/>This<sp/>is<sp/>because<sp/>the<sp/>dimension<sp/>of<sp/>the<sp/>vector<sp/>space<sp/>is<sp/>``n``.</highlight></codeline>
<codeline lineno="182"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Thus,<sp/>if<sp/>there<sp/>are<sp/>extra<sp/>vectors,<sp/>each<sp/>vector<sp/>is<sp/>orthogonalized<sp/>to</highlight></codeline>
<codeline lineno="183"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>window<sp/>of<sp/>the<sp/>previous<sp/>``n``<sp/>vector.</highlight></codeline>
<codeline lineno="184"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="185"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>..<sp/>note::</highlight></codeline>
<codeline lineno="186"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="187"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>If<sp/>two<sp/>vectors<sp/>are<sp/>identical<sp/>(or<sp/>the<sp/>norm<sp/>of<sp/>their<sp/>difference<sp/>is<sp/>very</highlight></codeline>
<codeline lineno="188"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>small),<sp/>they<sp/>cannot<sp/>be<sp/>orthogonalized<sp/>against<sp/>each<sp/>other.<sp/>In<sp/>this<sp/>case,</highlight></codeline>
<codeline lineno="189"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>one<sp/>of<sp/>the<sp/>vectors<sp/>is<sp/>re-generated<sp/>by<sp/>new<sp/>random<sp/>numbers.</highlight></codeline>
<codeline lineno="190"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="191"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>..<sp/>warning::</highlight></codeline>
<codeline lineno="192"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="193"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>``num_vectors``<sp/>is<sp/>larger<sp/>than<sp/>``vector_size``,<sp/>the</highlight></codeline>
<codeline lineno="194"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>orthogonalization<sp/>fails<sp/>since<sp/>not<sp/>all<sp/>vectors<sp/>are<sp/>independent,<sp/>and<sp/>at</highlight></codeline>
<codeline lineno="195"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>least<sp/>one<sp/>vector<sp/>becomes<sp/>zero.</highlight></codeline>
<codeline lineno="196"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="197"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>vectors:<sp/>2D<sp/>array<sp/>of<sp/>size<sp/>``vector_size<sp/>*<sp/>num_vectors``.<sp/>This<sp/>array</highlight></codeline>
<codeline lineno="198"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>will<sp/>be<sp/>modified<sp/>in-place<sp/>and<sp/>will<sp/>be<sp/>output<sp/>of<sp/>this<sp/>function.<sp/>Note</highlight></codeline>
<codeline lineno="199"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this<sp/>is<sp/>Fortran<sp/>ordering,<sp/>meaning<sp/>that<sp/>the<sp/>first<sp/>index<sp/>is<sp/>contiguous.</highlight></codeline>
<codeline lineno="200"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hence,<sp/>to<sp/>call<sp/>the<sp/>i-th<sp/>vector,<sp/>use<sp/>``&amp;vectors[0][i]``.<sp/>Here,<sp/>iteration</highlight></codeline>
<codeline lineno="201"><highlight class="stringliteral"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>over<sp/>the<sp/>first<sp/>index<sp/>is<sp/>continuous.</highlight></codeline>
<codeline lineno="202"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>vectors:<sp/>pointer<sp/>(DataType)</highlight></codeline>
<codeline lineno="203"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="204"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>vector_size:<sp/>Number<sp/>of<sp/>rows<sp/>of<sp/>vectors<sp/>array.</highlight></codeline>
<codeline lineno="205"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>vector_size:<sp/>IndexType</highlight></codeline>
<codeline lineno="206"><highlight class="stringliteral"></highlight></codeline>
<codeline lineno="207"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:param<sp/>num_vectors:<sp/>Number<sp/>of<sp/>columns<sp/>of<sp/>vectors<sp/>array.</highlight></codeline>
<codeline lineno="208"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>:type<sp/>num_vectors:<sp/>unsigned<sp/>long</highlight></codeline>
<codeline lineno="209"><highlight class="stringliteral"><sp/><sp/><sp/><sp/>&quot;&quot;&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Do<sp/>nothing<sp/>if<sp/>there<sp/>is<sp/>only<sp/>one<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>num_vectors<sp/>&lt;<sp/>2:</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal"></highlight></codeline>
<codeline lineno="215" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1ae9eaef107083b890d511589f9a27ae2d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>i<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>j</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>start_j</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>inner_prod</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>norm</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>norm_i</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>distance</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>scale</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>DataType<sp/>epsilon<sp/>=<sp/>1e-15</highlight></codeline>
<codeline lineno="224" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a0767a9c60658755e6ee4a467dc163402" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>success<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="225" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a9b7a86737d721c93a9d14ccdbe13ea0f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>max_num_trials<sp/>=<sp/>20</highlight></codeline>
<codeline lineno="226" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a907b122a87af466ee50fb1a4fb76a803" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>num_trials<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="227" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a9e310798d763530511cd9ece95abc016" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>cdef<sp/>IndexType<sp/>num_threads<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="228"><highlight class="normal"></highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>i<sp/>&lt;<sp/>num_vectors:</highlight></codeline>
<codeline lineno="230"><highlight class="normal"></highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>success<sp/>==<sp/>0<sp/></highlight><highlight class="keywordflow">and</highlight><highlight class="normal"><sp/>num_trials<sp/>&gt;=<sp/>max_num_trials:</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&apos;ERROR:<sp/>Cannot<sp/>orthogonalize<sp/>vectors<sp/>after<sp/>%d<sp/>trials.\n&apos;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_trials)</highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>abort()</highlight></codeline>
<codeline lineno="235"><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Reset<sp/>on<sp/>new<sp/>trial<sp/>(if<sp/>it<sp/>was<sp/>set<sp/>to<sp/>0<sp/>before<sp/>to<sp/>start<sp/>a<sp/>new<sp/>trial)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>success<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="238"><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>j<sp/>iterates<sp/>on<sp/>previous<sp/>vectors<sp/>in<sp/>a<sp/>window<sp/>of<sp/>at<sp/>most<sp/>``vector_size``</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>&lt;LongIndexType&gt;i<sp/>&gt;<sp/>vector_size:</highlight></codeline>
<codeline lineno="241" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1a463c2c403c11886dd7e1f9de88634270" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>start_j<sp/>=<sp/>i<sp/>-<sp/>vector_size</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>start_j<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="244"><highlight class="normal"></highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Reorthogonalize<sp/>against<sp/>previous<sp/>vectors</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>j<sp/></highlight><highlight class="keywordflow">in</highlight><highlight class="normal"><sp/>range(start_j,<sp/>i):</highlight></codeline>
<codeline lineno="247"><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Projecting<sp/>i-th<sp/>vector<sp/>to<sp/>j-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inner_prod<sp/>=<sp/>cVectorOperations[DataType].inner_product(</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;vectors[i*vector_size],</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;vectors[j*vector_size],</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector_size)</highlight></codeline>
<codeline lineno="253"><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Norm<sp/>of<sp/>the<sp/>j-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>norm<sp/>=<sp/>cVectorOperations[DataType].euclidean_norm(</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;vectors[j*vector_size],<sp/>vector_size)</highlight></codeline>
<codeline lineno="257"><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Check<sp/>norm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>norm<sp/>&lt;<sp/>epsilon<sp/>*<sp/>sqrt(vector_size):</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&apos;WARNING:<sp/>norm<sp/>of<sp/>the<sp/>given<sp/>vector<sp/>is<sp/>too<sp/>small.<sp/>&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&apos;Cannot<sp/>reorthogonalize<sp/>against<sp/>zero<sp/>vector.<sp/>&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(</highlight><highlight class="stringliteral">&apos;Skipping.\n&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal"></highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Scale<sp/>of<sp/>subtraction</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scale<sp/>=<sp/>inner_prod<sp/>/<sp/>(norm**2)</highlight></codeline>
<codeline lineno="267"><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>If<sp/>scale<sp/>is<sp/>is<sp/>1,<sp/>it<sp/>is<sp/>possible<sp/>that<sp/>i-th<sp/>and<sp/>j-th<sp/>vectors<sp/>are</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>identical<sp/>(or<sp/>close).<sp/>So,<sp/>instead<sp/>of<sp/>subtracting<sp/>them,<sp/>regenerate</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>a<sp/>new<sp/>i-th<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>fabs(scale<sp/>-<sp/>1.0)<sp/>&lt;=<sp/>2.0<sp/>*<sp/>epsilon:</highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Norm<sp/>of<sp/>the<sp/>i-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="274" refid="namespaceimate_1_1__linear__algebra_1_1orthogonalization_1ac3e457bbbc76b14063998551f1596b27" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>norm_i<sp/>=<sp/>cVectorOperations[DataType].euclidean_norm(</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;vectors[i*vector_size],<sp/>vector_size)</highlight></codeline>
<codeline lineno="276"><highlight class="normal"></highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Compute<sp/>distance<sp/>between<sp/>i-th<sp/>and<sp/>j-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>distance<sp/>=<sp/>sqrt(norm_i**2<sp/>-<sp/>2.0*inner_prod<sp/>+<sp/>norm**2)</highlight></codeline>
<codeline lineno="279"><highlight class="normal"></highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>If<sp/>distance<sp/>is<sp/>zero,<sp/>do<sp/>not<sp/>reorthogonalize<sp/>i-th<sp/>against</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>vector<sp/>j-th<sp/>and<sp/>the<sp/>subsequent<sp/>vectors<sp/>after<sp/>j-th.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>distance<sp/>&lt;<sp/>2.0<sp/>*<sp/>epsilon<sp/>*<sp/>sqrt(vector_size):</highlight></codeline>
<codeline lineno="283"><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Regenerate<sp/>new<sp/>random<sp/>vector<sp/>for<sp/>i-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>gil:</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>py_generate_random_array(&amp;vectors[i*vector_size],</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector_size,<sp/>num_threads)</highlight></codeline>
<codeline lineno="288"><highlight class="normal"></highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Repeat<sp/>the<sp/>reorthogonalization<sp/>for<sp/>i-th<sp/>vector<sp/>against</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>all<sp/>previous<sp/>vectors<sp/>again.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>success<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_trials<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="294"><highlight class="normal"></highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Subtraction</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cVectorOperations[DataType].subtract_scaled_vector(</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;vectors[vector_size*j],<sp/>vector_size,<sp/>scale,</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;vectors[vector_size*i])</highlight></codeline>
<codeline lineno="299"><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Check<sp/>norm<sp/>of<sp/>the<sp/>i-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>norm_i<sp/>=<sp/>cVectorOperations[DataType].euclidean_norm(</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;vectors[i*vector_size],<sp/>vector_size)</highlight></codeline>
<codeline lineno="303"><highlight class="normal"></highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>If<sp/>the<sp/>norm<sp/>is<sp/>too<sp/>small,<sp/>regenerate<sp/>the<sp/>i-th<sp/>vector<sp/>randomly</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>norm_i<sp/>&lt;<sp/>epsilon<sp/>*<sp/>sqrt(vector_size):</highlight></codeline>
<codeline lineno="306"><highlight class="normal"></highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Regenerate<sp/>new<sp/>random<sp/>vector<sp/>for<sp/>i-th<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">with</highlight><highlight class="normal"><sp/>gil:</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>py_generate_random_array(&amp;vectors[i*vector_size],</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector_size,<sp/>num_threads)</highlight></codeline>
<codeline lineno="311"><highlight class="normal"></highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Repeat<sp/>the<sp/>reorthogonalization<sp/>for<sp/>i-th<sp/>vector<sp/>against</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>all<sp/>previous<sp/>vectors<sp/>again.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>success<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_trials<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"></highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>success<sp/>==<sp/>1:</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>i<sp/>+=<sp/>1</highlight></codeline>
<codeline lineno="320"><highlight class="normal"></highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">#<sp/>Reset<sp/>if<sp/>num_trials<sp/>was<sp/>incremented<sp/>before.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_trials<sp/>=<sp/>0</highlight></codeline>
    </programlisting>
    <location file="/home/sia/work/ADCP/Noise-Estimation/code/imate/imate/_linear_algebra/orthogonalization.pyx"/>
  </compounddef>
</doxygen>
