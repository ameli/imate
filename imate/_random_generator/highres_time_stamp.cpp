/*
 *  SPDX-FileCopyrightText: Copyright 2021, Siavash Ameli <sameli@berkeley.edu>
 *  SPDX-License-Identifier: BSD-3-Clause
 *  SPDX-FileType: SOURCE
 *
 *  This program is free software: you can redistribute it and/or modify it
 *  under the terms of the license found in the LICENSE.txt file in the root
 *  directory of this source tree.
 */


// =======
// Headers
// =======

#include "./highres_time_stamp.h"
#include <ctime>  // std::time, std::clock
#include "stdint.h"  // uint64_t

// The following macros define either USE_QUERY_PERFORMANCE_COUNTER (if
// windows), or USE_CLOCK_GETTIME (if Linux or MacOS>=10.12), or none.
#if defined(WIN32) || defined(_WIN32) ||  defined(__WIN32__)

    // Use Windows API
    #include <windows.h>  // LARGE_INTEGER, QueryPerformanceCounter
    #define USE_QUERY_PERFORMANCE_COUNTER

#elif defined(_POSIX_TIMERS) && (_POSIX_TIMERS > 0)

    // POSIX time compilant (Linux)
    #include <time.h>  // timespec, clock_gettime
    #define USE_CLOCK_GETTIME

// MacOS version 10.12 and above has clock_gettime, but _POSIX_TIMERS is
// not defined. So, we check this function's availability in a different way.
#elif defined(__APPLE__) || defined(__MACH__)
    #include <TargetConditionals.h>
    #if TARGET_OS_MAC
        #include <Availability.h>
        #if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
            #if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 101200

                // macOS Sierra (10.12) or later. Use clock_gettime
                #include <time.h>  // timespec, clock_gettime
                #define USE_CLOCK_GETTIME

                // Define CLOCK_REALTIME in case it is not defined
                #if !defined(CLOCK_REALTIME)
                    #define CLOCK_REALTIME 0
                #endif

            #endif
        #endif
    #endif
#endif


// ======================
// Get HighRes Time Stamp
// ======================

/// This function returns a high-resolution clock counter to be used to seed a
/// random generating function (see split_mix_64.cpp). The purpose of
/// high-resolution counter is that if the random-generating function is called
/// subsequently in very short intervals (about nano-second), the seed value
/// should be distinct.
///
/// In UNIX, such distinct seed values can be generated by ``std::clock()``
/// function which gives the processor counter. This function has enough
/// resolution to generate distinct values if called subsequently. In MacOS,
/// this function is available only after version 10.12.
///
/// In Windows, however, ``std::clock()`` is not a process counter, rather, it
/// measures the wall clock with resoluton of one second! Thus, this function
/// is not suitable at all on Windows. Instead, the QueryPerformanceCounter is
/// used.
///
/// In Case if machine is neither POSIX compilant nor Windows, this function
/// falls back to std::time and std::clock.
///
/// Note that this function works without C++11.
///
/// An alternative approach is to use ``rdtsc()``, but its use is discouraged,
/// since it is far less portable and many processors (like ARM64 archetecture)
/// do not support it. Unlike rdtsc, this function works on both X86_64 and
/// ARM64.

uint64_t get_highres_time_stamp(void)
{
    // Zero means no proper function found for this OS and processor to
    // support high-precision time counting.
    uint64_t time_stamp = 0;

    #if defined(USE_CLOCK_GETTIME)

        // Using POSIX clock_gettime
        struct timespec clock;
        if (clock_gettime(CLOCK_REALTIME, &clock) == -1)
        {
            // One means there is an error, but the program continues without
            // raising an error.
            time_stamp = 1;
        }

        time_stamp = clock.tv_sec * 1e9 + clock.tv_nsec;

    #elif defined(USE_QUERY_PERFORMANCE_COUNTER)

        // Using Windows API for query performance counter
        LARGE_INTEGER ticks;
        if (!QueryPerformanceCounter(&ticks))
        {
            time_stamp = 1;
        }
        else
        {
            time_stamp = static_cast<uint64_t>(ticks.QuadPart);
        }

    #else

        // Use std::time and std::clock.
        // Note that std::time has low resolution second accuracy. To improve
        // it, we add std::clock, which has high-resolution (in UNIX only).
        // In UNIX, std::clock is the process time with high resolution. In
        // Windows, note well that std::clock is the wall time with "second"
        // resolution, and should be avoided.
        time_stamp = static_cast<uint64_t>(std::time(0)) +
                     static_cast<uint64_t>(std::clock());

    #endif

    return time_stamp;
}
