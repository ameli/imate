# SPDX-FileCopyrightText: Copyright 2021, Siavash Ameli <sameli@berkeley.edu>
# SPDX-License-Identifier: BSD-3-Clause
# SPDX-FileType: SOURCE
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the license found in the LICENSE.txt file in the root
# directory of this source tree.


# =======
# Imports
# =======

import numpy
from ._generate_points import generate_points
from ._dense_correlation_matrix import dense_correlation_matrix
from ._sparse_correlation_matrix import sparse_correlation_matrix

try:
    from .._utilities.plot_utilities import matplotlib, plt
    from .._utilities.plot_utilities import load_plot_settings, save_plot
    plot_modules_exist = True
except ImportError:
    plot_modules_exist = False

__all__ = ['correlation_matrix']


# ==================
# correlation matrix
# ==================

def correlation_matrix(
        size=20,
        dimension=1,
        scale=0.1,
        kernel='exponential',
        kernel_param=None,
        grid=True,
        sparse=False,
        density=0.001,
        format=r'csr',
        dtype=r'float64',
        plot=False,
        verbose=False):
    """
    Generate symmetric and positive-definite matrix for test purposes.

    The elements of the correlation matrix are generated by the spatial
    correlation of a set of points. The set of points is either randomly
    generated in a hypercube or defined on a grid of points of a lattice in a
    hypercube. The correlation is computed by a kernel function applied to the
    Euclidean distance of the set of points.


    Parameters
    ----------

    size : int, default=20
        The size of matrix, which is determined as follows:

        * If ``grid`` is `False`, the size of the matrix is ``size``.
        * If ``grid`` is `True`, the size of the matrix is ``size**dimension``.

    dimension : int, default=1
        The dimension of the space of points to generate the correlation
        matrix.

    scale : float, default=0.1
        A positive parameter :math:`\\rho` of the correlation function that
        scales distance :math:`r` to :math:`r/\\rho`

    kernel : {'matern', 'exponential', 'square_exponential', \
        'rational_quadratic'}, default='exponential'
        The kernel function of the correlation, which takes a distance
        :math:`r` and yields its spatial  correlation. See details in the Notes
        section below.

    kernel_param : float, default=None
        Parameter :math:`\\theta` of the kernel function. This option only
        applies to ``kernel=matern`` (see the parameter :math:`\\nu` in Notes
        below) and ``kernel=rational_quadratic`` (see the parameter
        :math:`\\alpha` in Notes below).

    grid : bool, default=True
        Determines whether to generate the set of points on a lattice grid or
        to randomly generate points inside the unit hypercube.

        * If `True`, the points are generated on a structured grid in a unit
          hypercube with equal distances. In this case, the size of matrix
          (which is equal to the number of points) is ``size**dimension``.
        * If `False`, the points are generated randomly. In this case, the size
          of the generated matrix is ``size``.

    sparse : bool, default=False
        Flag to indicate the correlation matrix should be a sparse or dense
        matrix. If set to `True`, you may also specify ``density``.

    density : float, default=0.001
        Specifies an approximate density of the non-zero elements of the
        generated sparse matrix. The actual density of the matrix may not be
        exactly the same as this value. This option is only relevant if
        ``sparse`` is `True`.

    format : {'csr', 'csc'}, default='csr'
        The format of the sparse matrix. `CSR` generates compressed sparse rows
        and CSC generates compressed sparse columns matrix.

    dtype : {'float32', 'float64', 'float128'}, default='float64'
        Data type of the matrix.

    plot : bool, default=False
        If `True`, the matrix will be plotted. If no display is available
        (such as executing on remote machines) the plot is saved in the current
        directory in `SVG` format.

    verbose : bool, default=False
        If `True`, it prints some information during the process.

    Returns
    -------

    A : numpy.ndarray, scipy.sparse.csr, or scipy.sparse.csc, (N, N)
        Correlation matrix.

    See Also
    --------

    imate.toeplitz

    Notes
    -----

    **Matrix Size:**

    The size of matrix, :math:`N`, is determined by the parameter ``size``
    which we refer to as :math:`n`, the dimension, ``dimension``, which we
    refer to as :math:`d`, and the boolean ``grid`` variable.

        * If ``grid`` is `True`, then, the size of the square matrix is
          :math:`N = n^d`.
        * If ``grid`` is `False`, then, the size of the square matrix is
          :math:`N = n`.

    **Complexity of computation:**

    The complexity of computing the correlation matrix is
    :math:`\\mathcal{O}(\\frac{1}{2} N^2)`. The elements of the matrix are
    generated using shared memory parallelism using an efficient method that
    only requires :math:`\\mathcal{O}(\\rho N^2)` memory where :math:`\\rho`
    is the density of the sparse matrix.

    .. warning::

        If :math:`N` is large, it might take a long time to generate the
        correlation matrix.

    **Spatial Correlation:**

    The correlation matrix of size :math:`N \\times N` is generated by the
    mutual correlation of a set of :math:`N` points in the unit hypercube,
    :math:`\\boldsymbol{x}_i \\in [0, 1]^d`. The correlation between each two
    points :math:`\\boldsymbol{x}_i` and :math:`\\boldsymbol{x}_j` is computed
    by

    .. math::

        K_{i, j} = \\kappa \\left(r_{i,j} | \\theta \\right),

    where :math:`\\kappa` is a correlation kernel with the parameter
    :math:`\\theta`. Also

    .. math::

        r_{i,j} = \\frac{1}{\\rho}
        \\Vert \\boldsymbol{x}_i-\\boldsymbol{x}_j \\Vert_2,

    where :math:`\\rho` is a positive parameter that scales the Euclidean
    distance :math:`\\Vert \\cdot \\Vert_2`.

    The output matrix is symmetric and positive-definite. The values of the
    matrix elements are between `0` and `1`. The diagonal elements of the
    correlation matrix are `1`.

    **Kernel Functions:**

    * Exponential correlation

      .. math::

          \\kappa(r) = e^{-r}.

    * Square exponential correlation

      .. math::

          \\kappa(r) = e^{-\\frac{1}{2}x^2}.

    * Rational quadratic correlation (set :math:`\\alpha` by ``kernel_param``)

      .. math::

          \\kappa(r | \\alpha) =
          \\left(1 + \\frac{r^2}{2\\alpha} \\right)^{-\\alpha}.

    * Matern correlation (set :math:`\\nu` by ``kernel_param``)

      .. math::

          \\kappa(r | \\nu) = \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(
          \\sqrt{2 \\nu} r \\right)^{\\nu}
          K_{\\nu}\\left( \\sqrt{2 \\nu} r \\right),

      where :math:`K_{\\nu}` is the modified Bessel function of the
      second kind and :math:`\\Gamma` is the Gamma function. Both
      :math:`K_{\\nu}` and :math:`\\Gamma` are computed efficiently using the
      python package `special_functions
      <https://ameli.github.io/special_functions/index.html>`_.

      The Matern kernel with :math:`\\nu=\\frac{1}{2}` is equivalent to the
      exponential kernel. Also, :math:`\\nu = \\infty` is equivalent to the
      square exponential kernel. If :math:`\\nu > 100`, it is assumed that
      :math:`\\nu` is infinity. If :math:`\\nu = \\frac{3}{2}` the following
      expression of Matern kernel is used:

      .. math::

          \\kappa(r | \\textstyle{\\frac{3}{2}}) =
          \\left(1+ \\sqrt{3} r \\right) e^{-\\sqrt{3} r}.

      If :math:`\\nu = \\frac{5}{2}`, the Matern kernel is computed with:

      .. math::

          \\kappa(r | \\textstyle{\\frac{5}{2}}) =
          \\left(1+ \\sqrt{5} r + \\frac{5}{3} r^2 \\right) e^{-\\sqrt{5} r}.

    **Sparsification:**

    The values of the correlation matrix are between :math:`0` and :math:`1`.
    To sparsify the matrix, the correlation kernel below a certain threshold
    value, :math:`\\tau`, is set to zero to taper the correlation kernel.
    Namely, for all :math:`r > r_0` where
    :math:`\\kappa(r_0|\\theta) = \\tau`, we set
    :math:`\\kappa(r|\\theta) = 0`.

    The threshold :math:`\\tau` can be indirectly set through the parameter
    ``density``, which sets an approximate density of the non-zero elements of
    the sparse matrix.

    .. note::

        The actual density of the generated matrix might differ from the
        specified density if :math:`N` is small.

    The density :math:`\\rho` is related to the kernel threshold :math:`\\tau`
    by

    .. math::

        \\rho N = \\mathrm{Vol}_{d}(r_0/l),

    .. math::
        \\tau = \\kappa(r_0|\\theta),

    where :math:`\\mathrm{Vol}_{d}` is the volume of a `d`-ball and
    :math:`l = (\\sqrt[d]{n} - 1)^{-1}` is the grid size along each axis
    assuming the points are placed on an equal-distanced structured grid.

    The quantity :math:`\\rho N` is the number of points on an integer lattice
    and inside a `d`-ball. This quantity can be approximated by the volume of a
    `d`-ball, see for instance `Gauss circle problem
    <https://en.wikipedia.org/wiki/Gauss_circle_problem>`_ in 2D.

    .. warning::

        Setting a too small ``density`` might eradicate the
        positive-definiteness of the correlation matrix.

    If density :math:`\\rho` is set to be too low, the threshold :math:`\\tau`
    becomes too large and some elements of the correlation matrix will not be
    correlated to any other neighbor point. This leads to a correlation matrix
    where at some rows, the only non-zero element is its diagonal element.

    **Plotting:**

    If ``plot`` is set to `True`, it plots the matrix.

    * If no graphical backend exists (such as running the code on a remote
      server or manually disabling the X11 backend), the plot will not be
      shown, rather, it will be saved as an ``svg`` file in the current
      directory.
    * If the executable ``latex`` is available on ``PATH``, the plot is
      rendered using :math:`\\rm\\LaTeX` and it may take slightly longer to
      produce the plot.
    * If :math:`\\rm\\LaTeX` is not installed, it uses any available San-Serif
      font to render the plot.

    To manually disable interactive plot display and save the plot as
    ``svg`` instead, add the following at the very beginning of your code
    before importing :mod:`imate`:

    .. code-block:: python

        >>> import os
        >>> os.environ['IMATE_NO_DISPLAY'] = 'True'

    .. note::

        When plotting a `sparse` matrix, the plot does not show the `value` of
        the elements of matrix entries. Rather, it only shows boolean values
        indicating the non-zero elements by the value of `1`, and zero
        elsewhere.

    Examples
    --------

    Generate a matrix of the size `(20,20)` corresponding to the spatial
    correlation of a set of `20` points in the unit interval:

    .. code-block:: python

       >>> from imate.sample_matrices import correlation_matrix
       >>> A = correlation_matrix(20)

    Generate a matrix of the size :math:`(20^2, 20^2)` corresponding to the
    spatial correlation of a 2D grid of `20x20` points in the unit square:

    .. code-block:: python

       >>> from imate.sample_matrices import correlation_matrix
       >>> A = correlation_matrix(20, dimension=2)

    Generate a correlation matrix of the size `(20, 20)` based on 20 random
    points in unit square:

    .. code-block:: python

       >>> A = correlation_matrix(size=20, dimension=2, grid=False)

    Generate a matrix of the size :math:`(20^2, 20^2)` for the correlation of
    a grid of `20x20` points in the unit square using Matern correlation
    function with the parameter :math:`\\nu=2.5` and scale :math:`\\rho=0.2`,
    and plot the matrix:

    .. code-block:: python

       >>> correlation_matrix(size=20, dimension=2, kernel='matern',
       ...                    kernel_param=2.5, scale=0.2, plot=True)


    .. image:: ../_static/images/plots/correlation_matrix_dense.png
        :align: center
        :width: 60%
        :class: custom-dark

    Sparsify correlation matrix of size :math:`(30^2, 30^2)` with approximate
    density :math:`5 \\times 10^{-2}`. Use `CSR` format and `32-bit` floating
    point.

    .. code-block:: python

       >>> A = correlation_matrix(size=30, dimension=2, scale=0.1, sparse=True,
       ...                        density=5e-2, format='csr', dtype='float32')


    .. image:: ../_static/images/plots/correlation_matrix_sparse.png
        :align: center
        :width: 60%
        :class: custom-dark
    """

    # Check input arguments
    _check_arguments(size, dimension, scale, kernel, kernel_param, grid,
                     sparse, density, format, dtype, plot, verbose)

    # Default for kernel parameter
    if kernel_param is None:
        if kernel == 'matern':
            kernel_param = 0.5
        elif kernel == 'rational-quadratic':
            kernel_param = 1.0

    # Convert string to binary
    kernel = kernel.encode('utf-8')

    # correlation a set of points in the unit square
    coords = generate_points(size, dimension, grid)

    # Compute the correlation between the set of points
    if sparse:

        # Generate as sparse matrix
        correlation_matrix = sparse_correlation_matrix(
            coords,
            scale,
            kernel,
            kernel_param,
            density,
            format,
            dtype,
            verbose)

    else:

        # Generate a dense matrix
        correlation_matrix = dense_correlation_matrix(
            coords,
            scale,
            kernel,
            kernel_param,
            dtype,
            verbose)

    # Plot Correlation Matrix
    if plot:
        plot_matrix(correlation_matrix, sparse, verbose)

    return correlation_matrix


# ===============
# check arguments
# ===============

def _check_arguments(
        size,
        dimension,
        scale,
        kernel,
        kernel_param,
        grid,
        sparse,
        density,
        format,
        dtype,
        plot,
        verbose):
    """
    Checks the type and values of the input arguments.
    """

    # Check size
    if size is None:
        raise TypeError('"size" cannot be None.')
    elif not numpy.isscalar(size):
        raise TypeError('"size" should be a scalar value.')
    elif not isinstance(size, (int, numpy.integer)):
        TypeError('"size" should be an integer.')
    elif size < 1:
        raise ValueError('"size" should be a positive integer.')

    # Check dimension
    if dimension is None:
        raise TypeError('"dimension" cannot be None.')
    elif not numpy.isscalar(dimension):
        raise TypeError('"dimension" should be a scalar value.')
    elif not isinstance(dimension, (int, numpy.integer)):
        TypeError('"dimension" should be an integer.')
    elif dimension < 1:
        raise ValueError('"dimension" should be a positive integer.')

    # Check scale
    if scale is None:
        raise TypeError('"scale" cannot be None.')
    elif not numpy.isscalar(scale):
        raise TypeError('"scale" should be a scalar value.')
    elif isinstance(scale, complex):
        TypeError('"scale" should be a float number.')
    elif scale <= 0.0:
        raise ValueError('"scale" should be a positive number.')

    # Check kernel
    if not isinstance(kernel, str):
        raise TypeError('"kernel" should be a string.')
    elif kernel not in ['matern', 'exponential', 'square_exponential',
                        'rational_quadratic']:
        raise ValueError('"kernel" should be one of "matern", ' +
                         '"exponential", "square-exponential", or ' +
                         '"ratioanl_quadratic".')

    # Check kernel_param
    if kernel_param is not None:
        if not numpy.isscalar(kernel_param):
            raise TypeError('"kernel_param" should be a scalar value.')
        elif isinstance(kernel_param, complex):
            TypeError('"kernel_param" should be an float number.')
        elif kernel == 'exponental' and kernel_param is not None:
            raise ValueError('When "kernel" is "exponential", ' +
                             '"kernel_param" should be "None".')
        elif kernel == 'square-exponental' and kernel_param is not None:
            raise ValueError('When "kernel" is "-square-exponential", ' +
                             '"kernel_param" should be "None".')

    # Check grid
    if grid is None:
        raise TypeError('"grid" cannot be None.')
    elif not numpy.isscalar(grid):
        raise TypeError('"grid" should be a scalar value.')
    elif not isinstance(grid, bool):
        TypeError('"grid" should be boolean.')

    # Check sparse
    if sparse is None:
        raise TypeError('"sparse" cannot be None.')
    elif not numpy.isscalar(sparse):
        raise TypeError('"sparse" should be a scalar value.')
    elif not isinstance(sparse, bool):
        TypeError('"sparse" should be boolean.')

    # Check density
    if density is None:
        raise TypeError('"density" cannot be None.')
    elif not numpy.isscalar(density):
        raise TypeError('"density" should be a scalar value.')
    elif isinstance(density, complex):
        TypeError('"density" should be a float number.')
    elif density <= 0.0 or density >= 1.0:
        raise ValueError('"density" hshould be between "0.0" and "1.0".')

    # Check format
    if format is None:
        raise TypeError('"format" cannot be None.')
    elif not numpy.isscalar(format):
        raise TypeError('"format" should be a scalar value.')
    elif not isinstance(format, str):
        raise TypeError('"format" should be a string')
    elif format not in [r'csr', r'csc']:
        raise TypeError('"format" should be either "csr" or "csc"')

    # Check dtype
    if dtype is None:
        raise TypeError('"dtype" cannot be None.')
    elif not numpy.isscalar(dtype):
        raise TypeError('"dtype" should be a scalar value.')
    elif not isinstance(dtype, str):
        raise TypeError('"dtype" should be a string')
    elif dtype not in [r'float32', r'float64', r'float128']:
        raise TypeError('"dtype" should be either "float32", "float64", or ' +
                        '"float128".')

    # Check plot
    if plot is None:
        raise TypeError('"plot" cannot be None.')
    elif not numpy.isscalar(plot):
        raise TypeError('"plot" should be a scalar value.')
    elif not isinstance(plot, bool):
        TypeError('"plot" should be boolean.')

    # Check if plot modules exist
    if plot is True:
        try:
            from .._utilities.plot_utilities import matplotlib      # noqa F401
            from .._utilities.plot_utilities import load_plot_settings
            load_plot_settings()
        except ImportError:
            raise ImportError('Cannot import modules for plotting. Either ' +
                              'install "matplotlib" and "seaborn" packages, ' +
                              'or set "plot=False".')

    # Check verbose
    if verbose is None:
        raise TypeError('"verbose" cannot be None.')
    elif not numpy.isscalar(verbose):
        raise TypeError('"verbose" should be a scalar value.')
    elif not isinstance(verbose, bool):
        TypeError('"verbose" should be boolean.')


# ===========
# plot Matrix
# ===========

def plot_matrix(matrix, sparse, verbose=False):
    """
    Plots a given matrix.

    If the matrix is a sparse, it plots all non-zero elements with single
    color regardless of their values, and leaves the zero elements white.

    Whereas, if the matrix is not a sparse matrix, the colormap of the plot
    correspond to the value of the elements of the matrix.

    If a graphical backend is not provided, the plot is not displayed,
    rather saved as ``SVG`` file in the current directory of user.

    :param matrix: A 2D array
    :type matrix: numpy.ndarray or scipy.sparse.csc_matrix

    :param sparse: Determine whether the matrix is dense or sparse
    :type sparse: bool

    :param verbose: If `True`, prints some information during the process.
    :type verbose: bool
    """

    if not plot_modules_exist:
        raise ImportError('Cannot import modules for plotting. Either ' +
                          'install "matplotlib" and "seaborn" packages, ' +
                          'or set "plot=False".')

    # Load plot settings
    try:
        load_plot_settings()
    except ImportError:
        raise ImportError('Cannot import modules for plotting. Either ' +
                          'install "matplotlib" and "seaborn" packages, ' +
                          'or set "plot=False".')

    # Figure
    fig, ax = plt.subplots(figsize=(5, 4))

    if sparse:
        # Plot sparse matrix
        p = ax.spy(matrix, markersize=1, color='black', rasterized=True)
    else:
        # Plot dense matrix
        p = ax.matshow(matrix, cmap='Blues')
        cbar = fig.colorbar(p, ax=ax)
        cbar.set_label('Correlation')

    ax.set_title('Correlation Matrix', y=1.11)
    ax.set_xlabel('Index $i$')
    ax.set_ylabel('Index $j$')

    plt.tight_layout()

    # Check if the graphical backend exists
    if matplotlib.get_backend() != 'agg':
        plt.show()
    else:
        # write the plot as SVG file in the current working directory
        save_plot(plt, 'correlation_matrix', transparent_background=True)
