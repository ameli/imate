<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Doxygen Awesome" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="Doxygen Awesome" />
<meta name="twitter:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<!-- END twitter metadata -->
<title>imate: imate.trace._slq_method Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/AMSfonts.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/ameli/imate" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-imate-light.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">imate
   </div>
   <div id="projectbrief">C++/CUDA Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceimate_1_1trace_1_1__slq__method.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">imate.trace._slq_method Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad6a5f697bb58bb59994379b4e1fe6cbb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceimate_1_1trace_1_1__slq__method.html#ad6a5f697bb58bb59994379b4e1fe6cbb">slq_method</a> (A, gram=False, p=1.0, return_info=False, parameters=None, min_num_samples=10, max_num_samples=50, error_atol=None, error_rtol=1e-2, confidence_level=0.95, outlier_significance_level=0.001, lanczos_degree=20, lanczos_tol=None, orthogonalize=0, num_threads=0, num_gpu_devices=0, verbose=False, plot=False, gpu=False)</td></tr>
<tr class="separator:ad6a5f697bb58bb59994379b4e1fe6cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad6a5f697bb58bb59994379b4e1fe6cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a5f697bb58bb59994379b4e1fe6cbb">&#9670;&nbsp;</a></span>slq_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def imate.trace._slq_method.slq_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gram</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_info</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_num_samples</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_num_samples</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_atol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>error_rtol</em> = <code>1e-2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>confidence_level</em> = <code>0.95</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outlier_significance_level</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lanczos_degree</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lanczos_tol</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orthogonalize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num_gpu_devices</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plot</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gpu</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Trace of matrix or linear operator using stochastic Lanczos quadrature
method.

Given the matrix or the linear operator :math:`\\mathbf{A}` and the real
non-negative exponent :math:`p \\geq 0`, the following is computed:

.. math::

    \\mathrm{trace} \\left(\\mathbf{A}^p \\right).

If ``gram`` is `True`, then :math:`\\mathbf{A}` in the above is replaced by
the Gramian matrix :math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`, and the
following is instead computed:

.. math::

    \\mathrm{trace} \\left((\\mathbf{A}^{\\intercal}\\mathbf{A})^p
    \\right).

If :math:`\\mathbf{A} = \\mathbf{A}(t)` is a linear operator of the class
:class:`imate.AffineMatrixFunction` with the parameter :math:`t`, then for
an input  tuple :math:`t = (t_1, \\dots, t_q)`, an array output of the
size :math:`q` is returned, namely:

.. math::

    \\mathrm{trace} \\left((\\mathbf{A}(t_i))^p \\right),
    \\quad i=1, \\dots, q.

Parameters
----------

A : numpy.ndarray, scipy.sparse, :class:`imate.Matrix`, or \
        :class:`imate.AffineMatrixFunction`
    A sparse or dense matrix or linear operator. If ``gram`` is `False`,
    then `A` should be symmetric.

    .. warning::

        The symmetry of `A` is not pre-checked by this function. If
        ``gram`` is `False`, make sure `A` is symmetric.

gram : bool, default=False
    If `True`, the trace of the Gramian matrix,
    :math:`(\\mathbf{A}^{\\intercal}\\mathbf{A})^p`, is computed. The
    Gramian matrix itself is not directly computed. If `False`, the
    trace of :math:`\\mathbf{A}^p` is computed.

p : float, default=1.0
    The non-negative real exponent :math:`p` in :math:`\\mathbf{A}^p`.

return_info : bool, default=False
    If `True`, this function also returns a dictionary containing
    information about the inner computation, such as process time,
    algorithm settings, etc.

parameters : array_like [`float`], default=one
    This argument is relevant if `A` is a type of
    :class:`AffineMatrixFunction`. By this argument, multiple inquiries,
    :math:`(t_1, \\dots, t_q)`, can be passed to the parameter :math:`t` of
    the linear operator :math:`\\mathbf{A}(t)`. The output of this function
    becomes an array of the size :math:`q` corresponding to each of the
    input matrices :math:`\\mathbf{A}(t_i)`.

min_num_samples : int, default=10
    The minimum number of Monte-Carlo samples. If the convergence criterion
    is reached before finishing the minimum number of iterations, the
    iterations are forced to continue till the minimum number of iterations
    is finished. This value should be smaller than
    ``maximum_num_samples``.

max_num_samples : int, default=50
    The maximum number of Monte-Carlo samples. If the convergence criterion
    is not reached by the maximum number of iterations, the iterations are
    forced to stop. This value should be larger than
    ``minimum_num_samples``.

error_atol : float, default=None
    Tolerance of the absolute error of convergence of the output. Once the
    error of convergence reaches ``error_atol + error_rtol * output``, the
    iteration is terminated. If the convergence criterion is not met by the
    tolerance, then the iterations continue till reaching
    ``max_num_samples`` iterations. If `None`, the termination criterion
    does not depend on this parameter.

error_rtol : float, default=None
    Tolerance of the relative error of convergence of the output. Once the
    error of convergence reaches ``error_atol + error_rtol * output``, the
    iteration is terminated. If the convergence criterion is not met by the
    tolerance, then the iterations continue till reaching
    ``max_num_samples`` iterations. If `None`, the termination criterion
    does not depend on this parameter.

confidence_level : float, default=0.95
    Confidence level of error, which is a number between `0` and `1`. The
    error of convergence of the population of samples is defined by their
    standard deviation times the Z-score, which depends on the confidence
    level. See notes below for details.

outlier_significance_level : float, default=0.001
    One minus the confidence level of the uncertainty of the outliers of
    the output samples. This is a number between `0` and `1`.

lanczos_degree : int, default=20
    The number of Lanczos recursive iterations. The larger Lanczos degree
    leads to better estimation. The computational cost quadratically
    increases with the Lanczos degree.

lanczos_tol : float, default=None
    The tolerance to stop the Lanczos recursive iterations before
    the end of iterations reached. If the tolerance is not met, all the
    iterations (total of ``lanczos_degree`` iterations) continue till the
    end. If set to `None` (default value), the machine' epsilon precision
    is used. The machine's epsilon precision is as follows:

    * For 32-bit, machine precision is
      :math:`2^{-23} = 1.1920929 \\times 10^{-7}`.
    * For 64-bit, machine precision is
      :math:`2^{-52} = 2.220446049250313 \\times 10^{-16}`,
    * For 128-bit, machine precision is
      :math:`2^{-63} = -1.084202172485504434 \\times 10^{-19}`.

orthogonalize : int, default=0
    Indicates whether to re-orthogonalize the eigenvectors during Lanczos
    recursive iterations.

    * If set to `0`, no orthogonalization is performed.
    * If set to a negative integer or an integer larger than
      ``lanczos_degree``, a newly computed eigenvector is orthogonalized
      against all the previous eigenvectors (also known as
      `full reorthogonalization`).
    * If set to a positive integer, say `q`, but less than
      ``lanczos_degree``, the newly computed eigenvector is
      orthogonalized against a window of last `q` previous eigenvectors
      (known as `partial reorthogonalization`).

num_threads : int, default=0
    Number of processor threads to employ for parallel computation on CPU.
    If set to `0` or a number larger than the available number of threads,
    all threads of the processor are used. The parallelization is performed
    over the Monte-Carlo iterations.

num_gpu_devices : int default=0
    Number of GPU devices (if available) to use for parallel multi-GPU
    processing. If set to `0`, the maximum number of available GPU devices
    is used. This parameter is relevant if ``gpu`` is `True`.

gpu : bool, default=False
    If `True`, the computations are performed on GPU devices where the
    number of devices can be set by ``num_gpu_devices``. If no GPU device
    is found, it raises an error.

    .. note::
        When performing `repetitive` computation on the same matrix on GPU,
        it is recommended to input `A` as an instance of
        :class:`imate.Matrix` class instead of `numpy` or `scipy` matrices.
        See examples below for clarification.

verbose : bool, default=False
    Prints extra information about the computations.

plot : bool, default=False
    Plots convergence of samples. For this, the packages `matplotlib` and
    `seaborn` should be installed. If no display is available (such as
    running this code on remote machines), the plots are saved as an `SVG`
    file in the current directory.

Returns
-------

Trace : float or numpy.array
    Trace of matrix. If `A` is of type
    :class:`imate.AffineMatrixFunction` with an array of ``parameters``,
    then the output is an array.

info : dict
    (Only if ``return_info`` is `True`) A dictionary of information with
    the following.

    * ``matrix``:
        * ``data_type``: `str`, {`float32`, `float64`, `float128`}. Type of
          the matrix data.
        * ``gram``: `bool`, whether the matrix `A` or its Gramian is
          considered.
        * ``exponent``: `float`, the exponent `p` in :math:`\\mathbf{A}^p`.
        * ``size``: (int) The size of matrix `A`.
        * ``sparse``: `bool`, whether the matrix `A` is sparse or dense.
        * ``nnz``: `int`, if `A` is sparse, the number of non-zero elements
          of `A`.
        * ``density``: `float`, if `A` is sparse, the density of `A`, which
          is the `nnz` divided by size squared.
        * ``num_inquiries``: `int`, the size of inquiries of each parameter
          of the linear operator `A`. If `A` is a matrix, this is always
          `1`. If `A` is a type of :class:`AffineMatrixFunction`, this
          value is the number of :math:`t_i` parameters.
        * ``num_operator_parameters``: `int`, number of parameters of the
          operator `A`. If `A` a type of :class:`AffineMatrixFunction`,
          then this value is `1` corresponding to one parameter :math:`t`
          in the affine function `t \\mapsto \\mathbf{A} + t \\mathbf{B}`.
        * ``parameters``: `list` [`float`], the parameters of the linear
          operator `A`.

    * ``convergence``:
        * ``all_converged``: `bool`, whether the Monte-Carlo sampling
          converged for all requested parameters :math:`t_i`. If all
          entries of the array for ``converged`` is `True``, then this
          value is also ``True``.
        * ``converged``: `array` [`bool`], whether the Monte-Carlo sampling
          converged for each of the requested parameters :math:`t_i`.
          Convergence is defined based on a termination criterion, such
          as absolute or relative error. If the iterations terminated due
          to reaching the maximum number of samples, this value is `False`.
        * ``min_num_samples``: `int`, the minimum number of Monte-Carlo
          iterations.
        * ``max_num_samples``: `int`, the maximum number of Monte-Carlo
          iterations.
        * ``num_outliers``: `int`, number of outliers found during search
          for outliers among the array of output.
        * ``num_samples_used``: `int`, number of Monte-Carlo samples used
          to produce the output. This is the total number of iterations
          minus the number of outliers.
        * ``samples``: `array` [`float`], an array of the size
          `max_num_samples`. The first few entries (`num_samples_used`) of
          this array are the output results of the Monte-Carlo sampling.
          The average of these samples is the final result. The rest of
          this array is `nan`.
        * ``samples_mean``: `float`, mean of the `samples` array, excluding
          the `nan` values.
        * ``samples_processed_order``: `array` [`int`], in parallel
          processing, samples are processed in non-sequential order. This
          array, which has the same size as `samples`, keeps track of the
          order in which each sample is processed.

    * ``error``:
        * ``absolute_error``: `float`, the absolute error of the
          convergence of samples.
        * ``confidence_level``: `float`, the confidence level used to
          calculate the error from standard deviation of samples.
        * ``error_atol``: `float`, the tolerance of absolute error of the
          convergence of samples.
        * ``error_rtol``: `float`, the tolerance of relative error of the
          convergence of samples.
        * ``outlier_significance_level``: `float`, the significance level
          used to determine the outliers in samples.
        * ``relative_error``: `float`, the relative error of the
          convergence of samples.

    * ``device``:
        * ``num_cpu_threads``: `int`, number of CPU threads used in shared
          memory parallel processing.
        * ``num_gpu_devices``: `int`, number of GPU devices used in the
          multi-GPU (GPU farm) computation.
        * ``num_gpu_multiprocessors``: `int`, number of GPU
          multi-processors.
        * ``num_gpu_threads_per_multiprocessor``: `int`, number of GPU
          threads on each GPU multi-processor.

    * ``time``:
        * ``tot_wall_time``: `float`, total elapsed time of computation.
        * ``alg_wall_time``: `float`, elapsed time of computation during
          only the algorithm execution.
        * ``cpu_proc_time``: `float`, the CPU processing time of
          computation.

    * ``solver``:
        * ``version``: `str`, version of imate.
        * ``method``: 'slq'.
        * ``lanczos_degree``: `bool`, Lanczos degree.
        * ``lanczos_tol``: `float`, Lanczos tolerance.
        * ``orthogonalize``: `int`, orthogonalization flag.

Raises
------

ImportError
    If the package has not been compiled with GPU support, but ``gpu`` is
    set to `True`. To resolve the issue, set ``gpu`` to `False` to be able
    to use the existing installation. Alternatively,  export the
    environment variable ``USE_CUDA=1`` and recompile the source code of
    the package.

See Also
--------

imate.logdet
imate.traceinv
imate.schatten

Notes
-----

**Computational Complexity:**

This method uses stochastic Lanczos quadrature (SLQ), which is a randomized
algorithm. The computational complexity of this method is

.. math::

    \\mathcal{O}((\\rho n^2 + n l) s l),

where :math:`n` is the matrix size, :math:`\\rho` is the density of
sparse matrix (for dense matrix, :math:`\\rho=1`), :math:`l` is the
Lanczos degree (set with ``lanczos_degree``), and :math:`s` is the number
of samples (set with ``min_num_samples`` and ``max_num_samples``).

This method can be used on very large matrices (:math:`n &gt; 2^{12}`). The
solution is an approximation.

**Input Matrix:**

The input `A` can be either of:

* A matrix, such as `numpy.ndarray`, or `scipy.sparse`.
* A linear operator representing a matrix using :class:`imate.Matrix`.
* A linear operator representing a one-parameter family of an affine matrix
  function :math:`t \\mapsto \\mathbf{A} + t\\mathbf{B}` using
  :class:`imate.AffineMatrixFunction`.

**Output:**

The output is a scalar. However, if `A` is the linear operator
:math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{B}` where :math:`t` is
given as the tuple :math:`t = (t_1, \\dots, t_q)`, then the output of this
function is an array of size :math:`q` corresponding to the
trace of each :math:`\\mathbf{A}(t_i)`.

.. note::

    When `A` represents
    :math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{I}`, where
    :math:`\\mathbf{I}` is the identity matrix, and :math:`t` is given by
    a tuple :math:`t = (t_1, \\dots, t_q)`, the computational cost of an
    array output of size `q` is the same as computing for a single
    :math:`t_i`. Namely, the trace of only :math:`\\mathbf{A}(t_1)` is
    computed, and the trace of the rest of :math:`i=2, \\dots, q` are
    obtained from the result of :math:`t_1` immediately.

**Algorithm:**

If ``gram`` is `False`, the Lanczos tri-diagonalization method is
used. This method requires only matrix-vector multiplication. If
``gram`` is `True`, the Golub-Kahn bi-diagonalization method is used. This
method requires both matrix-vector multiplication and transposed-matrix
vector multiplications.

**Convergence criterion:**

Let :math:`n_{\\min}` and :math:`n_{\\max}` be the minimum and maximum
number of iterations respectively defined by ``min_num_samples`` and
``max_num_samples``. The iterations terminate at
:math:`n_{\\min} \\leq i \\leq n_{\\max}` where :math:`i` is the
iteration counter. The iterations stop earlier at :math:`i &lt; n_{\\max}` if
the convergence error of the mean of the samples is satisfied, as follows.

Suppose :math:`s(j)` and :math:`\\sigma(i)` are respectively the mean and
standard deviation of samples after :math:`j` iterations. The error of
convergence, :math:`e(j)`, is defined by

.. math::

    e(j) = \\frac{\\sigma(j)}{\\sqrt{j}} Z

where :math:`Z` is the Z-score defined by

.. math::

    Z = \\sqrt{2} \\mathrm{erf}^{-1}(\\phi).

In the above, :math:`\\phi` is the confidence level and set by
``confidence_level`` argument, and :math:`\\mathrm{erf}^{-1}` is the
inverse error function. A confidence level of 95%, for instance, means that
the Z-score is 1.96, which means the confidence interval is
:math:`\\pm 1.96 \\sigma`.

The termination criterion is

.. math::

    e(j) &lt; \\epsilon_a + s(j) \\epsilon_r,

where :math:`\\epsilon_{a}` and :math:`\\epsilon_r` are the absolute and
relative error tolerances respectively, and they are set by ``error_atol``
and ``error_rtol``.

**Convergence for the case of multiple parameters:**

When `A` is a type of :class:`imate.AffineMatrixFunction` representing the
affine matrix function :math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{B}`
and if multiple parameters :math:`t_i`, :math:`i=1,\\dots, q` are passed to
this function through ``parameters`` argument, the convergence criterion
has to be satisfied for each of :math:`\\mathbf{A}(t_i)`. Specifically, the
iterations are terminated as follows:

* If :math:`\\mathbf{B}` is the identity matrix, iterations for all
  :math:`\\mathbf{A}(t_i)` continue till the convergence criterion for
  *all* :math:`t_i` are satisfied. That is, even if :math:`t=t_i` is
  converged but :math:`t=t_j` has not converged yet, the iterations for
  :math:`t=t_i` will continue.
  :
* If :math:`\\mathbf{B}` is not the identity matrix, the iterations for
  each of :math:`t_i` are independent. That is, if :math:`t=t_i` converges,
  the iterations for that parameter will stop regardless of the convergence
  status of other parameters.

**Plotting:**

If ``plot`` is set to `True`, it plots the convergence of samples and their
relative error.

* If no graphical backend exists (such as running the code on a remote
  server or manually disabling the X11 backend), the plot will not be
  shown, rather, it will be saved as an ``svg`` file in the current
  directory.
* If the executable ``latex`` is available on ``PATH``, the plot is
  rendered using :math:`\\rm\\LaTeX` and it may take slightly longer to
  produce the plot.
* If :math:`\\rm\\LaTeX` is not installed, it uses any available San-Serif
  font to render the plot.

To manually disable interactive plot display and save the plot as
``svg`` instead, add the following at the very beginning of your code
before importing :mod:`imate`:

.. code-block:: python

    &gt;&gt;&gt; import os
    &gt;&gt;&gt; os.environ['IMATE_NO_DISPLAY'] = 'True'

References
----------

* `Ubaru, S., Chen, J., and Saad, Y. (2017)
  &lt;https://www-users.cs.umn.edu/~saad/PDF/ys-2016-04.pdf&gt;`_,
  Fast Estimation of :math:`\\mathrm{tr}(F(A))` Via Stochastic Lanczos
  Quadrature, SIAM J. Matrix Anal. Appl., 38(4), 1075-1099.

Examples
--------

**Symmetric Input Matrix:**

The `slq` method requires the input matrix of :func:`imate.trace` function
to be symmetric when ``gram`` is `False`. For the first example, generate a
symmetric sample matrix using :func:`imate.toeplitz` function as follows:

.. code-block:: python

    &gt;&gt;&gt; # Import packages
    &gt;&gt;&gt; from imate import toeplitz

    &gt;&gt;&gt; # Generate a symmetric matrix by setting gram=True.
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)

In the above, by passing ``gram=True`` to :func:`imate.toeplitz` function,
the Gramian of the Toeplitz matrix is returned, which is symmetric. Compute
the trace of :math:`\\mathbf{A}^{2.5}`:

.. code-block:: python

    &gt;&gt;&gt; # Import packages
    &gt;&gt;&gt; from imate import trace

    &gt;&gt;&gt; # Compute trace
    &gt;&gt;&gt; trace(A, gram=False, p=2.5, method='slq')
    3177.56

.. note:

    Since `slq` is a stochastic method, the above result slightly
    differs after each run.

**Gramian Matrix:**

Passing ``gram=True`` to :func:`imate.trace` function uses the Gramian
of the input matrix. In this case, the input matrix can be non-symmetric.
In the next example, generate a non-symmetric matrix, :math:`\\mathbf{B}`,
then compute the trace of
:math:`(\\mathbf{B}^{\\intercal} \\mathbf{B})^{2.5}`.

.. code-block:: python

    &gt;&gt;&gt; # Generate a non-symmetric matrix by setting gram=False
    &gt;&gt;&gt; B = toeplitz(2, 1, size=100, gram=False)

    &gt;&gt;&gt; # Compute the trace of Gramian by passing gram=True
    &gt;&gt;&gt; trace(B, gram=True, p=2.5, method='slq')
    3180.60

Note that the result of the two examples in the above are the similar since
the input matrix :math:`\\mathbf{A}` of the first example is the Gramian of
the input matrix :math:`\\mathbf{B}` in the second example, that is
:math:`\\mathbf{A} = \\mathbf{B}^{\\intercal} \\mathbf{B}`. Since the
second example uses the Gramian of the input matrix, it computes the same
quantity as the first example.

**Verbose output:**

By setting ``verbose`` to `True`, useful info about the process is
printed.

.. literalinclude:: ../_static/data/imate.trace.slq-verbose-1.txt
    :language: python

**Output information:**

Print information about the inner computation:

.. code-block:: python

    &gt;&gt;&gt; tr, info = trace(A, method='slq', return_info=True)
    &gt;&gt;&gt; print(tr)
    506.04

    &gt;&gt;&gt; # Print dictionary neatly using pprint
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; pprint(info)
    {
        'convergence': {
            'all_converged': False,
            'converged': False,
            'max_num_samples': 50,
            'min_num_samples': 10,
            'num_outliers': 0,
            'num_samples_used': 50,
            'samples': array([527., ..., 495.]),
            'samples_mean': 506.04,
            'samples_processed_order': array([ 2, ..., 49])
        },
        'device': {
            'num_cpu_threads': 8,
            'num_gpu_devices': 0,
            'num_gpu_multiprocessors': 0,
            'num_gpu_threads_per_multiprocessor': 0
        },
        'error': {
            'absolute_error': 10.380366588608128,
           'confidence_level': 0.95,
           'error_atol': 0.0,
           'error_rtol': 0.01,
           'outlier_significance_level': 0.001,
           'relative_error': 0.02051293689947065
        },
        'matrix': {
            'data_type': b'float64',
            'density': 0.0298,
            'exponent': 1.0,
            'gram': False,
            'nnz': 298,
            'num_inquiries': 1,
            'num_operator_parameters': 0,
            'parameters': None,
            'size': 100,
            'sparse': True
        },
        'solver': {
            'lanczos_degree': 20,
            'lanczos_tol': 2.220446049250313e-16,
            'method': 'slq',
            'orthogonalize': 0,
            'version': '0.15.0'
        },
        'time': {
            'alg_wall_time': 0.003865957260131836,
          'cpu_proc_time': 0.021690301999999884,
          'tot_wall_time': 0.0040010069496929646
        }
    }

**Large matrix:**

Compute the trace of :math:`\\mathbf{A}` for a very large sparse
matrix using at least `100` samples. Note that the matrix
:math:`\\mathbf{A}` should be symmetric.

.. code-block:: python
    :emphasize-lines: 7, 8

    &gt;&gt;&gt; # Generate a matrix of size one million. Set gram=True to create
    &gt;&gt;&gt; # a symmetric matrix needed for slq method.
    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000, gram=True)

    &gt;&gt;&gt; # Approximate trace using stochastic Lanczos quadrature
    &gt;&gt;&gt; # with at least 100 Monte-Carlo sampling
    &gt;&gt;&gt; tr, info = trace(A, method='slq', min_num_samples=100,
    ...                  max_num_samples=200, return_info=True)
    &gt;&gt;&gt; print(tr)
    4999763.32

    &gt;&gt;&gt; # Find the time it took to compute the above
    &gt;&gt;&gt; print(info['time'])
    {
        'tot_wall_time': 16.101079436950386,
        'alg_wall_time': 16.08251190185547,
        'cpu_proc_time': 117.259937983
    }

Compare the result of the above approximation with the exact solution of
the trace using the analytic relation for Toeplitz matrix. See
:func:`imate.sample_matrices.toeplitz_trace` for details.

.. code-block:: python

    &gt;&gt;&gt; from imate.sample_matrices import toeplitz_trace
    &gt;&gt;&gt; toeplitz_trace(2, 1, size=1000000, gram=True)
    4999999

It can be seen that the error of approximation is :math:`0.008 \\%`. This
accuracy is remarkable considering that the computation on such a large
matrix took only 16 seconds. Computing the trace of such a large matrix
using any of the exact methods (such as ``exact`` or ``eigenvalue``) is
infeasible.

**Plotting:**

By setting ``plot`` to `True`, plots of samples during Monte-Carlo
iterations and the convergence of their mean are generated.

.. code-block:: python

    &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000, gram=True)
    &gt;&gt;&gt; trace(A, method='slq', min_num_samples=20, max_num_samples=80,
    ...       error_rtol=2e-4, confidence_level=0.95,
    ...       outlier_significance_level=0.001, plot=True)

.. image:: ../_static/images/plots/trace_slq_convergence_1.png
    :align: center
    :class: custom-dark

In the left plot, the samples are shown in circles and the cumulative mean
of the samples is shown by a solid black curve. The shaded area corresponds
to the 95% confidence interval :math:`\\pm 1.96 \\sigma`, which is set by
``confidence_level=0.95``. The samples outside the interval of 99.9% are
considered outliers, which is set by the significance level
``outlier_significance_level=0.001``.

In the right plot, the darker shaded area in the interval :math:`[0, 20]`
shows the minimum number of samples and is set by ``min_num_samples=20``.
The iterations do not stop till the minimum number of iterations is passed.
We can observe that sampling is terminated after 55 iterations where the
relative error of samples reaches 0.02% since we set ``error_rtol=2e-4``.
The lighter shaded area in the interval :math:`[56, 80]` corresponds to the
iterations that were not performed to reach the specified maximum
iterations by ``max_num_samples=80``.

**Matrix operator:**

Use an object of :class:`imate.Matrix` class as an alternative method to
pass the matrix `A` to the `trace` function.

.. code-block:: python
    :emphasize-lines: 8

    &gt;&gt;&gt; # Import matrix operator
    &gt;&gt;&gt; from imate import toeplitz, trace, Matrix

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)

    &gt;&gt;&gt; # Create a matrix operator object from matrix A
    &gt;&gt;&gt; Aop = Matrix(A)

    &gt;&gt;&gt; # Compute the trace of Aop
    &gt;&gt;&gt; trace(Aop, method='slq')
    493.08

An advantage of passing `Aop` (instead of `A`) to the `trace` function
will be clear when using GPU.

**Computation on GPU:**

The argument ``gpu=True`` performs the computations on GPU. The following
example uses the object `Aop` created earlier.

.. code-block:: python

    &gt;&gt;&gt; # Compute thet race of Aop
    &gt;&gt;&gt; trace(Aop, method='slq', gpu=True)
    493.08

The above function call triggers the object `Aop` to automatically load the
matrix data on the GPU.

One could have used `A` instead of `Aop` in the above. However, an
advantage of using `Aop` (instead of the matrix `A` directly) is that by
calling the above `trace` function (or another function) again on this
matrix, the data of this matrix does not have to be re-allocated on the GPU
device again. To highlight this point, call the above function again, but
this time, set ``gram`` to `True` to compute something different.

.. code-block:: python

    &gt;&gt;&gt; # Compute the trace of Aop
    &gt;&gt;&gt; trace(Aop, method='slq', gpu=True, gram=True)
    493.08

In the above example, no data is needed to be transferred from CPU host to
GPU device again. However, if `A` was used instead of `Aop`, the data would
have been transferred from CPU to GPU again for the second time. The `Aop`
object holds the data on GPU for later use as long as this object does no
go out of the scope of the python environment. Once the variable `Aop` goes
out of scope, the matrix data on all the GPU devices will be cleaned
automatically.

**Affine matrix operator:**

Use an object of :class:`imate.AffineMatrixFunction` to create the linear
operator

.. math::

    \\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{I}.

The object :math:`\\mathbf{A}(t)` can be passed to `trace` function with
multiple values for the parameter :math:`t` to compute their trace  all at
once, as follows.

.. code-block:: python
    :emphasize-lines: 8

    &gt;&gt;&gt; # Import affine matrix function
    &gt;&gt;&gt; from imate import toeplitz, trace, AffineMatrixFunction

    &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)
    &gt;&gt;&gt; A = toeplitz(2, 1, size=10000, gram=True)

    &gt;&gt;&gt; # Create a matrix operator object from matrix A
    &gt;&gt;&gt; Aop = AffineMatrixFunction(A)

    &gt;&gt;&gt; # A list of parameters t to pass to Aop
    &gt;&gt;&gt; t = [-1.0, 0.5, 1.0]

    &gt;&gt;&gt; # Compute the trace of Aop for all parameters t
    &gt;&gt;&gt; trace(Aop, method='slq', parameters=t, min_num_samples=50,
    ...       max_num_samples=150, error_rtol=2e-3, confidence_level=0.95,
    ...       outlier_significance_level=0.001, plot=True, verbose=True)
    [39988.03448276 54988.03448276 59988.03448276]

The output of the verbose argument is shown below. In the results section
of the table below, each row `i` under the `inquiry` column corresponds to
each element of the parameters ``t = [-1, 0.5, 1]`` that was specified by
``parameters`` argument.

.. literalinclude:: ../_static/data/imate.trace.slq-verbose-2.txt
    :language: python

The output of the plot is shown below. Each colored curve corresponds to
a parameter in ``t = [-1, 0.5, 1]``.

.. image:: ../_static/images/plots/trace_slq_convergence_2.png
    :align: center
    :width: 80%
    :class: custom-dark
</pre> 
<p class="definition">Definition at line <a class="el" href="trace_2__slq__method_8pyx_source.html#l00025">25</a> of file <a class="el" href="trace_2__slq__method_8pyx_source.html">_slq_method.pyx</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        gpu=<span class="keyword">False</span>):</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="stringliteral">    Trace of matrix or linear operator using stochastic Lanczos quadrature</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="stringliteral">    method.</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="stringliteral">    Given the matrix or the linear operator :math:`\\mathbf{A}` and the real</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="stringliteral">    non-negative exponent :math:`p \\geq 0`, the following is computed:</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="stringliteral">    .. math::</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="stringliteral">        \\mathrm{trace} \\left(\\mathbf{A}^p \\right).</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="stringliteral">    If ``gram`` is `True`, then :math:`\\mathbf{A}` in the above is replaced by</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="stringliteral">    the Gramian matrix :math:`\\mathbf{A}^{\\intercal} \\mathbf{A}`, and the</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="stringliteral">    following is instead computed:</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="stringliteral">    .. math::</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="stringliteral">        \\mathrm{trace} \\left((\\mathbf{A}^{\\intercal}\\mathbf{A})^p</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="stringliteral">        \\right).</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="stringliteral">    If :math:`\\mathbf{A} = \\mathbf{A}(t)` is a linear operator of the class</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="stringliteral">    :class:`imate.AffineMatrixFunction` with the parameter :math:`t`, then for</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="stringliteral">    an input  tuple :math:`t = (t_1, \\dots, t_q)`, an array output of the</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="stringliteral">    size :math:`q` is returned, namely:</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="stringliteral">    .. math::</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="stringliteral">        \\mathrm{trace} \\left((\\mathbf{A}(t_i))^p \\right),</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="stringliteral">        \\quad i=1, \\dots, q.</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="stringliteral">    Parameters</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="stringliteral">    ----------</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="stringliteral">    A : numpy.ndarray, scipy.sparse, :class:`imate.Matrix`, or \</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="stringliteral">            :class:`imate.AffineMatrixFunction`</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="stringliteral">        A sparse or dense matrix or linear operator. If ``gram`` is `False`,</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="stringliteral">        then `A` should be symmetric.</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="stringliteral">        .. warning::</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="stringliteral">            The symmetry of `A` is not pre-checked by this function. If</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="stringliteral">            ``gram`` is `False`, make sure `A` is symmetric.</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="stringliteral">    gram : bool, default=False</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="stringliteral">        If `True`, the trace of the Gramian matrix,</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="stringliteral">        :math:`(\\mathbf{A}^{\\intercal}\\mathbf{A})^p`, is computed. The</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="stringliteral">        Gramian matrix itself is not directly computed. If `False`, the</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="stringliteral">        trace of :math:`\\mathbf{A}^p` is computed.</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="stringliteral">    p : float, default=1.0</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="stringliteral">        The non-negative real exponent :math:`p` in :math:`\\mathbf{A}^p`.</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="stringliteral">    return_info : bool, default=False</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="stringliteral">        If `True`, this function also returns a dictionary containing</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="stringliteral">        information about the inner computation, such as process time,</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="stringliteral">        algorithm settings, etc.</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="stringliteral">    parameters : array_like [`float`], default=one</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="stringliteral">        This argument is relevant if `A` is a type of</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="stringliteral">        :class:`AffineMatrixFunction`. By this argument, multiple inquiries,</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="stringliteral">        :math:`(t_1, \\dots, t_q)`, can be passed to the parameter :math:`t` of</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="stringliteral">        the linear operator :math:`\\mathbf{A}(t)`. The output of this function</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="stringliteral">        becomes an array of the size :math:`q` corresponding to each of the</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="stringliteral">        input matrices :math:`\\mathbf{A}(t_i)`.</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="stringliteral">    min_num_samples : int, default=10</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="stringliteral">        The minimum number of Monte-Carlo samples. If the convergence criterion</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="stringliteral">        is reached before finishing the minimum number of iterations, the</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="stringliteral">        iterations are forced to continue till the minimum number of iterations</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="stringliteral">        is finished. This value should be smaller than</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="stringliteral">        ``maximum_num_samples``.</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="stringliteral">    max_num_samples : int, default=50</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="stringliteral">        The maximum number of Monte-Carlo samples. If the convergence criterion</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="stringliteral">        is not reached by the maximum number of iterations, the iterations are</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="stringliteral">        forced to stop. This value should be larger than</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="stringliteral">        ``minimum_num_samples``.</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="stringliteral">    error_atol : float, default=None</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="stringliteral">        Tolerance of the absolute error of convergence of the output. Once the</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="stringliteral">        error of convergence reaches ``error_atol + error_rtol * output``, the</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="stringliteral">        iteration is terminated. If the convergence criterion is not met by the</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="stringliteral">        tolerance, then the iterations continue till reaching</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="stringliteral">        ``max_num_samples`` iterations. If `None`, the termination criterion</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="stringliteral">        does not depend on this parameter.</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="stringliteral">    error_rtol : float, default=None</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="stringliteral">        Tolerance of the relative error of convergence of the output. Once the</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="stringliteral">        error of convergence reaches ``error_atol + error_rtol * output``, the</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="stringliteral">        iteration is terminated. If the convergence criterion is not met by the</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="stringliteral">        tolerance, then the iterations continue till reaching</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="stringliteral">        ``max_num_samples`` iterations. If `None`, the termination criterion</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="stringliteral">        does not depend on this parameter.</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="stringliteral">    confidence_level : float, default=0.95</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="stringliteral">        Confidence level of error, which is a number between `0` and `1`. The</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="stringliteral">        error of convergence of the population of samples is defined by their</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="stringliteral">        standard deviation times the Z-score, which depends on the confidence</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="stringliteral">        level. See notes below for details.</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="stringliteral">    outlier_significance_level : float, default=0.001</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="stringliteral">        One minus the confidence level of the uncertainty of the outliers of</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="stringliteral">        the output samples. This is a number between `0` and `1`.</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="stringliteral">    lanczos_degree : int, default=20</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="stringliteral">        The number of Lanczos recursive iterations. The larger Lanczos degree</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="stringliteral">        leads to better estimation. The computational cost quadratically</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="stringliteral">        increases with the Lanczos degree.</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="stringliteral">    lanczos_tol : float, default=None</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="stringliteral">        The tolerance to stop the Lanczos recursive iterations before</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="stringliteral">        the end of iterations reached. If the tolerance is not met, all the</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="stringliteral">        iterations (total of ``lanczos_degree`` iterations) continue till the</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="stringliteral">        end. If set to `None` (default value), the machine&#39; epsilon precision</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="stringliteral">        is used. The machine&#39;s epsilon precision is as follows:</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="stringliteral">        * For 32-bit, machine precision is</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="stringliteral">          :math:`2^{-23} = 1.1920929 \\times 10^{-7}`.</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="stringliteral">        * For 64-bit, machine precision is</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="stringliteral">          :math:`2^{-52} = 2.220446049250313 \\times 10^{-16}`,</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="stringliteral">        * For 128-bit, machine precision is</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="stringliteral">          :math:`2^{-63} = -1.084202172485504434 \\times 10^{-19}`.</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="stringliteral">    orthogonalize : int, default=0</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="stringliteral">        Indicates whether to re-orthogonalize the eigenvectors during Lanczos</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="stringliteral">        recursive iterations.</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="stringliteral">        * If set to `0`, no orthogonalization is performed.</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="stringliteral">        * If set to a negative integer or an integer larger than</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="stringliteral">          ``lanczos_degree``, a newly computed eigenvector is orthogonalized</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="stringliteral">          against all the previous eigenvectors (also known as</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="stringliteral">          `full reorthogonalization`).</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="stringliteral">        * If set to a positive integer, say `q`, but less than</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="stringliteral">          ``lanczos_degree``, the newly computed eigenvector is</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="stringliteral">          orthogonalized against a window of last `q` previous eigenvectors</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="stringliteral">          (known as `partial reorthogonalization`).</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="stringliteral">    num_threads : int, default=0</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="stringliteral">        Number of processor threads to employ for parallel computation on CPU.</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="stringliteral">        If set to `0` or a number larger than the available number of threads,</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="stringliteral">        all threads of the processor are used. The parallelization is performed</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="stringliteral">        over the Monte-Carlo iterations.</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="stringliteral">    num_gpu_devices : int default=0</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="stringliteral">        Number of GPU devices (if available) to use for parallel multi-GPU</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="stringliteral">        processing. If set to `0`, the maximum number of available GPU devices</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="stringliteral">        is used. This parameter is relevant if ``gpu`` is `True`.</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="stringliteral">    gpu : bool, default=False</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="stringliteral">        If `True`, the computations are performed on GPU devices where the</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="stringliteral">        number of devices can be set by ``num_gpu_devices``. If no GPU device</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="stringliteral">        is found, it raises an error.</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="stringliteral">        .. note::</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="stringliteral">            When performing `repetitive` computation on the same matrix on GPU,</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="stringliteral">            it is recommended to input `A` as an instance of</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="stringliteral">            :class:`imate.Matrix` class instead of `numpy` or `scipy` matrices.</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="stringliteral">            See examples below for clarification.</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="stringliteral">    verbose : bool, default=False</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="stringliteral">        Prints extra information about the computations.</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="stringliteral">    plot : bool, default=False</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="stringliteral">        Plots convergence of samples. For this, the packages `matplotlib` and</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="stringliteral">        `seaborn` should be installed. If no display is available (such as</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="stringliteral">        running this code on remote machines), the plots are saved as an `SVG`</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="stringliteral">        file in the current directory.</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="stringliteral">    Returns</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="stringliteral">    -------</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="stringliteral">    Trace : float or numpy.array</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="stringliteral">        Trace of matrix. If `A` is of type</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="stringliteral">        :class:`imate.AffineMatrixFunction` with an array of ``parameters``,</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="stringliteral">        then the output is an array.</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="stringliteral">    info : dict</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="stringliteral">        (Only if ``return_info`` is `True`) A dictionary of information with</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="stringliteral">        the following.</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="stringliteral">        * ``matrix``:</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="stringliteral">            * ``data_type``: `str`, {`float32`, `float64`, `float128`}. Type of</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="stringliteral">              the matrix data.</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="stringliteral">            * ``gram``: `bool`, whether the matrix `A` or its Gramian is</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="stringliteral">              considered.</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="stringliteral">            * ``exponent``: `float`, the exponent `p` in :math:`\\mathbf{A}^p`.</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="stringliteral">            * ``size``: (int) The size of matrix `A`.</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="stringliteral">            * ``sparse``: `bool`, whether the matrix `A` is sparse or dense.</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="stringliteral">            * ``nnz``: `int`, if `A` is sparse, the number of non-zero elements</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="stringliteral">              of `A`.</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="stringliteral">            * ``density``: `float`, if `A` is sparse, the density of `A`, which</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="stringliteral">              is the `nnz` divided by size squared.</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="stringliteral">            * ``num_inquiries``: `int`, the size of inquiries of each parameter</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="stringliteral">              of the linear operator `A`. If `A` is a matrix, this is always</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="stringliteral">              `1`. If `A` is a type of :class:`AffineMatrixFunction`, this</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="stringliteral">              value is the number of :math:`t_i` parameters.</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="stringliteral">            * ``num_operator_parameters``: `int`, number of parameters of the</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="stringliteral">              operator `A`. If `A` a type of :class:`AffineMatrixFunction`,</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="stringliteral">              then this value is `1` corresponding to one parameter :math:`t`</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="stringliteral">              in the affine function `t \\mapsto \\mathbf{A} + t \\mathbf{B}`.</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="stringliteral">            * ``parameters``: `list` [`float`], the parameters of the linear</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="stringliteral">              operator `A`.</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="stringliteral">        * ``convergence``:</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="stringliteral">            * ``all_converged``: `bool`, whether the Monte-Carlo sampling</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="stringliteral">              converged for all requested parameters :math:`t_i`. If all</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="stringliteral">              entries of the array for ``converged`` is `True``, then this</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="stringliteral">              value is also ``True``.</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="stringliteral">            * ``converged``: `array` [`bool`], whether the Monte-Carlo sampling</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="stringliteral">              converged for each of the requested parameters :math:`t_i`.</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="stringliteral">              Convergence is defined based on a termination criterion, such</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="stringliteral">              as absolute or relative error. If the iterations terminated due</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="stringliteral">              to reaching the maximum number of samples, this value is `False`.</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="stringliteral">            * ``min_num_samples``: `int`, the minimum number of Monte-Carlo</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="stringliteral">              iterations.</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="stringliteral">            * ``max_num_samples``: `int`, the maximum number of Monte-Carlo</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="stringliteral">              iterations.</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="stringliteral">            * ``num_outliers``: `int`, number of outliers found during search</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="stringliteral">              for outliers among the array of output.</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="stringliteral">            * ``num_samples_used``: `int`, number of Monte-Carlo samples used</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="stringliteral">              to produce the output. This is the total number of iterations</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="stringliteral">              minus the number of outliers.</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="stringliteral">            * ``samples``: `array` [`float`], an array of the size</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="stringliteral">              `max_num_samples`. The first few entries (`num_samples_used`) of</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="stringliteral">              this array are the output results of the Monte-Carlo sampling.</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="stringliteral">              The average of these samples is the final result. The rest of</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="stringliteral">              this array is `nan`.</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="stringliteral">            * ``samples_mean``: `float`, mean of the `samples` array, excluding</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="stringliteral">              the `nan` values.</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="stringliteral">            * ``samples_processed_order``: `array` [`int`], in parallel</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="stringliteral">              processing, samples are processed in non-sequential order. This</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="stringliteral">              array, which has the same size as `samples`, keeps track of the</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="stringliteral">              order in which each sample is processed.</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="stringliteral">        * ``error``:</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="stringliteral">            * ``absolute_error``: `float`, the absolute error of the</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="stringliteral">              convergence of samples.</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="stringliteral">            * ``confidence_level``: `float`, the confidence level used to</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="stringliteral">              calculate the error from standard deviation of samples.</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="stringliteral">            * ``error_atol``: `float`, the tolerance of absolute error of the</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="stringliteral">              convergence of samples.</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="stringliteral">            * ``error_rtol``: `float`, the tolerance of relative error of the</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="stringliteral">              convergence of samples.</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="stringliteral">            * ``outlier_significance_level``: `float`, the significance level</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="stringliteral">              used to determine the outliers in samples.</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="stringliteral">            * ``relative_error``: `float`, the relative error of the</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="stringliteral">              convergence of samples.</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="stringliteral">        * ``device``:</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="stringliteral">            * ``num_cpu_threads``: `int`, number of CPU threads used in shared</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="stringliteral">              memory parallel processing.</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="stringliteral">            * ``num_gpu_devices``: `int`, number of GPU devices used in the</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="stringliteral">              multi-GPU (GPU farm) computation.</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="stringliteral">            * ``num_gpu_multiprocessors``: `int`, number of GPU</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="stringliteral">              multi-processors.</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="stringliteral">            * ``num_gpu_threads_per_multiprocessor``: `int`, number of GPU</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="stringliteral">              threads on each GPU multi-processor.</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="stringliteral">        * ``time``:</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="stringliteral">            * ``tot_wall_time``: `float`, total elapsed time of computation.</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="stringliteral">            * ``alg_wall_time``: `float`, elapsed time of computation during</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="stringliteral">              only the algorithm execution.</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="stringliteral">            * ``cpu_proc_time``: `float`, the CPU processing time of</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="stringliteral">              computation.</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="stringliteral">        * ``solver``:</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="stringliteral">            * ``version``: `str`, version of imate.</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="stringliteral">            * ``method``: &#39;slq&#39;.</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="stringliteral">            * ``lanczos_degree``: `bool`, Lanczos degree.</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="stringliteral">            * ``lanczos_tol``: `float`, Lanczos tolerance.</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="stringliteral">            * ``orthogonalize``: `int`, orthogonalization flag.</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="stringliteral">    Raises</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="stringliteral">    ------</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="stringliteral">    ImportError</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="stringliteral">        If the package has not been compiled with GPU support, but ``gpu`` is</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="stringliteral">        set to `True`. To resolve the issue, set ``gpu`` to `False` to be able</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="stringliteral">        to use the existing installation. Alternatively,  export the</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="stringliteral">        environment variable ``USE_CUDA=1`` and recompile the source code of</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="stringliteral">        the package.</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="stringliteral">    See Also</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="stringliteral">    --------</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="stringliteral">    imate.logdet</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="stringliteral">    imate.traceinv</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="stringliteral">    imate.schatten</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="stringliteral">    Notes</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="stringliteral">    -----</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="stringliteral">    **Computational Complexity:**</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="stringliteral">    This method uses stochastic Lanczos quadrature (SLQ), which is a randomized</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="stringliteral">    algorithm. The computational complexity of this method is</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="stringliteral">    .. math::</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="stringliteral">        \\mathcal{O}((\\rho n^2 + n l) s l),</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="stringliteral">    where :math:`n` is the matrix size, :math:`\\rho` is the density of</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="stringliteral">    sparse matrix (for dense matrix, :math:`\\rho=1`), :math:`l` is the</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="stringliteral">    Lanczos degree (set with ``lanczos_degree``), and :math:`s` is the number</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="stringliteral">    of samples (set with ``min_num_samples`` and ``max_num_samples``).</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="stringliteral">    This method can be used on very large matrices (:math:`n &gt; 2^{12}`). The</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="stringliteral">    solution is an approximation.</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="stringliteral">    **Input Matrix:**</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="stringliteral">    The input `A` can be either of:</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="stringliteral">    * A matrix, such as `numpy.ndarray`, or `scipy.sparse`.</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="stringliteral">    * A linear operator representing a matrix using :class:`imate.Matrix`.</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="stringliteral">    * A linear operator representing a one-parameter family of an affine matrix</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="stringliteral">      function :math:`t \\mapsto \\mathbf{A} + t\\mathbf{B}` using</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="stringliteral">      :class:`imate.AffineMatrixFunction`.</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="stringliteral">    **Output:**</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="stringliteral">    The output is a scalar. However, if `A` is the linear operator</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="stringliteral">    :math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{B}` where :math:`t` is</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="stringliteral">    given as the tuple :math:`t = (t_1, \\dots, t_q)`, then the output of this</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="stringliteral">    function is an array of size :math:`q` corresponding to the</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="stringliteral">    trace of each :math:`\\mathbf{A}(t_i)`.</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="stringliteral">    .. note::</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="stringliteral">        When `A` represents</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="stringliteral">        :math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{I}`, where</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="stringliteral">        :math:`\\mathbf{I}` is the identity matrix, and :math:`t` is given by</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="stringliteral">        a tuple :math:`t = (t_1, \\dots, t_q)`, the computational cost of an</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="stringliteral">        array output of size `q` is the same as computing for a single</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="stringliteral">        :math:`t_i`. Namely, the trace of only :math:`\\mathbf{A}(t_1)` is</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="stringliteral">        computed, and the trace of the rest of :math:`i=2, \\dots, q` are</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="stringliteral">        obtained from the result of :math:`t_1` immediately.</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="stringliteral">    **Algorithm:**</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="stringliteral">    If ``gram`` is `False`, the Lanczos tri-diagonalization method is</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="stringliteral">    used. This method requires only matrix-vector multiplication. If</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="stringliteral">    ``gram`` is `True`, the Golub-Kahn bi-diagonalization method is used. This</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="stringliteral">    method requires both matrix-vector multiplication and transposed-matrix</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="stringliteral">    vector multiplications.</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="stringliteral">    **Convergence criterion:**</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="stringliteral">    Let :math:`n_{\\min}` and :math:`n_{\\max}` be the minimum and maximum</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="stringliteral">    number of iterations respectively defined by ``min_num_samples`` and</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="stringliteral">    ``max_num_samples``. The iterations terminate at</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="stringliteral">    :math:`n_{\\min} \\leq i \\leq n_{\\max}` where :math:`i` is the</span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="stringliteral">    iteration counter. The iterations stop earlier at :math:`i &lt; n_{\\max}` if</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="stringliteral">    the convergence error of the mean of the samples is satisfied, as follows.</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="stringliteral">    Suppose :math:`s(j)` and :math:`\\sigma(i)` are respectively the mean and</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="stringliteral">    standard deviation of samples after :math:`j` iterations. The error of</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="stringliteral">    convergence, :math:`e(j)`, is defined by</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="stringliteral">    .. math::</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="stringliteral">        e(j) = \\frac{\\sigma(j)}{\\sqrt{j}} Z</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="stringliteral">    where :math:`Z` is the Z-score defined by</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="stringliteral">    .. math::</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="stringliteral">        Z = \\sqrt{2} \\mathrm{erf}^{-1}(\\phi).</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="stringliteral">    In the above, :math:`\\phi` is the confidence level and set by</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="stringliteral">    ``confidence_level`` argument, and :math:`\\mathrm{erf}^{-1}` is the</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="stringliteral">    inverse error function. A confidence level of 95%, for instance, means that</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="stringliteral">    the Z-score is 1.96, which means the confidence interval is</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="stringliteral">    :math:`\\pm 1.96 \\sigma`.</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="stringliteral">    The termination criterion is</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="stringliteral">    .. math::</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="stringliteral">        e(j) &lt; \\epsilon_a + s(j) \\epsilon_r,</span></div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="stringliteral">    where :math:`\\epsilon_{a}` and :math:`\\epsilon_r` are the absolute and</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="stringliteral">    relative error tolerances respectively, and they are set by ``error_atol``</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="stringliteral">    and ``error_rtol``.</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="stringliteral">    **Convergence for the case of multiple parameters:**</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="stringliteral">    When `A` is a type of :class:`imate.AffineMatrixFunction` representing the</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="stringliteral">    affine matrix function :math:`\\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{B}`</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="stringliteral">    and if multiple parameters :math:`t_i`, :math:`i=1,\\dots, q` are passed to</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="stringliteral">    this function through ``parameters`` argument, the convergence criterion</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="stringliteral">    has to be satisfied for each of :math:`\\mathbf{A}(t_i)`. Specifically, the</span></div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="stringliteral">    iterations are terminated as follows:</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="stringliteral">    * If :math:`\\mathbf{B}` is the identity matrix, iterations for all</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="stringliteral">      :math:`\\mathbf{A}(t_i)` continue till the convergence criterion for</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="stringliteral">      *all* :math:`t_i` are satisfied. That is, even if :math:`t=t_i` is</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="stringliteral">      converged but :math:`t=t_j` has not converged yet, the iterations for</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="stringliteral">      :math:`t=t_i` will continue.</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="stringliteral">      :</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="stringliteral">    * If :math:`\\mathbf{B}` is not the identity matrix, the iterations for</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="stringliteral">      each of :math:`t_i` are independent. That is, if :math:`t=t_i` converges,</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="stringliteral">      the iterations for that parameter will stop regardless of the convergence</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="stringliteral">      status of other parameters.</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="stringliteral">    **Plotting:**</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="stringliteral">    If ``plot`` is set to `True`, it plots the convergence of samples and their</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="stringliteral">    relative error.</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="stringliteral">    * If no graphical backend exists (such as running the code on a remote</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="stringliteral">      server or manually disabling the X11 backend), the plot will not be</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="stringliteral">      shown, rather, it will be saved as an ``svg`` file in the current</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="stringliteral">      directory.</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="stringliteral">    * If the executable ``latex`` is available on ``PATH``, the plot is</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="stringliteral">      rendered using :math:`\\rm\\LaTeX` and it may take slightly longer to</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="stringliteral">      produce the plot.</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="stringliteral">    * If :math:`\\rm\\LaTeX` is not installed, it uses any available San-Serif</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="stringliteral">      font to render the plot.</span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="stringliteral">    To manually disable interactive plot display and save the plot as</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="stringliteral">    ``svg`` instead, add the following at the very beginning of your code</span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="stringliteral">    before importing :mod:`imate`:</span></div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; import os</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; os.environ[&#39;IMATE_NO_DISPLAY&#39;] = &#39;True&#39;</span></div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="stringliteral">    References</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="stringliteral">    ----------</span></div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="stringliteral">    * `Ubaru, S., Chen, J., and Saad, Y. (2017)</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="stringliteral">      &lt;https://www-users.cs.umn.edu/~saad/PDF/ys-2016-04.pdf&gt;`_,</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="stringliteral">      Fast Estimation of :math:`\\mathrm{tr}(F(A))` Via Stochastic Lanczos</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="stringliteral">      Quadrature, SIAM J. Matrix Anal. Appl., 38(4), 1075-1099.</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="stringliteral">    Examples</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="stringliteral">    --------</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="stringliteral">    **Symmetric Input Matrix:**</span></div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="stringliteral">    The `slq` method requires the input matrix of :func:`imate.trace` function</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="stringliteral">    to be symmetric when ``gram`` is `False`. For the first example, generate a</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="stringliteral">    symmetric sample matrix using :func:`imate.toeplitz` function as follows:</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Import packages</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; from imate import toeplitz</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Generate a symmetric matrix by setting gram=True.</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="stringliteral">    In the above, by passing ``gram=True`` to :func:`imate.toeplitz` function,</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="stringliteral">    the Gramian of the Toeplitz matrix is returned, which is symmetric. Compute</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="stringliteral">    the trace of :math:`\\mathbf{A}^{2.5}`:</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Import packages</span></div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; from imate import trace</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Compute trace</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; trace(A, gram=False, p=2.5, method=&#39;slq&#39;)</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="stringliteral">        3177.56</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="stringliteral">    .. note:</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="stringliteral">        Since `slq` is a stochastic method, the above result slightly</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="stringliteral">        differs after each run.</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="stringliteral">    **Gramian Matrix:**</span></div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="stringliteral">    </span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="stringliteral">    Passing ``gram=True`` to :func:`imate.trace` function uses the Gramian</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="stringliteral">    of the input matrix. In this case, the input matrix can be non-symmetric.</span></div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="stringliteral">    In the next example, generate a non-symmetric matrix, :math:`\\mathbf{B}`,</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="stringliteral">    then compute the trace of</span></div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="stringliteral">    :math:`(\\mathbf{B}^{\\intercal} \\mathbf{B})^{2.5}`.</span></div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Generate a non-symmetric matrix by setting gram=False</span></div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; B = toeplitz(2, 1, size=100, gram=False)</span></div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Compute the trace of Gramian by passing gram=True</span></div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; trace(B, gram=True, p=2.5, method=&#39;slq&#39;)</span></div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="stringliteral">        3180.60</span></div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="stringliteral">    Note that the result of the two examples in the above are the similar since</span></div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="stringliteral">    the input matrix :math:`\\mathbf{A}` of the first example is the Gramian of</span></div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="stringliteral">    the input matrix :math:`\\mathbf{B}` in the second example, that is</span></div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="stringliteral">    :math:`\\mathbf{A} = \\mathbf{B}^{\\intercal} \\mathbf{B}`. Since the</span></div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="stringliteral">    second example uses the Gramian of the input matrix, it computes the same</span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="stringliteral">    quantity as the first example.</span></div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="stringliteral">    **Verbose output:**</span></div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="stringliteral">    By setting ``verbose`` to `True`, useful info about the process is</span></div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="stringliteral">    printed.</span></div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="stringliteral">    .. literalinclude:: ../_static/data/imate.trace.slq-verbose-1.txt</span></div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="stringliteral">        :language: python</span></div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="stringliteral">    **Output information:**</span></div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="stringliteral">    Print information about the inner computation:</span></div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; tr, info = trace(A, method=&#39;slq&#39;, return_info=True)</span></div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; print(tr)</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="stringliteral">        506.04</span></div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Print dictionary neatly using pprint</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; from pprint import pprint</span></div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; pprint(info)</span></div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="stringliteral">        {</span></div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="stringliteral">            &#39;convergence&#39;: {</span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="stringliteral">                &#39;all_converged&#39;: False,</span></div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="stringliteral">                &#39;converged&#39;: False,</span></div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="stringliteral">                &#39;max_num_samples&#39;: 50,</span></div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="stringliteral">                &#39;min_num_samples&#39;: 10,</span></div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="stringliteral">                &#39;num_outliers&#39;: 0,</span></div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="stringliteral">                &#39;num_samples_used&#39;: 50,</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="stringliteral">                &#39;samples&#39;: array([527., ..., 495.]),</span></div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="stringliteral">                &#39;samples_mean&#39;: 506.04,</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="stringliteral">                &#39;samples_processed_order&#39;: array([ 2, ..., 49])</span></div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="stringliteral">            },</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="stringliteral">            &#39;device&#39;: {</span></div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="stringliteral">                &#39;num_cpu_threads&#39;: 8,</span></div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="stringliteral">                &#39;num_gpu_devices&#39;: 0,</span></div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="stringliteral">                &#39;num_gpu_multiprocessors&#39;: 0,</span></div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="stringliteral">                &#39;num_gpu_threads_per_multiprocessor&#39;: 0</span></div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="stringliteral">            },</span></div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="stringliteral">            &#39;error&#39;: {</span></div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="stringliteral">                &#39;absolute_error&#39;: 10.380366588608128,</span></div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="stringliteral">               &#39;confidence_level&#39;: 0.95,</span></div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="stringliteral">               &#39;error_atol&#39;: 0.0,</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="stringliteral">               &#39;error_rtol&#39;: 0.01,</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="stringliteral">               &#39;outlier_significance_level&#39;: 0.001,</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="stringliteral">               &#39;relative_error&#39;: 0.02051293689947065</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="stringliteral">            },</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="stringliteral">            &#39;matrix&#39;: {</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="stringliteral">                &#39;data_type&#39;: b&#39;float64&#39;,</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="stringliteral">                &#39;density&#39;: 0.0298,</span></div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="stringliteral">                &#39;exponent&#39;: 1.0,</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="stringliteral">                &#39;gram&#39;: False,</span></div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="stringliteral">                &#39;nnz&#39;: 298,</span></div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="stringliteral">                &#39;num_inquiries&#39;: 1,</span></div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="stringliteral">                &#39;num_operator_parameters&#39;: 0,</span></div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="stringliteral">                &#39;parameters&#39;: None,</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="stringliteral">                &#39;size&#39;: 100,</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="stringliteral">                &#39;sparse&#39;: True</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="stringliteral">            },</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="stringliteral">            &#39;solver&#39;: {</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="stringliteral">                &#39;lanczos_degree&#39;: 20,</span></div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="stringliteral">                &#39;lanczos_tol&#39;: 2.220446049250313e-16,</span></div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="stringliteral">                &#39;method&#39;: &#39;slq&#39;,</span></div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="stringliteral">                &#39;orthogonalize&#39;: 0,</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="stringliteral">                &#39;version&#39;: &#39;0.15.0&#39;</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="stringliteral">            },</span></div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="stringliteral">            &#39;time&#39;: {</span></div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="stringliteral">                &#39;alg_wall_time&#39;: 0.003865957260131836,</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="stringliteral">              &#39;cpu_proc_time&#39;: 0.021690301999999884,</span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="stringliteral">              &#39;tot_wall_time&#39;: 0.0040010069496929646</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="stringliteral">            }</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="stringliteral">    **Large matrix:**</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="stringliteral">    Compute the trace of :math:`\\mathbf{A}` for a very large sparse</span></div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="stringliteral">    matrix using at least `100` samples. Note that the matrix</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="stringliteral">    :math:`\\mathbf{A}` should be symmetric.</span></div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="stringliteral">        :emphasize-lines: 7, 8</span></div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Generate a matrix of size one million. Set gram=True to create</span></div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # a symmetric matrix needed for slq method.</span></div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000, gram=True)</span></div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Approximate trace using stochastic Lanczos quadrature</span></div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # with at least 100 Monte-Carlo sampling</span></div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; tr, info = trace(A, method=&#39;slq&#39;, min_num_samples=100,</span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="stringliteral">        ...                  max_num_samples=200, return_info=True)</span></div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; print(tr)</span></div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="stringliteral">        4999763.32</span></div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Find the time it took to compute the above</span></div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; print(info[&#39;time&#39;])</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="stringliteral">        {</span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="stringliteral">            &#39;tot_wall_time&#39;: 16.101079436950386,</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="stringliteral">            &#39;alg_wall_time&#39;: 16.08251190185547,</span></div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="stringliteral">            &#39;cpu_proc_time&#39;: 117.259937983</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="stringliteral">    Compare the result of the above approximation with the exact solution of</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="stringliteral">    the trace using the analytic relation for Toeplitz matrix. See</span></div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="stringliteral">    :func:`imate.sample_matrices.toeplitz_trace` for details.</span></div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; from imate.sample_matrices import toeplitz_trace</span></div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; toeplitz_trace(2, 1, size=1000000, gram=True)</span></div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="stringliteral">        4999999</span></div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="stringliteral">    It can be seen that the error of approximation is :math:`0.008 \\%`. This</span></div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="stringliteral">    accuracy is remarkable considering that the computation on such a large</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="stringliteral">    matrix took only 16 seconds. Computing the trace of such a large matrix</span></div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="stringliteral">    using any of the exact methods (such as ``exact`` or ``eigenvalue``) is</span></div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="stringliteral">    infeasible.</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="stringliteral">    **Plotting:**</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="stringliteral">    By setting ``plot`` to `True`, plots of samples during Monte-Carlo</span></div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="stringliteral">    iterations and the convergence of their mean are generated.</span></div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; A = toeplitz(2, 1, size=1000000, gram=True)</span></div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; trace(A, method=&#39;slq&#39;, min_num_samples=20, max_num_samples=80,</span></div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;<span class="stringliteral">        ...       error_rtol=2e-4, confidence_level=0.95,</span></div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;<span class="stringliteral">        ...       outlier_significance_level=0.001, plot=True)</span></div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="stringliteral">    .. image:: ../_static/images/plots/trace_slq_convergence_1.png</span></div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="stringliteral">        :align: center</span></div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="stringliteral">        :class: custom-dark</span></div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="stringliteral">    In the left plot, the samples are shown in circles and the cumulative mean</span></div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="stringliteral">    of the samples is shown by a solid black curve. The shaded area corresponds</span></div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="stringliteral">    to the 95% confidence interval :math:`\\pm 1.96 \\sigma`, which is set by</span></div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="stringliteral">    ``confidence_level=0.95``. The samples outside the interval of 99.9% are</span></div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="stringliteral">    considered outliers, which is set by the significance level</span></div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="stringliteral">    ``outlier_significance_level=0.001``.</span></div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="stringliteral">    In the right plot, the darker shaded area in the interval :math:`[0, 20]`</span></div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="stringliteral">    shows the minimum number of samples and is set by ``min_num_samples=20``.</span></div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;<span class="stringliteral">    The iterations do not stop till the minimum number of iterations is passed.</span></div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="stringliteral">    We can observe that sampling is terminated after 55 iterations where the</span></div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="stringliteral">    relative error of samples reaches 0.02% since we set ``error_rtol=2e-4``.</span></div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="stringliteral">    The lighter shaded area in the interval :math:`[56, 80]` corresponds to the</span></div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="stringliteral">    iterations that were not performed to reach the specified maximum</span></div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="stringliteral">    iterations by ``max_num_samples=80``.</span></div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="stringliteral">    **Matrix operator:**</span></div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="stringliteral">    Use an object of :class:`imate.Matrix` class as an alternative method to</span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="stringliteral">    pass the matrix `A` to the `trace` function.</span></div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="stringliteral">        :emphasize-lines: 8</span></div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Import matrix operator</span></div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; from imate import toeplitz, trace, Matrix</span></div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)</span></div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; A = toeplitz(2, 1, size=100, gram=True)</span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Create a matrix operator object from matrix A</span></div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; Aop = Matrix(A)</span></div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Compute the trace of Aop</span></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; trace(Aop, method=&#39;slq&#39;)</span></div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;<span class="stringliteral">        493.08</span></div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="stringliteral">    An advantage of passing `Aop` (instead of `A`) to the `trace` function</span></div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="stringliteral">    will be clear when using GPU.</span></div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="stringliteral">    **Computation on GPU:**</span></div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="stringliteral">    The argument ``gpu=True`` performs the computations on GPU. The following</span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="stringliteral">    example uses the object `Aop` created earlier.</span></div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Compute thet race of Aop</span></div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; trace(Aop, method=&#39;slq&#39;, gpu=True)</span></div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;<span class="stringliteral">        493.08</span></div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="stringliteral">    The above function call triggers the object `Aop` to automatically load the</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="stringliteral">    matrix data on the GPU.</span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="stringliteral">    One could have used `A` instead of `Aop` in the above. However, an</span></div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="stringliteral">    advantage of using `Aop` (instead of the matrix `A` directly) is that by</span></div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="stringliteral">    calling the above `trace` function (or another function) again on this</span></div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="stringliteral">    matrix, the data of this matrix does not have to be re-allocated on the GPU</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="stringliteral">    device again. To highlight this point, call the above function again, but</span></div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="stringliteral">    this time, set ``gram`` to `True` to compute something different.</span></div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Compute the trace of Aop</span></div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; trace(Aop, method=&#39;slq&#39;, gpu=True, gram=True)</span></div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="stringliteral">        493.08</span></div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="stringliteral">    In the above example, no data is needed to be transferred from CPU host to</span></div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="stringliteral">    GPU device again. However, if `A` was used instead of `Aop`, the data would</span></div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="stringliteral">    have been transferred from CPU to GPU again for the second time. The `Aop`</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="stringliteral">    object holds the data on GPU for later use as long as this object does no</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="stringliteral">    go out of the scope of the python environment. Once the variable `Aop` goes</span></div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;<span class="stringliteral">    out of scope, the matrix data on all the GPU devices will be cleaned</span></div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="stringliteral">    automatically.</span></div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;<span class="stringliteral">    **Affine matrix operator:**</span></div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="stringliteral">    Use an object of :class:`imate.AffineMatrixFunction` to create the linear</span></div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="stringliteral">    operator</span></div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;<span class="stringliteral">    .. math::</span></div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="stringliteral">        \\mathbf{A}(t) = \\mathbf{A} + t \\mathbf{I}.</span></div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;<span class="stringliteral">    The object :math:`\\mathbf{A}(t)` can be passed to `trace` function with</span></div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;<span class="stringliteral">    multiple values for the parameter :math:`t` to compute their trace  all at</span></div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="stringliteral">    once, as follows.</span></div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="stringliteral">    .. code-block:: python</span></div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;<span class="stringliteral">        :emphasize-lines: 8</span></div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Import affine matrix function</span></div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; from imate import toeplitz, trace, AffineMatrixFunction</span></div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Generate a sample matrix (a toeplitz matrix)</span></div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; A = toeplitz(2, 1, size=10000, gram=True)</span></div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Create a matrix operator object from matrix A</span></div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; Aop = AffineMatrixFunction(A)</span></div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # A list of parameters t to pass to Aop</span></div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; t = [-1.0, 0.5, 1.0]</span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; # Compute the trace of Aop for all parameters t</span></div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="stringliteral">        &gt;&gt;&gt; trace(Aop, method=&#39;slq&#39;, parameters=t, min_num_samples=50,</span></div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="stringliteral">        ...       max_num_samples=150, error_rtol=2e-3, confidence_level=0.95,</span></div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="stringliteral">        ...       outlier_significance_level=0.001, plot=True, verbose=True)</span></div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;<span class="stringliteral">        [39988.03448276 54988.03448276 59988.03448276]</span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="stringliteral">    The output of the verbose argument is shown below. In the results section</span></div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="stringliteral">    of the table below, each row `i` under the `inquiry` column corresponds to</span></div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;<span class="stringliteral">    each element of the parameters ``t = [-1, 0.5, 1]`` that was specified by</span></div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;<span class="stringliteral">    ``parameters`` argument.</span></div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;<span class="stringliteral">    .. literalinclude:: ../_static/data/imate.trace.slq-verbose-2.txt</span></div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="stringliteral">        :language: python</span></div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;<span class="stringliteral">    The output of the plot is shown below. Each colored curve corresponds to</span></div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;<span class="stringliteral">    a parameter in ``t = [-1, 0.5, 1]``.</span></div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;<span class="stringliteral"></span> </div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="stringliteral">    .. image:: ../_static/images/plots/trace_slq_convergence_2.png</span></div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;<span class="stringliteral">        :align: center</span></div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="stringliteral">        :width: 80%</span></div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;<span class="stringliteral">        :class: custom-dark</span></div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;<span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160; </div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    <span class="comment"># Define identity  matrix function</span></div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    cdef Function* matrix_function = new <a class="code" href="classIdentity.html">Identity</a>()</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    py_matrix_function = pyFunction()</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;    py_matrix_function.set_function(matrix_function)</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160; </div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    trace, info = trace_estimator(</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;        A,</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;        parameters,</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;        py_matrix_function,</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;        gram,</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;        p,</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;        min_num_samples,</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;        max_num_samples,</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;        error_atol,</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;        error_rtol,</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;        confidence_level,</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;        outlier_significance_level,</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        lanczos_degree,</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;        lanczos_tol,</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        orthogonalize,</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;        num_threads,</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;        num_gpu_devices,</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;        verbose,</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        plot,</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;        gpu)</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160; </div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;    del matrix_function</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160; </div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    <span class="keywordflow">if</span> return_info:</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;        <span class="keywordflow">return</span> trace, info</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;    <span class="keywordflow">else</span>:</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;        <span class="keywordflow">return</span> trace</div>
<div class="ttc" id="aclassIdentity_html"><div class="ttname"><a href="classIdentity.html">Identity</a></div><div class="ttdoc">Defines the function .</div><div class="ttdef"><b>Definition:</b> <a href="functions_8h_source.html#l00065">functions.h:66</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>imate</b></li><li class="navelem"><b>trace</b></li><li class="navelem"><a class="el" href="namespaceimate_1_1trace_1_1__slq__method.html">_slq_method</a></li>
    <li class="footer">Generated on Thu Sep 1 2022 16:18:34 for imate by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
