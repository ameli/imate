\documentclass{article}
\usepackage{ifthen}
\usepackage{epsfig}
\usepackage[utf8]{inputenc}
% Packages requested by user
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{newunicodechar}
  \newunicodechar{⁻}{${}^{-}$}% Superscript minus
  \newunicodechar{²}{${}^{2}$}% Superscript two
  \newunicodechar{³}{${}^{3}$}% Superscript three

\pagestyle{empty}
\begin{document}
$ \boldsymbol{c} = \mathbf{A} \boldsymbol{b} $
\pagebreak

$ \mathbf{A} $
\pagebreak

$ \boldsymbol{c} = \boldsymbol{c} + \alpha \mathbf{A} \boldsymbol{b} $
\pagebreak

$\boldsymbol{c} = \mathbf{A}^{\intercal} \boldsymbol{b} $
\pagebreak

$ \mathbf{A}^{\intercal} $
\pagebreak

$ \boldsymbol{c} = \boldsymbol{c} + \alpha \mathbf{A}^{\intercal} \boldsymbol{b} $
\pagebreak

$ \mathbf{A}\ f$ is compressed sparse row (CSR) matrix and $
\pagebreak

$ is a dense vector. The output $
\pagebreak

$ is a dense vector. \details The reduction variable (here, \c sum ) is of the type \c{long double}. This is becase when \c DataType is \c float, the summation loses the precision, especially when the vector size is large. It seems that using \c{long double} is slightly faster than using \c double. The advantage of using a type with larger bits for the reduction variable is only sensible if the compiler is optimized with \c -O2 or \c -O3 flags. \param[in] A_data CSR format data array of the sparse matrix. The length of this array is the nnz of the matrix. \param[in] A_column_indices CSR format column indices of the sparse matrix. The length of this array is the nnz of the matrix. \param[in] A_index_pointer CSR format index pointer. The length of this array is one plus the number of rows of the matrix. Also, the first element of this array is \c 0, and the last element is the nnz of the matrix. \param[in] b Column vector with same size of the number of columns of \c A. \param[in] num_rows Number of rows of the matrix \c A. This is essentially the size of \c A_index_pointer array minus one. \param[out] c Output column vector with the same size as \c b. This array is written in-place. template <typename DataType> void cMatrixOperations<DataType>::csr_matvec( const DataType* A_data, const LongIndexType* A_column_indices, const LongIndexType* A_index_pointer, const DataType* b, const LongIndexType num_rows, DataType* c) { LongIndexType index_pointer; LongIndexType row; LongIndexType column; long double sum; for (row=0; row < num_rows; ++row) { sum = 0.0; for (index_pointer=A_index_pointer[row]; index_pointer < A_index_pointer[row+1]; ++index_pointer) { column = A_column_indices[index_pointer]; sum += A_data[index_pointer] * b[column]; } c[row] = static_cast<DataType>(sum); } } // =============== // csr matvec plus // =============== \brief Computes $
\pagebreak

$ where $
\pagebreak

$ \boldsymbol{b} $
\pagebreak

$ \boldsymbol{c} $
\pagebreak

$\boldsymbol{c} =\mathbf{A}^{\intercal} \boldsymbol{b}$
\pagebreak

$ \boldsymbol{c} = \boldsymbol{c} + \alpha \mathbf{A}^{\intercal} \boldsymbol{b}$
\pagebreak

$\boldsymbol{c} =\mathbf{A}^{\intercal} \boldsymbol{b} $
\pagebreak

$ \boldsymbol{c} = \mathbf{A}^{\intercal} \boldsymbol{b} $
\pagebreak

\[ \boldsymbol{b} = \boldsymbol{b} - c \boldsymbol{a}, \]
\pagebreak

$ \boldsymbol{a} $
\pagebreak

$ c $
\pagebreak

$ \mathbf{I} $
\pagebreak

\[ \mathbf{A}(t) = \mathbf{A} + t \mathbf{I} \]
\pagebreak

$ \lambda $
\pagebreak

\[ \lambda(\mathbf{A}(t)) = \lambda(\mathbf{A}) + t. \]
\pagebreak

$ \lambda_{t_0} $
\pagebreak

$ t_0 $
\pagebreak

$ \lambda_{t} $
\pagebreak

$ t $
\pagebreak

$ \boldsymbol{c} = \boldsymbol{c} + \alpha * \boldsymbol{b} $
\pagebreak

$ \alpha $
\pagebreak

\[ \boldsymbol{c} = (\mathbf{A} + t \mathbf{B}) \boldsymbol{b}. \]
\pagebreak

$ \mathbf{B} $
\pagebreak

$ m \times n $
\pagebreak

\[ \boldsymbol{c} = (\mathbf{A} + t \mathbf{B})^{\intercal} \boldsymbol{b}. \]
\pagebreak

$ \alpha_j $
\pagebreak

$ \beta_j $
\pagebreak

\[ \mathbf{A} = \mathbf{V} \boldsymbol{\Lambda} \mathbf{V}^{\intercal} \]
\pagebreak

$ \mathbf{V} $
\pagebreak

$ \boldsymbol{\Lambda} $
\pagebreak

\[ \mathbf{A} = \mathbf{U} \boldsymbol{\Sigma} \mathbf{V}^{\intercal} \]
\pagebreak

$ \mathbf{U} $
\pagebreak

$ \boldsymbol{\Sigma} $
\pagebreak

\end{document}
