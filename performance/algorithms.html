


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Comparison of Randomized Algorithms &#8212; imate Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "auto";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom-pydata.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/toggleprompt.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/js/custom-pydata.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/custom-pydata.css"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4JHJ15SKEY"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-4JHJ15SKEY');
    </script>

    <script defer data-domain="docs.scipy.org" src="https://views.scientific-python.org/js/script.js"></script>

    <!-- My custom JS -->
    <script type="text/javascript" src="../_static/js/custom-pydata.js"></script>

    <!-- Syntax highlighting for BibTex code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-solarizedlight.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs-bibtex@2.0.1/prism-bibtex.min.js"></script>

    
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">

  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="auto">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../contents.html">
  
  
  
  
    <img src="../_static/images/icons/logo-imate-light.png" class="logo__image only-light" alt="Logo image">
    <img src="../_static/images/icons/logo-imate-dark.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorials/install.html">
  1. Install
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorials/docker.html">
  2. Docker
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorials/gpu.html">
  3. GPU
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../api.html">
  API Reference
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/ameli/imate" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pypi.org/project/imate/" rel="noopener" target="_blank" title="PyPI"><span><i class="fab fa-python"></i></span>
            <label class="sr-only">PyPI</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://anaconda.org/s-ameli/imate" rel="noopener" target="_blank" title="Anaconda Cloud"><span><i class="fa fa-circle-notch"></i></span>
            <label class="sr-only">Anaconda Cloud</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://hub.docker.com/r/sameli/imate" rel="noopener" target="_blank" title="Docker Hub"><span><i class="fab fa-docker"></i></span>
            <label class="sr-only">Docker Hub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://mybinder.org/v2/gh/ameli/imate/HEAD?filepath=notebooks%2FInterpolateTraceOfInverse.ipynb" rel="noopener" target="_blank" title="Lanuch Jupyter on Binder"><span><i class="fa fa-chart-line"></i></span>
            <label class="sr-only">Lanuch Jupyter on Binder</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="gpu.html">
   Performance on GPU Farm
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Comparison of Randomized Algorithms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="openblas.html">
   Comparison With and Without OpenBLAS
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="interpolation.html">
   Interpolation of Affine Matrix Functions
  </a>
 </li>
</ul>

    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#test-description">
   Test Description
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algorithms">
     Algorithms
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#arithmetic-types">
     Arithmetic Types
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#test-on-simple-matrices">
   Test on Simple Matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#elapsed-time-of-computing-log-determinant">
     Elapsed Time of Computing Log-Determinant
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#accuracy-of-computing-log-determinant">
     Accuracy of Computing Log-Determinant
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#elapsed-time-of-computing-trace-of-inverse">
     Elapsed Time of Computing Trace of Inverse
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#accuracy-of-computing-trace-of-inverse">
     Accuracy of Computing Trace of Inverse
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#test-on-practical-matrices">
   Test on Practical Matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#process-time-of-computing-log-determinant">
     Process Time of Computing Log-Determinant
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     Accuracy of Computing Log-Determinant
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#varying-algorithm-parameters">
   Varying Algorithm Parameters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     Process Time of Computing Log-Determinant
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     Accuracy of Computing Log-Determinant
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#process-time-of-computing-trace-of-inverse">
     Process Time of Computing Trace of Inverse
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     Accuracy of Computing Trace of Inverse
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#how-to-reproduce-results">
   How to Reproduce Results
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#prepare-matrix-data">
     Prepare Matrix Data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#perform-numerical-test">
     Perform Numerical Test
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#run-locally">
       Run Locally
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#submit-to-cluster-with-slurm">
       Submit to Cluster with SLURM
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#plot-results">
     Plot Results
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      

<div class="tocsection editthispage">
    <a href="https://github.com/ameli/imate/edit/main/docs/source/performance/algorithms.rst">
        <i class="fas fa-pencil-alt"></i> Edit this page
    </a>
</div>

    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="comparison-of-randomized-algorithms">
<span id="perf-algorithms"></span><h1>Comparison of Randomized Algorithms<a class="headerlink" href="#comparison-of-randomized-algorithms" title="Permalink to this heading">#</a></h1>
<p><span class="synco">imate</span> implements various deterministic and randomized algorithms on dense and sparse matrices. The goal of the following numerical experiments is to compare the performance, scalability, and accuracy of these algorithms.</p>
<section id="test-description">
<h2>Test Description<a class="headerlink" href="#test-description" title="Permalink to this heading">#</a></h2>
<p>The following numerical experiments aims to estimate</p>
<div class="math notranslate nohighlight" id="equation-logdet3">
<span class="eqno">(1)<a class="headerlink" href="#equation-logdet3" title="Permalink to this equation">#</a></span>\[\log \det (\mathbf{A}),\]</div>
<p>and</p>
<div class="math notranslate nohighlight" id="equation-traceinv3">
<span class="eqno">(2)<a class="headerlink" href="#equation-traceinv3" title="Permalink to this equation">#</a></span>\[\mathrm{trace}(\mathbf{A}^{-1}),\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is symmetric and positive-definite. The above quantities are computationally expensive expressions that frequently appears in the likelihood functions and their Jacobian and Hessian.</p>
<section id="algorithms">
<h3>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this heading">#</a></h3>
<p>The following Algorithms were tested on Intel® Xeon CPU E5-2670 v3  with 24 threads.</p>
<dl class="glossary">
<dt id="term-Cholesky-Decomposition">Cholesky Decomposition<a class="headerlink" href="#term-Cholesky-Decomposition" title="Permalink to this term">#</a></dt><dd><p>This method is implemented by the following functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../api/imate.logdet.cholesky.html#imate-logdet-cholesky"><span class="std std-ref">imate.logdet(method=’cholesky’)</span></a> to compute <a class="reference internal" href="#equation-logdet3">(1)</a>.</p></li>
<li><p><a class="reference internal" href="../api/imate.traceinv.cholesky.html#imate-traceinv-cholesky"><span class="std std-ref">imate.traceinv(method=’cholesky’)</span></a> to compute <a class="reference internal" href="#equation-traceinv3">(2)</a>.</p></li>
</ul>
<p>The complexity of computing <a class="reference internal" href="#equation-logdet3">(1)</a> for matrices obtained from 1D, 2D, and 3D grids are respectively <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span>, <span class="math notranslate nohighlight">\(\mathcal{O}(n^{\frac{3}{2}})\)</span>, and <span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the matrix size. The complexity of computing <a class="reference internal" href="#equation-traceinv3">(2)</a> for sparse matrices is <span class="math notranslate nohighlight">\(\mathcal{O}(\rho n^2)\)</span> where <span class="math notranslate nohighlight">\(\rho\)</span> is the sparse matrix density.</p>
</dd>
<dt id="term-Hutchinson-Algorithm">Hutchinson Algorithm<a class="headerlink" href="#term-Hutchinson-Algorithm" title="Permalink to this term">#</a></dt><dd><p>This method is only applied to <a class="reference internal" href="#equation-traceinv3">(2)</a> and implemented by <a class="reference internal" href="../api/imate.traceinv.hutchinson.html#imate-traceinv-hutchinson"><span class="std std-ref">imate.traceinv(method=’hutchinson’)</span></a> function. The complexity of this method is:</p>
<div class="math notranslate nohighlight" id="equation-comp-hutch">
<span class="eqno">(3)<a class="headerlink" href="#equation-comp-hutch" title="Permalink to this equation">#</a></span>\[\mathcal{O}(\mathrm{nnz}(\mathbf{A})s),\]</div>
<p>where <span class="math notranslate nohighlight">\(s\)</span> is the number of Monte-Carlo iterations in the algorithm and <span class="math notranslate nohighlight">\(\rho\)</span> is the sparse matrix density. In this experiment, <span class="math notranslate nohighlight">\(s = 80\)</span>.</p>
</dd>
<dt id="term-Stochastic-Lanczos-Quadrature-Algorithm">Stochastic Lanczos Quadrature Algorithm<a class="headerlink" href="#term-Stochastic-Lanczos-Quadrature-Algorithm" title="Permalink to this term">#</a></dt><dd><p>This method is implemented by:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../api/imate.logdet.cholesky.html#imate-logdet-cholesky"><span class="std std-ref">imate.logdet(method=’cholesky’)</span></a> to compute <a class="reference internal" href="#equation-logdet3">(1)</a>.</p></li>
<li><p><a class="reference internal" href="../api/imate.traceinv.cholesky.html#imate-traceinv-cholesky"><span class="std std-ref">imate.traceinv(method=’cholesky’)</span></a> to compute <a class="reference internal" href="#equation-traceinv3">(2)</a>.</p></li>
</ul>
<p>The complexity of this method is:</p>
<div class="math notranslate nohighlight" id="equation-comp-slq">
<span class="eqno">(4)<a class="headerlink" href="#equation-comp-slq" title="Permalink to this equation">#</a></span>\[\mathcal{O} \left( (\mathrm{nnz}(\mathbf{A}) l + n l^2) s \right),\]</div>
<p>where <span class="math notranslate nohighlight">\(l\)</span> is the number of Lanczos iterations, and <span class="math notranslate nohighlight">\(s\)</span> is the number of Monte-Carlo iterations.  The numerical experiment is performed with <span class="math notranslate nohighlight">\(l=80\)</span> and <span class="math notranslate nohighlight">\(s=200\)</span>.</p>
</dd>
</dl>
</section>
<section id="arithmetic-types">
<h3>Arithmetic Types<a class="headerlink" href="#arithmetic-types" title="Permalink to this heading">#</a></h3>
<p>The benchmark test also examines the performance and accuracy of <span class="synco">imate</span> on various arithmetic types of the matrix data. To this end, the matrices that are described below are re-cast into 32-bit, 64-bit, and 128-bit floating point types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Supporting 128-bit data types is one of the features of <span class="synco">imate</span>, which is often not available in numerical libraries, such as BLAS, OpenBLAS, Cholmod, etc.</p>
</div>
</section>
</section>
<section id="test-on-simple-matrices">
<span id="simple-mat"></span><h2>Test on Simple Matrices<a class="headerlink" href="#test-on-simple-matrices" title="Permalink to this heading">#</a></h2>
<p>The Gramian matrix <span class="math notranslate nohighlight">\(\mathbf{A} = \mathbf{B}^{\intercal} \mathbf{B}\)</span> is considered for the test where <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> is a sparse bi-diagonal Toeplitz matrix defined by</p>
<div class="math notranslate nohighlight">
\[\begin{split}B_{ij} =
\begin{cases}
    a, &amp; i = j, \\
    b, &amp; i+1 = j.
\end{cases}\end{split}\]</div>
<p>The above matrix can be generated by <a class="reference internal" href="../generated/imate.toeplitz.html#imate.toeplitz" title="imate.toeplitz"><code class="xref py py-func docutils literal notranslate"><span class="pre">imate.toeplitz()</span></code></a> function. In this experiment, <span class="math notranslate nohighlight">\(a = 2\)</span>, <span class="math notranslate nohighlight">\(b = 1\)</span>, and the matrix size is varied by powers of two, <span class="math notranslate nohighlight">\(n = 2^8, 2^9, \dots, 2^{14}\)</span>.</p>
<p>The Cholesky factor of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is <span class="math notranslate nohighlight">\(\mathbf{B}^{\intercal}\)</span>. Also, <span class="math notranslate nohighlight">\(\mathrm{nnz}(\mathbf{A}) = 3n\)</span>. An advantage of using the above matrix is that an analytic formula for <a class="reference internal" href="#equation-logdet3">(1)</a> and <a class="reference internal" href="#equation-traceinv3">(2)</a> is known. Namely,</p>
<div class="math notranslate nohighlight" id="equation-formula-logdet3">
<span class="eqno">(5)<a class="headerlink" href="#equation-formula-logdet3" title="Permalink to this equation">#</a></span>\[ \log \det \mathbf{A} = 2n \log_e a.\]</div>
<p>See <a class="reference internal" href="../generated/imate.sample_matrices.toeplitz_logdet.html#imate.sample_matrices.toeplitz_logdet" title="imate.sample_matrices.toeplitz_logdet"><code class="xref py py-func docutils literal notranslate"><span class="pre">imate.sample_matrices.toeplitz_logdet()</span></code></a> for details. Also, if <span class="math notranslate nohighlight">\(n \gg 1\)</span>, then</p>
<div class="math notranslate nohighlight" id="equation-formula-traceinv3">
<span class="eqno">(6)<a class="headerlink" href="#equation-formula-traceinv3" title="Permalink to this equation">#</a></span>\[ \mathrm{trace}(\mathbf{A}^{-1}) \approx \frac{1}{a^2 - b^2} \left( n - \frac{q^{2}}{1 - q^2} \right),\]</div>
<p>where <span class="math notranslate nohighlight">\(q = b/a\)</span>. See <a class="reference internal" href="../generated/imate.sample_matrices.toeplitz_traceinv.html#imate.sample_matrices.toeplitz_traceinv" title="imate.sample_matrices.toeplitz_traceinv"><code class="xref py py-func docutils literal notranslate"><span class="pre">imate.sample_matrices.toeplitz_traceinv()</span></code></a> for details. The above analytic formulas are used as the benchmark solution to test the accuracy of the results.</p>
<section id="elapsed-time-of-computing-log-determinant">
<h3>Elapsed Time of Computing Log-Determinant<a class="headerlink" href="#elapsed-time-of-computing-log-determinant" title="Permalink to this heading">#</a></h3>
<p>The elapsed (wall) time of the computations is shown in the figure below. The Cholesky method is faster than the SLQ method by an order of magnitude, hence it could be considered the preferred algorithm to compute log-determinant.</p>
<p>For large matrix sizes, <span class="math notranslate nohighlight">\(n \geq 2^{19}\)</span>, the elapsed time can be related to the matrix size as <span class="math notranslate nohighlight">\(t \propto n^{\alpha}\)</span>. It can be seen from the slope of the fitted lines in the figure that for the SLQ method, <span class="math notranslate nohighlight">\(\alpha\)</span> is close to 1. This result is consistent with the analytic complexity <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span> derived from <a class="reference internal" href="interpolation.html#equation-comp-slq">(4)</a> and using <span class="math notranslate nohighlight">\(\mathrm{nnz}(\mathbf{A}) \sim n\)</span> for a tri-diagonal matrix. Similarly, for the Cholesky method, <span class="math notranslate nohighlight">\(\alpha \approx 1\)</span>, which corresponds to the analytic complexity of computing log-determinant for matrices obtained from 1D meshes.</p>
<a class="custom-dark reference internal image-reference" href="../_images/compare_methods_analytic_matrix_logdet_time.png"><img alt="../_images/compare_methods_analytic_matrix_logdet_time.png" class="custom-dark align-center" src="../_images/compare_methods_analytic_matrix_logdet_time.png" style="height: 375px;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Cholesky method <a class="reference internal" href="../api/imate.logdet.cholesky.html#imate-logdet-cholesky"><span class="std std-ref">imate.logdet(method=’cholesky’)</span></a> uses <a class="reference external" href="https://scikit-sparse.readthedocs.io/en/latest/cholmod.html#sksparse.cholmod.Factor.logdet">logdet</a> function from SuiteSparse’s Cholmod library, which only supports 64-bit data types. Because of this, the performance test for 32-bit and 128-bit is not available. In contrast, <span class="synco">imate</span>’s implementation of randomized algorithms supports all data types shown in the above figure.</p>
</div>
</section>
<section id="accuracy-of-computing-log-determinant">
<h3>Accuracy of Computing Log-Determinant<a class="headerlink" href="#accuracy-of-computing-log-determinant" title="Permalink to this heading">#</a></h3>
<p>The error of computing <a class="reference internal" href="#equation-logdet3">(1)</a> is shown in the figure below, which is obtained by comparing the results with the benchmark solution <a class="reference internal" href="#equation-formula-logdet3">(5)</a>. The error of the Cholesky method is close to the machine precision (almost zero) since it is a direct method. On the other hand, the error of the <cite>SLQ</cite> method, as a randomized algorithm, is non-zero, yet very small. Such a remarkably small error of the SLQ method is due to the specific matrix used in the test and can be explained by the localized distribution of the eigenvalues of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> which makes the SLQ method very effective in estimating <a class="reference internal" href="#equation-logdet3">(1)</a> with only a few Lanczos iterations. However, for practical matrices, usually, the error of randomized methods is larger than the figure below.</p>
<a class="custom-dark reference internal image-reference" href="../_images/compare_methods_analytic_matrix_logdet_accuracy.png"><img alt="../_images/compare_methods_analytic_matrix_logdet_accuracy.png" class="custom-dark align-center" src="../_images/compare_methods_analytic_matrix_logdet_accuracy.png" style="height: 375px;" /></a>
</section>
<section id="elapsed-time-of-computing-trace-of-inverse">
<h3>Elapsed Time of Computing Trace of Inverse<a class="headerlink" href="#elapsed-time-of-computing-trace-of-inverse" title="Permalink to this heading">#</a></h3>
<p>The elapsed (wall) time of the computations is shown in the figure below. Unlike the above results for log-determinant, the Cholesky method here is significantly slower than the SLQ method. In fact, computing the trace of inverse of matrices is one of the applications where the performance of randomized methods surpasses the direct methods significantly.</p>
<p>The computational complexity can be quantified by the relation between the elapsed time and the matrix size as <span class="math notranslate nohighlight">\(t \propto n^{\alpha}\)</span>. It can be seen from the slope of the fitted lines in the figure that for Hutchinson and SLQ methods, <span class="math notranslate nohighlight">\(\alpha\)</span> is close to 1. This result is consistent with the analytic complexity <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span> derived from <a class="reference internal" href="interpolation.html#equation-comp-hutch">(3)</a> and <a class="reference internal" href="interpolation.html#equation-comp-slq">(4)</a> and using <span class="math notranslate nohighlight">\(\mathrm{nnz}(\mathbf{A}) \sim n\)</span> for a tri-diagonal matrix. Similarly, for the Cholesky method, <span class="math notranslate nohighlight">\(\alpha \approx 2\)</span>, which corresponds to the analytic complexity <span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span> for computing the trace of matrix inverse.</p>
<img alt="../_images/compare_methods_analytic_matrix_traceinv_time.png" class="custom-dark align-center" src="../_images/compare_methods_analytic_matrix_traceinv_time.png" />
</section>
<section id="accuracy-of-computing-trace-of-inverse">
<h3>Accuracy of Computing Trace of Inverse<a class="headerlink" href="#accuracy-of-computing-trace-of-inverse" title="Permalink to this heading">#</a></h3>
<p>The error of computing <a class="reference internal" href="#equation-traceinv3">(2)</a> is obtained from the benchmark solution <a class="reference internal" href="#equation-formula-traceinv3">(6)</a> and shown in the figure below. The error of the Cholesky method is close to the machine precision (almost zero) since it is a direct method. On the other hand, the <cite>SLQ</cite> method, as a randomized algorithm, is non-zero. As mentioned previously, such a remarkable small error of the SLQ method is due to the specific matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> used in the test as its eigenvalues have a localized distribution, allowing the SLQ method to estimate <a class="reference internal" href="#equation-traceinv3">(2)</a> with a few Lanczos iterations.</p>
<a class="custom-dark reference internal image-reference" href="../_images/compare_methods_analytic_matrix_traceinv_accuracy.png"><img alt="../_images/compare_methods_analytic_matrix_traceinv_accuracy.png" class="custom-dark align-center" src="../_images/compare_methods_analytic_matrix_traceinv_accuracy.png" style="height: 375px;" /></a>
</section>
</section>
<section id="test-on-practical-matrices">
<span id="prac-mat"></span><h2>Test on Practical Matrices<a class="headerlink" href="#test-on-practical-matrices" title="Permalink to this heading">#</a></h2>
<p>The performance of algorithms was also examined on practical matrices. The table below shows the practical matrices used in the test, which are chosen from <a class="reference external" href="https://sparse.tamu.edu">SuiteSparse Matrix Collection</a> and are obtained from real applications. The matrices in the table below are all symmetric positive-definite. The number of nonzero elements (nnz) of these matrices increases approximately by a factor of 5 on average and their sparse density remains at the same order of magnitude (except for the first three).</p>
<table class="right2 right3 table">
<thead>
<tr class="row-odd"><th class="head"><p>Matrix Name</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>nnz</p></th>
<th class="head"><p>Density</p></th>
<th class="head"><p>Application</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference external" href="https://sparse.tamu.edu/HB/nos5"><code class="docutils literal notranslate"><span class="pre">nos5</span></code></a></p></td>
<td><p>468</p></td>
<td><p>5,172</p></td>
<td><p>0.02</p></td>
<td><p>Structural Problem</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://sparse.tamu.edu/Bai/mhd4800b"><code class="docutils literal notranslate"><span class="pre">mhd4800b</span></code></a></p></td>
<td><p>4,800</p></td>
<td><p>27,520</p></td>
<td><p>0.001</p></td>
<td><p>Electromagnetics</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://sparse.tamu.edu/Pothen/bodyy6"><code class="docutils literal notranslate"><span class="pre">bodyy6</span></code></a></p></td>
<td><p>19,366</p></td>
<td><p>134,208</p></td>
<td><p>0.0003</p></td>
<td><p>Structural Problem</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://sparse.tamu.edu/AMD/G2_circuit"><code class="docutils literal notranslate"><span class="pre">G2_circuit</span></code></a></p></td>
<td><p>150,102</p></td>
<td><p>726,674</p></td>
<td><p>0.00003</p></td>
<td><p>Circuit Simulation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://sparse.tamu.edu/Wissgott/parabolic_fem"><code class="docutils literal notranslate"><span class="pre">parabolic_fem</span></code></a></p></td>
<td><p>525,825</p></td>
<td><p>3,674,625</p></td>
<td><p>0.00001</p></td>
<td><p>Computational Fluid Dynamics</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://sparse.tamu.edu/Janna/StocF-1465"><code class="docutils literal notranslate"><span class="pre">StocF-1465</span></code></a></p></td>
<td><p>1,465,137</p></td>
<td><p>21,005,389</p></td>
<td><p>0.00001</p></td>
<td><p>Computational Fluid Dynamics</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference external" href="https://sparse.tamu.edu/Janna/Bump_2911"><code class="docutils literal notranslate"><span class="pre">Bump_2911</span></code></a></p></td>
<td><p>2,911,419</p></td>
<td><p>127,729,899</p></td>
<td><p>0.00001</p></td>
<td><p>Structural Problem</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference external" href="https://sparse.tamu.edu/Janna/Queen_4147"><code class="docutils literal notranslate"><span class="pre">Queen_4147</span></code></a></p></td>
<td><p>4,147,110</p></td>
<td><p>329,499,284</p></td>
<td><p>0.00002</p></td>
<td><p>Structural Problem</p></td>
</tr>
</tbody>
</table>
<section id="process-time-of-computing-log-determinant">
<h3>Process Time of Computing Log-Determinant<a class="headerlink" href="#process-time-of-computing-log-determinant" title="Permalink to this heading">#</a></h3>
<p>The elapsed (wall) time of the computations is shown in the figure below. Unlike the results of the Toeplitz matrices, here, the result of comparing the Cholesky method and SLQ method is mixed with the Cholesky method often being marginally faster than the SLQ method. However, the SLQ method is scalable to larger matrices, whereas the Cholesky method often crashes at <span class="math notranslate nohighlight">\(n &gt; 10^8\)</span>.</p>
<img alt="../_images/compare_methods_practical_matrix_logdet_time.png" class="custom-dark align-center" src="../_images/compare_methods_practical_matrix_logdet_time.png" />
</section>
<section id="id1">
<h3>Accuracy of Computing Log-Determinant<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<p>The error of computing log-determinant using the SLQ method is shown in the figure below, which is obtained by comparing with the result of the Cholesky method as a benchmark. For four of the matrices, the error is less than <span class="math notranslate nohighlight">\(1 \%\)</span>. However, for the second and the sixth matrices in the figure, the error is above <span class="math notranslate nohighlight">\(10 \%\)</span>. To reduce the error, a higher number of Monte-Carlo iterations are needed on these matrices.</p>
<a class="custom-dark reference internal image-reference" href="../_images/compare_methods_practical_matrix_logdet_accuracy.png"><img alt="../_images/compare_methods_practical_matrix_logdet_accuracy.png" class="custom-dark align-center" src="../_images/compare_methods_practical_matrix_logdet_accuracy.png" style="height: 375px;" /></a>
</section>
</section>
<section id="varying-algorithm-parameters">
<h2>Varying Algorithm Parameters<a class="headerlink" href="#varying-algorithm-parameters" title="Permalink to this heading">#</a></h2>
<p>A known issue of the Lanczos algorithm is that the eigenvectors computed during the recusance Lanczos iterations lose their orthogonality. A solution to this issue is the re-orthogonalization of the newly computed eigenvectors with either some or all previous eigenvectors, which is known as partial or full orthogonalization, respectively. <span class="synco">imate</span> supports both types of orthogonalization techniques.</p>
<p>In the following tests, the effect of re-orthogonalizations of the eigenvectors and the effect of varying the number of Lanczos iterations are examined.</p>
<section id="id2">
<h3>Process Time of Computing Log-Determinant<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h3>
<p>The test below corresponds to the tri-diagonal matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> (See <a class="reference internal" href="#simple-mat"><span class="std std-ref">Test on Simple Matrices</span></a>) with <span class="math notranslate nohighlight">\(n = 2^{14}\)</span>. The figure below shows the elapsed time (left) and process time (right) of computing the log-determinant versus the number of Lanczos iterations, <span class="math notranslate nohighlight">\(l\)</span> (also known as Lanczos degree). The orange and red curves respectively show the results with and without orthogonalization of the eigenvectors in the Lanczos algorithm. The processing time is proportional to <span class="math notranslate nohighlight">\(\mathcal{O}(l)\)</span> without orthogonalization, which is consistent with the complexity given in <a class="reference internal" href="interpolation.html#equation-comp-slq">(4)</a> when <span class="math notranslate nohighlight">\(\mathrm{nnz}(\mathbf{A})\)</span> is large. However, the processing time is almost <span class="math notranslate nohighlight">\(\mathcal{O}(l^{2})\)</span> with orthogonalization for <span class="math notranslate nohighlight">\(l &lt; 300\)</span>, which is consistent with the complexity of the Gram-Schmit orthogonalization process.</p>
<img alt="../_images/vary_lanczos_degree_analytic_matrix_time.png" class="custom-dark align-center" src="../_images/vary_lanczos_degree_analytic_matrix_time.png" />
<p>Note that at <span class="math notranslate nohighlight">\(l &gt; 300\)</span>, the processing time suddenly increases. This effect does not reflect a mathematical complexity, rather, is due to the fact that the Gram-Schmidt process is a memory-bounded process when the number of vectors is large. Specifically, when <em>full-orthogonalization</em> is used, all previous eigenvectors of the Lanczos iterations should be stored on the memory in a single large array. However, by increasing the number of eigenvectors, the size of the arrays grows larger than the memory bandwidth of the CPU cache, making the memory access significantly inefficient.</p>
</section>
<section id="id3">
<h3>Accuracy of Computing Log-Determinant<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h3>
<p>The figure below shows the error of computing log-determinant by comparing the results with the analytic value in <a class="reference internal" href="#equation-formula-logdet3">(5)</a>. While the full-orthogonalization process in the Lanczos algorithm is an order of magnitude slower than without using orthogonalization, it provides a higher accuracy by an order of magnitude. The figure also implies that only a few Lanczos iterations, <span class="math notranslate nohighlight">\(l = 30 \sim 60\)</span> are sufficient to obtain a reasonable order of accuracy. This result holds for most applications.</p>
<a class="custom-dark reference internal image-reference" href="../_images/vary_lanczos_degree_analytic_matrix_accuracy.png"><img alt="../_images/vary_lanczos_degree_analytic_matrix_accuracy.png" class="custom-dark align-center" src="../_images/vary_lanczos_degree_analytic_matrix_accuracy.png" style="height: 340px;" /></a>
</section>
<section id="process-time-of-computing-trace-of-inverse">
<h3>Process Time of Computing Trace of Inverse<a class="headerlink" href="#process-time-of-computing-trace-of-inverse" title="Permalink to this heading">#</a></h3>
<p>The above tests were also performed on the practical matrices (see <a class="reference internal" href="#prac-mat"><span class="std std-ref">Test on Practical Matrices</span></a>). The figure below corresponds to computing the race of inverse of the matrix <a class="reference external" href="http://sparse.tamu.edu/GHS_psdef/jnlbrng1">jnlbrng1</a> with <span class="math notranslate nohighlight">\(n = 40000\)</span>. The results are very similar to the previous test on simple matrices. Namely, the complexity of the process with and without orthogonalization is <span class="math notranslate nohighlight">\(\mathcal{O}(l^2)\)</span> and <span class="math notranslate nohighlight">\(\mathcal{O}(l)\)</span>, respectively. Also, orthogonalization is by an order of magnitude slower than without orthogonalization and the effect of the cache memory bandwidth can be seen at <span class="math notranslate nohighlight">\(l &gt; 300\)</span>.;</p>
<img alt="../_images/vary_lanczos_degree_practical_matrix_time.png" class="custom-dark align-center" src="../_images/vary_lanczos_degree_practical_matrix_time.png" />
</section>
<section id="id4">
<h3>Accuracy of Computing Trace of Inverse<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<p>The error of computing the trace of inverse of the test matrix is shown below, which is obtained by comparison of the results with the Cholesky method (not shown here). The difference between the error of the process with and without orthogonalization is insignificant, hence, one may not use orthogonalization as it is effectively faster. Also, as suggested by the figure’s results, a practical choice for the number of Lanczos iterations is <span class="math notranslate nohighlight">\(l = 20 \sim 50\)</span> for most applications.</p>
<a class="custom-dark reference internal image-reference" href="../_images/vary_lanczos_degree_practical_matrix_accuracy.png"><img alt="../_images/vary_lanczos_degree_practical_matrix_accuracy.png" class="custom-dark align-center" src="../_images/vary_lanczos_degree_practical_matrix_accuracy.png" style="height: 340px;" /></a>
</section>
</section>
<section id="how-to-reproduce-results">
<h2>How to Reproduce Results<a class="headerlink" href="#how-to-reproduce-results" title="Permalink to this heading">#</a></h2>
<section id="prepare-matrix-data">
<h3>Prepare Matrix Data<a class="headerlink" href="#prepare-matrix-data" title="Permalink to this heading">#</a></h3>
<ol class="arabic">
<li><p>Download all the above-mentioned sparse matrices from <a class="reference external" href="https://sparse.tamu.edu">SuiteSparse Matrix Collection</a>. For instance, download <code class="docutils literal notranslate"><span class="pre">Queen_4147.mat</span></code> from <a class="reference external" href="https://sparse.tamu.edu/Janna/Queen_4147"><code class="docutils literal notranslate"><span class="pre">Queen_4147</span></code></a>.</p></li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/matrices/read_matrix.m"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/matrices/read_matrix.m</span></code></a> to extract sparse matrix data from <code class="docutils literal notranslate"><span class="pre">Queen_4147.mat</span></code>:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">read_matrix</span><span class="p">(</span><span class="s">&#39;Queen_4147.mat&#39;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/matrices/read_matrix.py"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/matrices/read_matrix.py</span></code></a> to convert the outputs of the above script to generate a python pickle file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><style type="text/css">
span.prompt1:before {
  content: "$ ";
}
</style><span class="prompt1">read_matrix.py Queen_4147 float32    <span class="c1"># to generate 32-bit data</span></span>
<span class="prompt1">read_matrix.py Queen_4147 float64    <span class="c1"># to generate 64-bit data</span></span>
<span class="prompt1">read_matrix.py Queen_4147 float128   <span class="c1"># to generate 128-bit data</span></span>
</pre></div></div><p>The output of the above script will be written in <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/matrices"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/matrices/</span></code></a>.</p>
</li>
</ol>
</section>
<section id="perform-numerical-test">
<h3>Perform Numerical Test<a class="headerlink" href="#perform-numerical-test" title="Permalink to this heading">#</a></h3>
<section id="run-locally">
<h4>Run Locally<a class="headerlink" href="#run-locally" title="Permalink to this heading">#</a></h4>
<ul>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/scripts/compare_methods_analytic_matrix.py"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/compare_methods_analytic_matrix.py</span></code></a> to reproduce results for Toeplitz matrices as follows</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/scripts</span>
<span class="prompt1">python ./compare_methods_analytic_matrix.py -a -f logdet     <span class="c1"># log-determinant test</span></span>
<span class="prompt1">python ./compare_methods_analytic_matrix.py -a -f traceinv   <span class="c1"># trace of inverse test</span></span>
</pre></div></div></div></blockquote>
</li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/scripts/compare_methods_practical_matrix.py"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/compare_methods_practical_matrix.py</span></code></a> to reproduce results for practical matrices as follows</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/scripts</span>
<span class="prompt1">python ./compare_methods_practical_matrix.py -a -f logdet     <span class="c1"># log-determinant test</span></span>
</pre></div></div></div></blockquote>
</li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/scripts/vary_lanczos_degree_analytic_matrix.py"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/vary_lanczos_degree_analytic_matrix.py</span></code></a> to reproduce results for varying algorithm parameters on simple matrices:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/scripts</span>
<span class="prompt1">python ./vary_lanczos_degree_analytic_matrix.py</span>
</pre></div></div></div></blockquote>
</li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/scripts/vary_lanczos_degree_practical_matrix.py"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/vary_lanczos_degree_practical_matrix.py</span></code></a> to reproduce results for varying algorithm parameters on practical matrices:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/scripts</span>
<span class="prompt1">python ./vary_lanczos_degree_practical_matrix.py</span>
</pre></div></div></div></blockquote>
</li>
</ul>
</section>
<section id="submit-to-cluster-with-slurm">
<h4>Submit to Cluster with SLURM<a class="headerlink" href="#submit-to-cluster-with-slurm" title="Permalink to this heading">#</a></h4>
<ul>
<li><p>Submit <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/jobfiles/jobfile_compare_methods_analytic_matrix_logdet.sh"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/jobfile_compare_methods_analytic_matrix_logdet.sh</span></code></a> to reproduce results of log-determinant of simple matrices:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/jobfiles</span>
<span class="prompt1">sbatch ./jobfile_compare_methods_analytic_matrix_logdet.sh</span>
</pre></div></div></div></blockquote>
</li>
<li><p>Submit <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/jobfiles/jobfile_compare_methods_analytic_matrix_traceinv.sh"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/jobfile_compare_methods_analytic_matrix_traceinv.sh</span></code></a> to reproduce results of the trace of inverse of simple matrices:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/jobfiles</span>
<span class="prompt1">sbatch ./jobfile_compare_methods_analytic_matrix_traceinv.sh</span>
</pre></div></div></div></blockquote>
</li>
<li><p>Submit <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/jobfiles/jobfile_compare_methods_practical_matrix_logdet.sh"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/jobfile_compare_methods_practical_matrix_logdet.sh</span></code></a> to reproduce results of log-determinant of simple matrices:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/jobfiles</span>
<span class="prompt1">sbatch ./jobfile_compare_methods_practical_matrix_logdet.sh</span>
</pre></div></div></div></blockquote>
</li>
<li><p>Submit <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/jobfiles/jobfile_vary_lanczos_degree_analytic_matrix.sh"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/jobfile_vary_lanczos_degree_analytic_matrix.sh</span></code></a> to reproduce results of varying parameters on simple matrices:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/jobfiles</span>
<span class="prompt1">sbatch ./jobfile_vary_lanczos_degree_analytic_matrix.sh</span>
</pre></div></div></div></blockquote>
</li>
<li><p>Submit <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/jobfiles/jobfile_vary_lanczos_degree_practical_matrix.sh"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/scripts/jobfile_vary_lanczos_degree_practical_matrix.sh</span></code></a> to reproduce results of varying parameters on practical matrices:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1"><span class="nb">cd</span> /imate/benchmark/jobfiles</span>
<span class="prompt1">sbatch ./jobfile_vary_lanczos_degree_practical_matrix.sh</span>
</pre></div></div></div></blockquote>
</li>
</ul>
</section>
</section>
<section id="plot-results">
<h3>Plot Results<a class="headerlink" href="#plot-results" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/notebooks/plot_compare_methods_analytic_matrix_logdet.ipynb"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/notebooks/plot_compare_methods_analytic_matrix_logdet.ipynb</span></code></a> to generate plots for computing the log-determinants of Toeplitz matrices.</p></li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/notebooks/plot_compare_methods_analytic_matrix_traceinv.ipynb"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/notebooks/plot_compare_methods_analytic_matrix_traceinv.ipynb</span></code></a> to generate plots for computing the trace of inverse of Toeplitz matrices.</p></li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/notebooks/plot_compare_methods_analytic_matrix_logdet.ipynb"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/notebooks/plot_compare_methods_analytic_matrix_logdet.ipynb</span></code></a> to generate plots for computing the log-determinants of the practical matrices.</p></li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/notebooks/plot_vary_lanczos_degree_analytic_matrix.ipynb"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/notebooks/plot_vary_lanczos_degree_analytic_matrix.ipynb</span></code></a> to generate plots for varying algorithm parameters on Toeplitz matrices.</p></li>
<li><p>Run <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/notebooks/plot_vary_lanczos_degree_practical_matrix.ipynb"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/notebooks/plot_vary_lanczos_degree_practical_matrix.ipynb</span></code></a> to generate plots for varying algorithm parameters on practical matrices.</p></li>
</ul>
<p>These notebooks stores the plots as <cite>svg</cite> files in <a class="reference external" href="https://github.com/ameli/imate/blob/main/benchmark/svg_plots"><code class="docutils literal notranslate"><span class="pre">/imate/benchmark/svg_plots/</span></code></a>.</p>
</section>
</section>
</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>


    <!-- Adobe Embed API -->
    
    <script src="https://documentcloud.adobe.com/view-sdk/main.js"></script>


  </body>
</html>