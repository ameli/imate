


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Interpolate Trace of Inverse (imate.InterpolateTraceOfInverse) &#8212; imate Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "auto";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom-pydata.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/toggleprompt.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/js/custom-pydata.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/logo-imate.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <script defer data-domain="docs.scipy.org" src="https://views.scientific-python.org/js/script.js"></script>

    <!-- Adobe Embed API -->
    <script src="https://documentcloud.adobe.com/view-sdk/viewer.js"></script>

    <!-- My custom JS -->
    <script type="text/javascript" src="../_static/js/custom-pydata.js"></script>

    <!-- Syntax highlighting for BibTex code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-solarizedlight.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs-bibtex@2.0.1/prism-bibtex.min.js"></script>

    
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">

  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="auto">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../contents.html">
  
  
  
  
    <img src="../_static/images/icons/logo-imate-light.png" class="logo__image only-light" alt="Logo image">
    <img src="../_static/images/icons/logo-imate-dark.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorials/install.html">
  1. Install
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorials/docker.html">
  2. Docker
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorials/gpu.html">
  3. GPU
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../api.html">
  API Reference
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/ameli/imate" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pypi.org/project/imate/" rel="noopener" target="_blank" title="PyPI"><span><i class="fab fa-python"></i></span>
            <label class="sr-only">PyPI</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://anaconda.org/s-ameli/imate" rel="noopener" target="_blank" title="Anaconda Cloud"><span><i class="fa fa-circle-notch"></i></span>
            <label class="sr-only">Anaconda Cloud</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://hub.docker.com/r/sameli/imate" rel="noopener" target="_blank" title="Docker Hub"><span><i class="fab fa-docker"></i></span>
            <label class="sr-only">Docker Hub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://mybinder.org/v2/gh/ameli/imate/HEAD?filepath=notebooks%2FInterpolateTraceOfInverse.ipynb" rel="noopener" target="_blank" title="Lanuch Jupyter on Binder"><span><i class="fa fa-chart-line"></i></span>
            <label class="sr-only">Lanuch Jupyter on Binder</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#usage">
   Usage
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#parameters">
   Parameters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parameters-for-interpolatetraceofinverse-class">
     Parameters for
     <code class="xref py py-mod docutils literal notranslate">
      <span class="pre">
       InterpolateTraceOfInverse
      </span>
     </code>
     Class
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parameters-for-interpolate-function">
     Parameters for
     <code class="xref py py-func docutils literal notranslate">
      <span class="pre">
       Interpolate()
      </span>
     </code>
     Function
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mathematical-details">
   Mathematical Details
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#exact-method">
     Exact Method
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#eigenvalue-method">
     Eigenvalue Method
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#monomial-basis-functions-method">
     Monomial Basis Functions Method
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#root-monomial-basis-functions-method">
     Root Monomial Basis Functions Method
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#radial-basis-functions-method">
     Radial Basis Functions Method
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rational-polynomial-functions-method">
     Rational Polynomial Functions Method
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#examples">
   Examples
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#comparison-of-interpolation-methods">
     Comparison of Interpolation Methods
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#plot-exact-versus-interpolated-function">
     Plot Exact Versus Interpolated Function
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   References
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#api">
   API
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#main-interface">
     Main Interface
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#inheritance-diagram">
     Inheritance Diagram
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#modules">
     Modules
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      

<div class="tocsection editthispage">
    <a href="https://github.com/https://github.com/ameli/imate/edit/main/docs/source/old/InterpolateTraceOfInverse.rst">
        <i class="fas fa-pencil-alt"></i> Edit this page
    </a>
</div>

    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="interpolate-trace-of-inverse-imate-interpolatetraceofinverse">
<span id="interpolatetraceofinverse-userguide"></span><h1>Interpolate Trace of Inverse (<code class="xref py py-mod docutils literal notranslate"><span class="pre">imate.InterpolateTraceOfInverse</span></code>)<a class="headerlink" href="#interpolate-trace-of-inverse-imate-interpolatetraceofinverse" title="Permalink to this heading">#</a></h1>
<p>The sub-package <code class="xref py py-mod docutils literal notranslate"><span class="pre">imate.InterpolateTraceOfInverse</span></code> interpolates the trace of inverse of an affine matrix function <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span>, that is the following function is interpolated for the parameter <span class="math notranslate nohighlight">\(t\)</span>:</p>
<div class="math notranslate nohighlight">
\[t \mapsto \mathrm{trace} \left( (\mathbf{A} + t \mathbf{B})^{-1} \right).\]</div>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this heading">#</a></h2>
<p>In the code below, we create an object of the class <code class="xref py py-mod docutils literal notranslate"><span class="pre">InterpolateTraceOfInverse</span></code>, and then interpolate at an inquiry point <span class="math notranslate nohighlight">\(t\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">imate</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">imate</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a symmetric positive-definite matrix of the shape (20**2,20**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define some interpolant points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">InterpolantPoints</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-2</span><span class="p">,</span><span class="mf">1e-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1e+1</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an interpolating imate object</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="o">=</span><span class="n">InterpolantPoints</span><span class="p">)</span>
</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Interpolate A+tI at some inquiry point t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">4e-1</span>
<span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">trace</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span></pre></div>
</div>
<p>In the above code, we only provided the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> to the module <code class="xref py py-mod docutils literal notranslate"><span class="pre">InterpolateTraceOfInverse</span></code>, which then it assumes <code class="docutils literal notranslate"><span class="pre">B</span></code> is identity matrix by default. To compute the trace of the inverse of <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> is not identity matrix, pass both <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> to <code class="xref py py-mod docutils literal notranslate"><span class="pre">InterpolateTraceOfInverse</span></code> as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate two different symmetric positive-definite matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">DecorrelationScale</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">DecorrelationScale</span><span class="o">=</span><span class="mf">2e-2</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an interpolating imate object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="o">=</span><span class="n">InterpolantPoints</span><span class="p">)</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">DecorrelationScale</span></code> of the class <code class="xref py py-mod docutils literal notranslate"><span class="pre">GenerateMatrix</span></code> in the above specifies the scale of correlation function used to form a positive-definite matrix. We specified two correlation scales to generate different matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>. The user may use their own matrix data.</p>
<p>Interpolation for an array of inquiries points can be made by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create an array of inquiry points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traces</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t_array</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="o">=</span><span class="n">InterpolantPoints</span><span class="p">)</span>
</pre></div>
</div>
<p>The module <code class="xref py py-mod docutils literal notranslate"><span class="pre">InterpolateTraceOfInverse</span></code> can employ various interpolation methods listed in the table below. The method of interpolation can be set by <code class="docutils literal notranslate"><span class="pre">InterpolationMethod</span></code> argument when calling <code class="xref py py-mod docutils literal notranslate"><span class="pre">InterpolateTraceOfInverse</span></code>. The default method is <code class="docutils literal notranslate"><span class="pre">RMBF</span></code>.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a></p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Matrix size</p></th>
<th class="head"><p>Matrix type</p></th>
<th class="head"><p>Results</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'EXT'</span></code></p></td>
<td><p><span class="xref std std-ref">Exact Method</span> (no interpolation)</p></td>
<td><p>Small</p></td>
<td><p>dense, sparse</p></td>
<td><p>exact</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'EIG'</span></code></p></td>
<td><p><span class="xref std std-ref">Eigenvalue Method</span></p></td>
<td><p>Small</p></td>
<td><p>dense, sparse</p></td>
<td><p>exact</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'MBF'</span></code></p></td>
<td><p><span class="xref std std-ref">Monomial Basis Functions Method</span></p></td>
<td><p>Small, large</p></td>
<td><p>dense, sparse</p></td>
<td><p>interpolated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code></p></td>
<td><p><span class="xref std std-ref">Root Monomial Basis Functions Method</span></p></td>
<td><p>small, large</p></td>
<td><p>dense, sparse</p></td>
<td><p>interpolated</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'RBF'</span></code></p></td>
<td><p><span class="xref std std-ref">Radial Basis Functions Method</span></p></td>
<td><p>small, large</p></td>
<td><p>dense, sparse</p></td>
<td><p>interpolated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'RPF'</span></code></p></td>
<td><p><span class="xref std std-ref">Rational Polynomial Functions Method</span></p></td>
<td><p>small, large</p></td>
<td><p>dense, sparse</p></td>
<td><p>interpolated</p></td>
</tr>
</tbody>
</table>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">InterpolateTraceOfInverse</span></code> module internally defines an object of <code class="xref py py-class docutils literal notranslate"><span class="pre">ComputeTraceOfInverse</span></code> (see <a class="reference internal" href="ComputeTraceOfInverse.html#computetraceofinverse-userguide"><span class="std std-ref">Compute Trace of Inverse user guide</span></a>) to evaluate the trace of inverse at the given interpolant points <code class="docutils literal notranslate"><span class="pre">InterpolantPoints</span></code>. You can pass the options for this internal <code class="xref py py-class docutils literal notranslate"><span class="pre">ComputeTraceOfInverse</span></code> object by <code class="docutils literal notranslate"><span class="pre">ComputeOptions</span></code> argument when initializing  <code class="xref py py-mod docutils literal notranslate"><span class="pre">InterpolateTraceOfInverse</span></code>, such as in the example below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify options of the internal ComputeTraceOfInverse object in a dictionary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ComputeOptions</span> <span class="o">=</span> \
<span class="gp">... </span><span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;ComputeMethod&#39;</span><span class="p">:</span> <span class="s1">&#39;hutchinson&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;NumIterations&#39;</span><span class="p">:</span> <span class="mi">20</span>
<span class="gp">... </span><span class="p">}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Pass options by ComputeOptions argument</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">InterpolantPoints</span><span class="o">=</span><span class="n">InterpolantPoints</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">InterpolatingMethod</span><span class="o">=</span><span class="s1">&#39;RMBF&#39;</span><span class="p">,</span>
<span class="hll"><span class="gp">... </span>            <span class="n">ComputeOptions</span><span class="o">=</span><span class="n">ComputeOptions</span><span class="p">)</span>
</span></pre></div>
</div>
</section>
<section id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading">#</a></h2>
<section id="parameters-for-interpolatetraceofinverse-class">
<h3>Parameters for <code class="xref py py-mod docutils literal notranslate"><span class="pre">InterpolateTraceOfInverse</span></code> Class<a class="headerlink" href="#parameters-for-interpolatetraceofinverse-class" title="Permalink to this heading">#</a></h3>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">imate.InterpolateTraceOfInverse</span></code> class accepts the following attributes as input argument.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="A">
<span class="sig-name descname"><span class="pre">A</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.ndarray,</span> <span class="pre">or</span> <span class="pre">scipy.sparse.csc_matrix</span></em><a class="headerlink" href="#A" title="Permalink to this definition">#</a></dt>
<dd><p>An invertible sparse or dense matrix.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="B">
<span class="sig-name descname"><span class="pre">B</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.ndarray,</span> <span class="pre">or</span> <span class="pre">scipy.sparse.csc_matrix</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">numpy.eye,</span> <span class="pre">or</span> <span class="pre">scipy.sparse.eye</span></em><a class="headerlink" href="#B" title="Permalink to this definition">#</a></dt>
<dd><p>An invertible sparse or dense matrix. If not provided, it is assumed that <code class="docutils literal notranslate"><span class="pre">B</span></code> is an identity matrix of the same shape and type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="InterpolantPoints">
<span class="sig-name descname"><span class="pre">InterpolantPoints</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list(float)</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#InterpolantPoints" title="Permalink to this definition">#</a></dt>
<dd><p>List of interpolant points. The trace of inverse at the interpolant points are computed via the exact method using
<code class="xref py py-mod docutils literal notranslate"><span class="pre">imate.ComputeTraceOfInverse</span></code> module. For each <a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a>, the interpolant points should be as follows:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a></p></th>
<th class="head"><p><a class="reference internal" href="#InterpolantPoints" title="InterpolantPoints"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolantPoints</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EXT</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (not required)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EIG</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (not required)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MBF</span></code></p></td>
<td><p>A list of only <em>one</em> point</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RMBF</span></code></p></td>
<td><p>A list of <em>arbitrary number</em> of points</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RBF</span></code></p></td>
<td><p>A list of <em>arbitrary number</em> of points</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RPF</span></code></p></td>
<td><p>A list of either <em>two</em> or <em>four</em> points</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="InterpolationMethod">
<span class="sig-name descname"><span class="pre">InterpolationMethod</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">string</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'RMBF'</span></em><a class="headerlink" href="#InterpolationMethod" title="Permalink to this definition">#</a></dt>
<dd><p>Specifies the method of interpolation. The methods are one of <code class="docutils literal notranslate"><span class="pre">'EXT'</span></code>, <code class="docutils literal notranslate"><span class="pre">'EIG'</span></code>, <code class="docutils literal notranslate"><span class="pre">'MBF'</span></code>, <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code>, <code class="docutils literal notranslate"><span class="pre">'RBF'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'RPF'</span></code> (see <span class="xref std std-ref">Mathematical Details</span>).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ComputeOptions">
<span class="sig-name descname"><span class="pre">ComputeOptions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dict</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#ComputeOptions" title="Permalink to this definition">#</a></dt>
<dd><p>Recall that the trace of inverse at the interpolant points are computed via the exact method using an internal
<code class="xref py py-mod docutils literal notranslate"><span class="pre">imate.ComputeTraceOfInverse</span></code> object within this class. The parameters of this internal object can be passed
by the <a class="reference internal" href="#ComputeOptions" title="ComputeOptions"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ComputeOptions</span></code></a> disctionary. For instance, to</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Verbose">
<span class="sig-name descname"><span class="pre">Verbose</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#Verbose" title="Permalink to this definition">#</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, prints some information during the process.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="NonZeroRatio">
<span class="sig-name descname"><span class="pre">NonZeroRatio</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.9</span></em><a class="headerlink" href="#NonZeroRatio" title="Permalink to this definition">#</a></dt>
<dd><p>This parameter is only applied to <code class="docutils literal notranslate"><span class="pre">'EIG'</span></code> method.</p>
<p>In the case of large sparse input matrices, it is not possible to find all the eigenvalues.
However, often most of the eigenvalues of the matrices in many a applications are near zero. This
parameter is a number in the range <span class="math notranslate nohighlight">\([0,1]\)</span> and sets a fraction of the eigenvalues to
be assumed nonzero.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Tolerance">
<span class="sig-name descname"><span class="pre">Tolerance</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-3</span></em><a class="headerlink" href="#Tolerance" title="Permalink to this definition">#</a></dt>
<dd><p>This parameter is only applied to <code class="docutils literal notranslate"><span class="pre">'EIG'</span></code> method.
Sets the tolerance of finding the eigenvalues in case the input matrices are sparse.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="FunctionType">
<span class="sig-name descname"><span class="pre">FunctionType</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#FunctionType" title="Permalink to this definition">#</a></dt>
<dd><p>This parameter is only applied to <code class="docutils literal notranslate"><span class="pre">'RBF'</span></code> method. This parameter can be either <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, or
<code class="docutils literal notranslate"><span class="pre">3</span></code> and speficies three function types interpolation.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="BasisFunctionsType">
<span class="sig-name descname"><span class="pre">BasisFunctionsType</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">string</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'Orthogonal2'</span></em><a class="headerlink" href="#BasisFunctionsType" title="Permalink to this definition">#</a></dt>
<dd><p>This parameter is only applied to <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code> method. This parameter can be either of
<code class="docutils literal notranslate"><span class="pre">'NonOrthogonal'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Orthogonal'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'Orthogonal2'</span></code>, which specifies the type
of basis functions used in the interpolation.</p>
</dd></dl>

</section>
<section id="parameters-for-interpolate-function">
<h3>Parameters for <code class="xref py py-func docutils literal notranslate"><span class="pre">Interpolate()</span></code> Function<a class="headerlink" href="#parameters-for-interpolate-function" title="Permalink to this heading">#</a></h3>
<p>The <code class="xref py py-func docutils literal notranslate"><span class="pre">imate.InterpolateTraceOfInverse.Interpolate()</span></code> function accepts the following attributes as input argument.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="t">
<span class="sig-name descname"><span class="pre">t</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">scalar,</span> <span class="pre">or</span> <span class="pre">numpy.array</span></em><a class="headerlink" href="#t" title="Permalink to this definition">#</a></dt>
<dd><p>An inquiry point (or an array of inquiry points) to interpolate.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="CompareWithExact">
<span class="sig-name descname"><span class="pre">CompareWithExact</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#CompareWithExact" title="Permalink to this definition">#</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, it computes the trace with exact solution, then compares it with the interpolated
solution. When this option is enabled, the function <code class="xref py py-func docutils literal notranslate"><span class="pre">Interpolate()</span></code>
returns a tuple with the following three quantities:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>interpolated trace (single number or array)</p></li>
<li><p>exact solution (sngle number or array)</p></li>
<li><p>Relative error of interpolated trace compared with the exact solution</p></li>
</ol>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When the option <a class="reference internal" href="#CompareWithExact" title="CompareWithExact"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CompareWithExact</span></code></a> is enabled, depending on the matrix size and the length of the input array <a class="reference internal" href="#t" title="t"><code class="xref py py-attr docutils literal notranslate"><span class="pre">t</span></code></a>,
the processing time will be significantly longer. This is becase the solution will be computed for all inquiry points
using the exact method (besides the interpolation). Use this option only for test purposes (benchmarking) on small matrices.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="Plot">
<span class="sig-name descname"><span class="pre">Plot</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#Plot" title="Permalink to this definition">#</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, it plots the interpolated trace versus the inquiry points.</p>
<ul class="simple">
<li><p>If the option <a class="reference internal" href="#CompareWithExact" title="CompareWithExact"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CompareWithExact</span></code></a> is also set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the plotted diagram contains both interpolated
and exact solutions, together with the <em>relative error</em> of interpolated solution with respect to the exact solution.</p></li>
<li><p>If no graphical backend exists (such as running the code on a remote server or manually disabling the X11 backend),
the plot will not be shown, rather, it will be saved as an <code class="docutils literal notranslate"><span class="pre">svg</span></code> file in the current directory.</p></li>
<li><p>If the executable <code class="docutils literal notranslate"><span class="pre">latex</span></code> can be found on the path, the plot is rendered using <span class="math notranslate nohighlight">\(\rm\LaTeX\)</span>, which then,
it takes a bit longer to produce the plot.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\rm\LaTeX\)</span> is not installed, it uses any available San-Serif font to render the plot.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To manually disable interactive plot display, and save the plot as <code class="docutils literal notranslate"><span class="pre">SVG</span></code> instead, add the following in the
very begining of your code before importing <code class="docutils literal notranslate"><span class="pre">imate</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;IMATE_NO_DISPLAY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;True&#39;</span>
</pre></div>
</div>
</div>
</dd></dl>

</section>
</section>
<section id="mathematical-details">
<h2>Mathematical Details<a class="headerlink" href="#mathematical-details" title="Permalink to this heading">#</a></h2>
<p>In the methods that follows (except the exact and the eigenvalues method), instead of interpolating the function
<span class="math notranslate nohighlight">\(t \mapsto \mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right)\)</span>, the function <span class="math notranslate nohighlight">\(t \mapsto \tau(t)\)</span>
is interpolated, where <span class="math notranslate nohighlight">\(\tau(t)\)</span> is defined by</p>
<div class="math notranslate nohighlight">
\[\tau(t) = \frac{\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right)}{\mathrm{trace}\left(\mathbf{B}^{-1} \right)}.\]</div>
<p>Also, we define</p>
<div class="math notranslate nohighlight">
\[\tau_0 = \tau(0) = \frac{\mathrm{trace} \left( \mathbf{A}^{-1} \right)}{\mathrm{trace} \left( \mathbf{B}^{-1} \right)}.\]</div>
<section id="exact-method">
<h3>Exact Method<a class="headerlink" href="#exact-method" title="Permalink to this heading">#</a></h3>
<p>The exact method (by setting <a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a> to <code class="docutils literal notranslate"><span class="pre">'EXT'</span></code>) do not perform any interpolation on the inquiry
point. Rather, it computes the trace of inverse directly via the <code class="xref py py-mod docutils literal notranslate"><span class="pre">imate.ComputeTraceOfInverse</span></code> module. This method
is primarily used for comparing the result of other methods with a benchmark solution. For details of computation,
see <a class="reference internal" href="ComputeTraceOfInverse.html#computetraceofinverse-userguide"><span class="std std-ref">Compute Trace of Inverse</span></a> user guide.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Since this method does not perform interpolation, the process time is proportional to the number of the inquity points <span class="math notranslate nohighlight">\(t\)</span>.</p>
</div>
</section>
<section id="eigenvalue-method">
<h3>Eigenvalue Method<a class="headerlink" href="#eigenvalue-method" title="Permalink to this heading">#</a></h3>
<p>This method is employed by setting <a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a> to <code class="docutils literal notranslate"><span class="pre">'EIG'</span></code>. The trace of inverse is computed via</p>
<div class="math notranslate nohighlight">
\[\mathrm{trace}\left( (\mathbf{A} + t \mathbf{B})^{-1} \right) = \sum_{i = 1}^n \frac{1}{\lambda_i + t \mu_i}\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda_i\)</span> is the eigenvalue of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mu_i\)</span> is the eigenvalue of <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>.
This class does not accept interpolant points as the result is not interpolated.</p>
<p>For dense matrices, the results of this method is identical to the exact (<code class="docutils literal notranslate"><span class="pre">'EXT'</span></code>) method as no approximation has been
made. For sparse matrices, however, it is not possible to compute all spectrum of a large matrix, and the small
eigenvalues are assumed to be zero, Hence, the results are very close, yet not the same, as the exact method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the fastest and most accurate interpolation method, but can only be applied on small matrices.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is not suitable for large matrices, and practically, may stall and never return output.</p>
</div>
</section>
<section id="monomial-basis-functions-method">
<h3>Monomial Basis Functions Method<a class="headerlink" href="#monomial-basis-functions-method" title="Permalink to this heading">#</a></h3>
<p>This method is invoked by setting <a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a> to <code class="docutils literal notranslate"><span class="pre">'MBF'</span></code>. The trace of inverse is computed via
Computes the trace of inverse of an invertible matrix <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span> using</p>
<div class="math notranslate nohighlight">
\[\frac{1}{(\tau(t))^{p+1}} \approx \frac{1}{(\tau_0)^{p+1}} + \sum_{i=1}^{p+1} w_i t^i,\]</div>
<p>where <span class="math notranslate nohighlight">\(w_{p+1} = 1\)</span>. To find the weight coefficient <span class="math notranslate nohighlight">\(w_1\)</span>, the trace is computed at the given interpolant point <span class="math notranslate nohighlight">\(t_1\)</span>
(see <a class="reference internal" href="#InterpolantPoints" title="InterpolantPoints"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolantPoints</span></code></a> argument).</p>
<p>When <span class="math notranslate nohighlight">\(p = 1\)</span>, meaning that there is only one interpolant point <span class="math notranslate nohighlight">\(t_1\)</span> with the function value <span class="math notranslate nohighlight">\(\tau_1 = \tau(t_1)\)</span>, the
weight coefficient <span class="math notranslate nohighlight">\(w_1\)</span> can be solved easily. In this case, the interpolation function becomes</p>
<div class="math notranslate nohighlight">
\[\frac{1}{(\tau(t))^2} \approx  \frac{1}{\tau_0^2} + t^2 + \left( \frac{1}{\tau_1^2} - \frac{1}{\tau_0^2} - t_1^2 \right) \frac{t}{t_1}.\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class accepts only <em>one</em> interpolant point (<span class="math notranslate nohighlight">\(p = 1\)</span>). That is, the parameter <a class="reference internal" href="#InterpolantPoints" title="InterpolantPoints"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolantPoints</span></code></a> should be only
one number or a list of the length one.</p>
</div>
</section>
<section id="root-monomial-basis-functions-method">
<h3>Root Monomial Basis Functions Method<a class="headerlink" href="#root-monomial-basis-functions-method" title="Permalink to this heading">#</a></h3>
<p>This method is invoked by setting <a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a> to <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code>. In this method, the function <span class="math notranslate nohighlight">\((\tau(t))^{-1}\)</span>
is approximated via</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\tau(t)} \approx \frac{1}{\tau_0} + \sum_{i = 0}^p w_i \phi_i(t),\]</div>
<p>where  <span class="math notranslate nohighlight">\(\phi_i\)</span> are some known basis functions, and <span class="math notranslate nohighlight">\(w_i\)</span> are the coefficients of the linear basis functions.
The first coefficient is set to <span class="math notranslate nohighlight">\(w_{0} = 1\)</span> and the rest of the weights
are to be found form the known function values <span class="math notranslate nohighlight">\(\tau_i = \tau(t_i)\)</span> at some given interpolant points <span class="math notranslate nohighlight">\(t_i\)</span>.</p>
<p><strong>Basis Functions:</strong></p>
<p>Two types of basis functions can be set by the argument <a class="reference internal" href="#BasisFunctionsType" title="BasisFunctionsType"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BasisFunctionsType</span></code></a>.</p>
<ol class="arabic">
<li><p>When <a class="reference internal" href="#BasisFunctionsType" title="BasisFunctionsType"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BasisFunctionsType</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">NonOrthogonal</span></code>, the basis functions are the root of the monomial functions defined by</p>
<div class="math notranslate nohighlight">
\[\phi_i(t) = t^{\frac{1}{i+1}}, \qquad i = 0,\dots,p.\]</div>
</li>
<li><p>When <a class="reference internal" href="#BasisFunctionsType" title="BasisFunctionsType"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BasisFunctionsType</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">'Orthogonal'</span></code> or <code class="docutils literal notranslate"><span class="pre">'Orthogonal2'</span></code>, the orthogonal form of the
above basis functions are used. Orthogonal basis functions are formed by the above non-orthogonal functions
as</p>
<div class="math notranslate nohighlight">
\[\phi_i^{\perp}(t) = \alpha_i \sum_{j=1}^i a_{ij} \phi_j(t)\]</div>
<p>The coefficients <span class="math notranslate nohighlight">\(\alpha_i\)</span> and <span class="math notranslate nohighlight">\(a_{ij}\)</span> can be obtained by the python package
<a class="reference external" href="https://ameli.github.io/Orthogonal-Functions">Orthogoanl Functions</a>. These coefficients are
hard-coded in this function up to <span class="math notranslate nohighlight">\(i = 9\)</span>. Thus, in this module, up to nine interpolant points
are supported.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The non-orthogonal basis functions can lead to ill-conditioned system of equations for finding the weight
coefficients <span class="math notranslate nohighlight">\(w_i\)</span>. When the number of interpolating points is large (such as <span class="math notranslate nohighlight">\(p &gt; 6\)</span>),
it is recommended to use the orthogonalized set of basis functions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The recommended basis function type is <code class="docutils literal notranslate"><span class="pre">'Orthogonal2'</span></code>.</p>
</div>
</li>
</ol>
</section>
<section id="radial-basis-functions-method">
<h3>Radial Basis Functions Method<a class="headerlink" href="#radial-basis-functions-method" title="Permalink to this heading">#</a></h3>
<p>This method is invoked by setting <a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a> to <code class="docutils literal notranslate"><span class="pre">'RBF'</span></code>. In this method, the function <span class="math notranslate nohighlight">\(\tau(t)\)</span>
is approximated by radial basis functions. Define</p>
<div class="math notranslate nohighlight">
\[x(t) = \log t\]</div>
<p>Depending whether <a class="reference internal" href="#FunctionType" title="FunctionType"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FunctionType</span></code></a> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, or <code class="docutils literal notranslate"><span class="pre">3</span></code>, one of the following functions is defined:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray}
y_1(t) &amp;= \frac{1}{\tau(t)} - \frac{1}{\tau_0} - t, \\
y_2(t) &amp;= \frac{\frac{1}{\tau(t)}}{\frac{1}{\tau_0} + t} - 1, \\
y_3(t) &amp;= 1 - \tau(t) \left( \frac{1}{\tau_0} + t \right).
\end{eqnarray}</div><ul class="simple">
<li><p>The set of data <span class="math notranslate nohighlight">\((x,y_1(x))\)</span> are interpolated using <em>cubic splines</em>.</p></li>
<li><p>The set of data <span class="math notranslate nohighlight">\((x,y_2(x))\)</span> and <span class="math notranslate nohighlight">\((x,y_3(x))\)</span> are interpolated using <em>Gaussian radial basis functions</em>.</p></li>
</ul>
</section>
<section id="rational-polynomial-functions-method">
<h3>Rational Polynomial Functions Method<a class="headerlink" href="#rational-polynomial-functions-method" title="Permalink to this heading">#</a></h3>
<p>This method is invoked by setting <a class="reference internal" href="#InterpolationMethod" title="InterpolationMethod"><code class="xref py py-attr docutils literal notranslate"><span class="pre">InterpolationMethod</span></code></a> to <code class="docutils literal notranslate"><span class="pre">'RPF'</span></code>.
In this method, the function <span class="math notranslate nohighlight">\(\tau(t)\)</span> is approximated by</p>
<div class="math notranslate nohighlight">
\[\tau(t) \approx \frac{t^p + a_{p-1} t^{p-1} + \cdots + a_1 t + a_0}{t^{p+1} + b_p t^p + \cdots + b_1 t + b_0}\]</div>
<p>where <span class="math notranslate nohighlight">\(a_0 = b_0 \tau_0\)</span>. The rest of coefficients are found by solving a linear system using the
function value at the interpolant points <span class="math notranslate nohighlight">\(\tau_i = \tau(t_i)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The number of interpolant points <span class="math notranslate nohighlight">\(p\)</span> in this method can only be either <span class="math notranslate nohighlight">\(p = 2\)</span> or <span class="math notranslate nohighlight">\(p = 4\)</span>.</p>
</div>
</section>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">#</a></h2>
<section id="comparison-of-interpolation-methods">
<h3>Comparison of Interpolation Methods<a class="headerlink" href="#comparison-of-interpolation-methods" title="Permalink to this heading">#</a></h3>
<p>The following code compares the methods <code class="docutils literal notranslate"><span class="pre">'EXT'</span></code>, <code class="docutils literal notranslate"><span class="pre">'EIG'</span></code>, <code class="docutils literal notranslate"><span class="pre">'MBF'</span></code>, <code class="docutils literal notranslate"><span class="pre">'RMBF'</span></code>, <code class="docutils literal notranslate"><span class="pre">'RBF'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'RPF'</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Import packages</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">imate</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">imate</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate two symmetric and positive-definite matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">UseSparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">UseSparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">DecorrelationScale</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="go"># Specify interpolation points and the inquiry point</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">InterpolantPoints</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-4</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">,</span><span class="mf">1e-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1e+1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">InquiryPoint</span> <span class="o">=</span> <span class="mf">0.4</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify options to pass to the internal imate.ComputeTraceOfInverse module</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ComputeOptions</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ComputeMethod&#39;</span><span class="p">:</span><span class="s1">&#39;cholesky&#39;</span><span class="p">,</span><span class="s1">&#39;UseInverseMatrix&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute exact trace without interpolation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI0</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolationMethod</span><span class="o">=</span><span class="s1">&#39;EXT&#39;</span><span class="p">,</span><span class="n">ComputeOptions</span><span class="o">=</span><span class="n">ComputeOptions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T0</span> <span class="o">=</span> <span class="n">TI0</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">InquiryPoint</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Eigenvalues Method</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI1</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolationMethod</span><span class="o">=</span><span class="s1">&#39;EIG&#39;</span><span class="p">,</span><span class="n">ComputeOptions</span><span class="o">=</span><span class="n">ComputeOptions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T1</span> <span class="o">=</span> <span class="n">TI1</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">InquiryPoint</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Monomial Basis Functions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI2</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolationMethod</span><span class="o">=</span><span class="s1">&#39;MBF&#39;</span><span class="p">,</span><span class="n">ComputeOptions</span><span class="o">=</span><span class="n">ComputeOptions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T2</span> <span class="o">=</span> <span class="n">TI2</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">InquiryPoint</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Root Monomial Basis Functions, basis type: Orthogonal2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI3</span><span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="o">=</span><span class="n">InterpolantPoints</span><span class="p">,</span><span class="n">InterpolationMethod</span><span class="o">=</span><span class="s1">&#39;RMBF&#39;</span><span class="p">,</span><span class="n">BasisFunctionsType</span><span class="o">=</span><span class="s1">&#39;Orthogonal2&#39;</span><span class="p">,</span><span class="n">ComputeOptions</span><span class="o">=</span><span class="n">ComputeOptions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T3</span> <span class="o">=</span> <span class="n">TI3</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">InquiryPoint</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Radial Basis Functions, FunctionType 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI4</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="o">=</span><span class="n">InterpolantPoints</span><span class="p">,</span><span class="n">InterpolationMethod</span><span class="o">=</span><span class="s1">&#39;RBF&#39;</span><span class="p">,</span><span class="n">FunctionType</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ComputeOptions</span><span class="o">=</span><span class="n">ComputeOptions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T4</span> <span class="o">=</span> <span class="n">TI4</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">InquiryPoint</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Rational Polynomial with four interpolating points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">InterpolantPoints</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-2</span><span class="p">,</span><span class="mf">1e-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1e+1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI5</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="o">=</span><span class="n">InterpolantPoints</span><span class="p">,</span><span class="n">InterpolationMethod</span><span class="o">=</span><span class="s1">&#39;RPF&#39;</span><span class="p">,</span><span class="n">ComputeOptions</span><span class="o">=</span><span class="n">ComputeOptions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T5</span> <span class="o">=</span> <span class="n">TI5</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">InquiryPoint</span><span class="p">)</span>
</pre></div>
</div>
<p>The results are given in the table below. The last column of the table shows the relative error with respect to the exact method (first row).</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Method</p></th>
<th class="head"><p>Result</p></th>
<th class="head"><p>Error</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">T0</span></code></p></td>
<td><p><span class="xref std std-ref">Exact Method</span> (no interpolation)</p></td>
<td><p>590.4149</p></td>
<td><p>0.00%</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">T1</span></code></p></td>
<td><p><span class="xref std std-ref">Eigenvalue Method</span></p></td>
<td><p>590.4954</p></td>
<td><p>0.01%</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">T2</span></code></p></td>
<td><p><span class="xref std std-ref">Monomial Basis Functions Method</span></p></td>
<td><p>590.2722</p></td>
<td><p>0.02%</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">T3</span></code></p></td>
<td><p><span class="xref std std-ref">Root Monomial Basis Functions Method</span></p></td>
<td><p>590.4579</p></td>
<td><p>0.01%</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">T4</span></code></p></td>
<td><p><span class="xref std std-ref">Radial Basis Functions Method</span></p></td>
<td><p>590.1533</p></td>
<td><p>0.04%</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">T5</span></code></p></td>
<td><p><span class="xref std std-ref">Rational Polynomial Functions Method</span></p></td>
<td><p>590.4157</p></td>
<td><p>0.00%</p></td>
</tr>
</tbody>
</table>
</section>
<section id="plot-exact-versus-interpolated-function">
<h3>Plot Exact Versus Interpolated Function<a class="headerlink" href="#plot-exact-versus-interpolated-function" title="Permalink to this heading">#</a></h3>
<p>In this example, we use the default method (<code class="docutils literal notranslate"><span class="pre">RMBF</span></code>), but interpolate for an array of inquiry points <code class="docutils literal notranslate"><span class="pre">t</span></code>. Also, we compare the results with the exact method (<code class="docutils literal notranslate"><span class="pre">EXT</span></code>) and plot the errors.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate symmetric and positive-definite matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">imate</span> <span class="kn">import</span> <span class="n">GenerateMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">DecorrelationScale</span><span class="o">=</span><span class="mf">0.20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">GenerateMatrix</span><span class="p">(</span><span class="n">NumPoints</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">DecorrelationScale</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify interpolation points, and create interpolating object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">imate</span> <span class="kn">import</span> <span class="n">InterpolateTraceOfInverse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">InterpolantPoints</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-3</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">,</span><span class="mf">1e-1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1e+1</span><span class="p">,</span><span class="mf">1e+2</span><span class="p">,</span><span class="mf">1e+3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TI</span> <span class="o">=</span> <span class="n">InterpolateTraceOfInverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">InterpolantPoints</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Specify an array of inquiry points, then interpolate at inquiry points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trace_interpolated</span><span class="p">,</span> <span class="n">trace_exact</span><span class="p">,</span> <span class="n">relative_error</span> <span class="o">=</span> <span class="n">TI</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">CompareWithExact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">Plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The above code produces the following plot. The interpolant points are shown by the red dots. The red curve on the left plot is behind the black curve, since the interpolation is very close to the exact values. Note that because of setting <a class="reference internal" href="#CompareWithExact" title="CompareWithExact"><code class="xref py py-attr docutils literal notranslate"><span class="pre">CompareWithExact</span></code></a> to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the above code takes more processing time since it also computes the exact values for all elements of the array <code class="docutils literal notranslate"><span class="pre">t</span></code>. Without enabling this option, the interpolation takes significantly less processing time.</p>
<img alt="old/images/InterpolationResults.svg" class="align-center" src="old/images/InterpolationResults.svg" /></section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<div role="list" class="citation-list">
<div class="citation" id="ameli-2020" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Ameli-2020<span class="fn-bracket">]</span></span>
<p>Ameli, S., and Shadden. S. C. (2020). Interpolating the Trace of the Inverse of Matrix <span class="math notranslate nohighlight">\(\mathbf{A} + t \mathbf{B}\)</span>. <a class="reference external" href="https://arxiv.org/abs/2009.07385">arXiv:2009.07385</a> [math.NA]</p>
</div>
</div>
</section>
<section id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this heading">#</a></h2>
<section id="main-interface">
<h3>Main Interface<a class="headerlink" href="#main-interface" title="Permalink to this heading">#</a></h3>
</section>
<section id="inheritance-diagram">
<h3>Inheritance Diagram<a class="headerlink" href="#inheritance-diagram" title="Permalink to this heading">#</a></h3>
</section>
<section id="modules">
<h3>Modules<a class="headerlink" href="#modules" title="Permalink to this heading">#</a></h3>
</section>
</section>
</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2022, Siavash Ameli.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.1.1.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>